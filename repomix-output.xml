This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
prisma/
  schema.prisma
  seed.ts
src/
  api/
    addresses/
      dto/
        users/
          create-user-address.dto.ts
          update-user-address.dto.ts
        vendors/
          create-vendor-address.dto.ts
          update-vendor-address.dto.ts
        create-address.dto.ts
        update-address.dto.ts
      interfaces/
        delete-vendor-address-by-id.interface.ts
      providers/
        users/
          create-user-address.provider.ts
          find-user-address-by-id.provider.ts
          update-user-address.provider.ts
        vendors/
          create-vendor-address.provider.ts
          delete-vendor-address-by-id.provider.ts
          find-vendor-addresses-by-id.provider.ts
          update-vendor-address.provider.ts
        delete-address-by-id.provider.ts
        find-address-by-id.provider.ts
        find-all-addresses.provider.ts
        find-one-address.provider.ts
        update-address-by-id.provider.ts
      addresses.controller.ts
      addresses.module.ts
      addresses.service.ts
    auth/
      constants/
        auth.constant.ts
      decorators/
        active-user.decorator.ts
        auth.decorator.ts
        index.ts
        role.decorator.ts
      dtos/
        forgot-password.dto.ts
        refresh-token.dto.ts
        reset-password.dto.ts
        sign-in.dto.ts
        sign-up.dto.ts
      enums/
        auth-type.enum.ts
      guards/
        access-token/
          access-token.guard.ts
        authentication/
          authentication.guard.ts
        authorization/
          authorization.guard.ts
      interfaces/
        active-user-data.interface.ts
      providers/
        hash-password/
          bcrypt.provider.ts
          hashing.provider.ts
        jwt-token/
          generate-token.provider.ts
          refresh-token.provider.ts
        password-reset/
          forgot-password.provider.ts
          reset-password.provider.ts
        sign-in/
          sign-in.provider.ts
        sign-up/
          sign-up.provider.ts
      auth.controller.ts
      auth.module.ts
      auth.service.ts
    cart/
      dto/
        create-cart.dto.ts
        update-cart.dto.ts
      providers/
        create-cart.provider.ts
        find-my-cart.provider.ts
        find-my-carts.provider.ts
        find-one-cart.provider.ts
      cart.controller.ts
      cart.module.ts
      cart.service.ts
    cart_items/
      dto/
        create-cart_item.dto.ts
        update-cart_item.dto.ts
      interfaces/
        delete-cart-item-by-id.interface.ts
        find-cart-by-id.interface.ts
      providers/
        create-cart-item.provider.ts
        delete-cart-item-by-id.provider.ts
        find-all-cart-items.provider.ts
        find-cart-item-by-id.provider.ts
        find-one-cart-item.provider.ts
        find-user-cart-items.provider.ts
        index.ts
        update-cart-item-by-id.provider.ts
      cart_items.controller.ts
      cart_items.module.ts
      cart_items.service.ts
    categories/
      dto/
        create-category.dto.ts
        update-category.dto.ts
      providers/
        create-category.provider.ts
        delete-category-by-id.provider.ts
        find-all-categories.provider.ts
        find-category-by-id.provider.ts
        find-one-category.provider.ts
        index.ts
        update-category-by-id.provider.ts
      categories.controller.ts
      categories.module.ts
      categories.service.ts
    order_items/
      order_items.controller.ts
      order_items.module.ts
      order_items.service.ts
    orders/
      dtos/
        checkout.dto.ts
        update-order-status.dto.ts
      helpers/
        checkStatusTransition.ts
      providers/
        check-out.provider.ts
        find-all-orders.provider.ts
        find-all-vendor-orders.provider.ts
        find-my-order.provider.ts
        find-my-orders.provider.ts
        find-one-order.provider.ts
        find-order-by-id.provider.ts
        index.ts
        update-order-status-by-id.provider.ts
      orders.controller.ts
      orders.module.ts
      orders.service.ts
    payments/
      chapa/
        dtos/
          initialize-order-payment.dto.ts
          verify-order-payment.dto.ts
        interfaces/
          supported-bank-info.interface.ts
        providers/
          find-supported-bank-infos.provider.ts
          initialize-order-payment.provider.ts
          verify-order-payment.provider.ts
        chapa.controller.ts
        chapa.service.ts
      payments.module.ts
    products/
      dto/
        create-product.dto.ts
        get-products.dto.ts
        update-product.dto.ts
      enum/
        product-unit.enum.ts
      interfaces/
        delete-product-by-id.interface.ts
      providers/
        create-product.provider.ts
        delete-product-by-id.provider.ts
        find-all-products.provider.ts
        find-one-product.provider.ts
        find-product-by-id.provider.ts
        find-products-by-category.provider.ts
        index.ts
        update-product-by-id.provider.ts
      products.controller.ts
      products.module.ts
      products.service.ts
    reviews/
      dto/
        create-review.dto.ts
        update-review.dto.ts
      reviews.controller.ts
      reviews.module.ts
      reviews.service.ts
    users/
      dto/
        complete-onboarding.dto.ts
        create-user.dto.ts
        index.ts
        update-profile-picture.dto.ts
        update-user-data.dto.ts
        update-user-password.dto.ts
        update-user.dto.ts
        verify-user.dto.ts
      providers/
        account/
          complete-onboarding.provider.ts
          find-all-verification-requests.provider.ts
          request-account-verification.provider.ts
          update-profile-picture.provider.ts
          update-user-data.provider.ts
          update-user-password.provider.ts
          verify-user.provider.ts
        crud/
          create-user.provider.ts
          delete-user-by-id.provider.ts
          find-all-users.provider.ts
          find-user-by-id.provider.ts
          update-user-by-id.provider.ts
        find-one-user.provider.ts
      users.controller.ts
      users.module.ts
      users.service.ts
    vendors/
      vender_transaction/
        vender_transaction.controller.ts
        vender_transaction.module.ts
        vender_transaction.service.ts
      vendor_balance/
        vendor_balance.controller.ts
        vendor_balance.module.ts
        vendor_balance.service.ts
      vendor_bank_account/
        dtos/
          create-back-account.dto.ts
          update-bank-account.dto.ts
        vendor_bank_account.controller.ts
        vendor_bank_account.module.ts
        vendor_bank_account.service.ts
      vendors/
        dto/
          create-vendor.dto.ts
          update-vendor.dto.ts
        providers/
          create-vendor.provider.ts
          delete-vendor.provider.ts
          find-all-vendors.provider.ts
          find-one-vendor.provider.ts
          find-vendor-by-id.provider.ts
          update-vendor.provider.ts
        vendors.controller.ts
        vendors.module.ts
        vendors.service.ts
      withdrawal_request/
        dtos/
          create-withdrawal-request.dto.ts
          process-withdrawal.dto.ts
        withdrawal_request.controller.ts
        withdrawal_request.module.ts
        withdrawal_request.service.ts
      vendors_root.module.ts
    wishlist/
      interfaces/
        create-wishlist.interface.ts
      wishlist.controller.ts
      wishlist.module.ts
      wishlist.service.ts
  common/
    configuration/
      config/
        app.config.ts
        cookies.config.ts
        database.config.ts
        email.config.ts
        index.ts
        jwt.config.ts
        payment.config.ts
        twilio.config.ts
      configuration.module.ts
      environment.validation.ts
    decorators/
      check-password-confirm.decorator.ts
      email-or-phone.decorator.ts
    email/
      interfaces/
        send-email.interface.ts
      email.module.ts
      email.service.ts
    file-upload/
      file-upload.module.ts
      file-upload.service.ts
    interceptors/
      data-response/
        data-response.interceptor.ts
      serialize-prisma-decimals/
        decimal.interceptor.ts
      interceptors.module.ts
    message/
      interfaces/
        send-sms.interface.ts
      message.module.ts
      message.service.ts
    pagination/
      dtos/
        pagination-query.dto.ts
    pinno-logger/
      pinno-logger.module.ts
    prisma/
      prisma.module.ts
      prisma.service.ts
    swagger/
      swagger.module.ts
    types/
      api-response.type.ts
  lib/
    constants/
      default-images.ts
      file-upload-dir-names.ts
      max-image-file-size.ts
      pg-unique-violation-err-code.ts
    helpers/
      day-to-timestamp.ts
      get-reset-password-email-template.helper.ts
    utils/
      create-api-response.util.ts
  app.controller.ts
  app.module.ts
  main.ts
test/
  app.e2e-spec.ts
  jest-e2e.json
.eslintrc.js
.gitignore
.prettierrc
add-to-cart-flow.md
check-out-flow.md
db-diagram.txt
db.md
nest-cli.json
order-related-endpoints.md
package.json
README.md
todo.md
tsconfig.build.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="prisma/schema.prisma">
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  first_name                      String?
  last_name                       String?
  // incase users dont have an email address
  email                           String
  phone_number                    String                  @unique
  password                        String
  date_of_birth                   DateTime?
  gender                          Gender?
  profile_picture                 String?
  role                            UserRole                @default(CUSTOMER)
  status                          UserStatus              @default(ACTIVE)
  authProvider                    AuthProvider            @default(EMAIL)
  is_onboarding                   Boolean                 @default(true)
  // this field is true when admin create a user. user should set his own password.
  need_reset_password             Boolean                 @default(false)
  idPhoto_front                   String?
  idPhoto_back                    String?
  verify_status                   UserAccountVerifyStatus @default(UNVERIFIED)
  reset_password_token            String?
  reset_password_token_expires_at DateTime?

  // user may or may not be a vendor
  vendor  Vendor?
  // one user have one default addresses
  address Address?

  // one user may have many orders
  orders   Order[]
  // one user may have many orders
  cart     Cart[]
  Review   Review[]
  Wishlist Wishlist[]
}

enum Gender {
  male
  female
}

model Vendor {
  id        String   @id @default(uuid())
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  business_name     String
  business_email    String       @unique
  phone_number      String       @unique
  logo_url          String?
  status            VendorStatus @default(PENDING)
  have_bank_details Boolean      @default(false)

  // user may or may not be a vendor
  user              User               @relation(fields: [userId], references: [id])
  userId            String             @unique
  // one vendor many addresses
  address           Address[]
  // one vendor many products
  products          Product[]
  // one vendor may have many orders
  orders            Order[]
  VendorBankAccount VendorBankAccount?
  VendorBalance     VendorBalance?
}

model VendorBankAccount {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  account_name   String
  account_number String
  bank_name      String
  // bank_code      String
  currency       String @default("ETB")
  // status         AccountStatus @default(ACTIVE)
  // branch_name    String?
  // swift_code     String?
  // is_default     Boolean       @default(false)
  // is_verified    Boolean       @default(false)
  // last_used_at   DateTime?
  // verification_documents String[]
  // verified_at            DateTime?
  // verified_by            String? // Admin user ID who verified the account

  // One-to-one relation with Vendor
  vendor   Vendor @relation(fields: [vendorId], references: [id])
  vendorId String @unique

  @@index([vendorId])
}

model VendorBalance {
  id        String   @id @default(uuid())
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  // Total amount earned from all successful orders
  total_earnings      Decimal @default(0) @db.Decimal(10, 2)
  // Amount available for withdrawal (total_earnings - pending_withdrawals - withdrawn_amount)
  available_balance   Decimal @default(0) @db.Decimal(10, 2)
  // Total amount withdrawn so far
  withdrawn_amount    Decimal @default(0) @db.Decimal(10, 2)
  // Amount in pending withdrawal requests
  pending_withdrawals Decimal @default(0) @db.Decimal(10, 2)

  // One-to-one relation with Vendor
  vendor   Vendor @relation(fields: [vendorId], references: [id])
  vendorId String @unique

  // One-to-many relation with VendorTransaction
  transactions        VendorTransaction[]
  // One-to-many relation with WithdrawalRequest
  withdrawal_requests WithdrawalRequest[]

  @@index([vendorId])
}

model VendorTransaction {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  // Amount of the transaction
  amount       Decimal
  // Transaction type (e.g., ORDER_PAYMENT, WITHDRAWAL, REFUND)
  type         TransactionType   @default(WITHDRAWAL)
  // Status of the transaction
  status       TransactionStatus @default(PENDING)
  // Reference to the related entity (order ID, withdrawal ID, etc.)
  reference_id String?
  // Additional transaction details
  description  String?

  // Many-to-one relation with VendorBalance
  vendor_balance    VendorBalance @relation(fields: [vendor_balance_id], references: [id])
  vendor_balance_id String

  @@index([vendor_balance_id])
  @@index([status])
  @@index([createdAt])
}

model WithdrawalRequest {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Amount requested for withdrawal
  amount                Decimal                 @db.Decimal(10, 2)
  // Status of the withdrawal request
  status                WithdrawalStatus        @default(PENDING)
  // Payment method details (bank account, mobile money, etc.)
  payment_method        WithdrawalPaymentMethod @default(CHAPA)
  // Notes/comments (from vendor or admin)
  notes                 String?
  // When the withdrawal was processed
  processed_at          DateTime?
  // Transaction reference after processing
  transaction_reference String?

  // Many-to-one relation with VendorBalance
  vendor_balance    VendorBalance @relation(fields: [vendor_balance_id], references: [id])
  vendor_balance_id String

  @@index([vendor_balance_id])
  @@index([status])
  @@index([createdAt])
}

model Address {
  id        String   @id @default(uuid())
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  street     String
  city       String
  sub_city   String
  zip_code   String
  country    String
  latitude   Decimal?
  longitude  Decimal?
  is_default Boolean  @default(false)
  // type       AddressType

  // one vendor many addresses
  Vendor   Vendor? @relation(fields: [vendorId], references: [id])
  vendorId String?
  Order    Order[]
  User     User?   @relation(fields: [userId], references: [id])
  userId   String? @unique
}

model Category {
  id        String   @id @default(uuid())
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  name      String
  slug      String         @unique
  image_url String?
  status    CategoryStatus @default(ACTIVE)

  // many to many relation product - category
  products Product[]
  // TODO: parent_id uuid [null, note: "For subcategories (e.g., \"Citrus\" under \"Fruits\")."]
}

model Product {
  id        String   @id @default(uuid())
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  name           String
  description    String
  price          Decimal
  discount_price Decimal?      @default(0)
  unit           String
  stock          Int
  image_url      String
  status         ProductStatus @default(ACTIVE)
  is_featured    Boolean       @default(false)

  // one vendor many products
  Vendor     Vendor      @relation(fields: [vendorId], references: [id])
  vendorId   String
  // many to many relation product - category
  categories Category[]
  OrderItems OrderItem[]
  CartItem   CartItem[]
  Wishlist   Wishlist[]
}

model Cart {
  id        String   @id @default(uuid())
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  total_price Decimal    @default(0)
  status      CartStatus @default(ACTIVE)

  CartItems CartItem[]
  user      User       @relation(fields: [userId], references: [id])
  userId    String

  // multi-vendor marketplace, the checkout flow needs to split the cart by vendor, and create separate orders per vendor
  Order Order[]
}

model CartItem {
  id        String   @id @default(uuid())
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  price     Decimal
  quantity  Int
  sub_total Decimal

  Product   Product @relation(fields: [productId], references: [id])
  productId String

  Cart   Cart   @relation(fields: [cartId], references: [id])
  cartId String

  // NOTE: In a cart system, a user should not be able to add the same product twice to the cart as separate entries — instead, the quantity should just increase.
  @@unique([cartId, productId], name: "unique_cart_product")
}

model Order {
  id        String   @id @default(uuid())
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  total_price Decimal
  status      OrderStatus @default(PENDING)
  shippedAt   DateTime?
  deliveredAt DateTime?
  receivedAt  DateTime?

  cart   Cart   @relation(fields: [cartId], references: [id])
  cartId String @unique

  // ensures only one order can ever exist for a cart
  OrderItems OrderItem[]
  Payment    Payment?
  // one user may have many orders
  User       User        @relation(fields: [userId], references: [id])
  userId     String
  // one vendor may have many orders
  vendor     Vendor      @relation(fields: [vendorId], references: [id])
  vendorId   String
  // Shipping/delivery address. it should be one of the customers address else the default customer address
  Adress     Address     @relation(fields: [addressId], references: [id])
  addressId  String

  @@index([userId]) // Added index for better query performance
  @@index([vendorId]) // Added index for better query performance
  @@index([addressId]) // Added index for better query performance
}

model OrderItem {
  id        String   @id @default(uuid())
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  // Price per unit at purchase time.
  price     Decimal
  // Number of units ordered.
  quantity  Decimal
  // price * quantity.
  sub_total Decimal
  reviewed  Boolean @default(false)

  // one order may have many order items
  Order     Order   @relation(fields: [orderId], references: [id])
  orderId   String
  // one order item will have one product
  Product   Product @relation(fields: [productId], references: [id])
  productId String

  Review Review?
}

model Payment {
  id        String   @id @default(uuid())
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  amount        Decimal
  status        PaymentStatus @default(PENDING)
  paymentMethod PaymentMethod
  reference     String        @unique
  paidAt        DateTime?

  Order   Order  @relation(fields: [orderId], references: [id])
  orderId String @unique
}

model Review {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  rating  Int
  comment String?

  userId      String
  orderItemId String @unique

  User      User      @relation(fields: [userId], references: [id])
  OrderItem OrderItem @relation(fields: [orderItemId], references: [id])

  @@unique([userId, orderItemId], name: "unique_user_order_item")
}

model Wishlist {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  productId String
  userId    String

  User    User    @relation(fields: [userId], references: [id])
  Product Product @relation(fields: [productId], references: [id])

  @@unique([userId, productId], name: "unique_user_product_wishlist")
}

enum UserRole {
  ADMIN
  CUSTOMER
  VENDOR
}

enum UserStatus {
  ACTIVE
  INACTIVE
  BANNED
  DELETED
}

enum UserAccountVerifyStatus {
  UNVERIFIED
  REQUESTED
  VERIFIED
  DECLINED
}

enum AuthProvider {
  EMAIL
  GOOGLE
}

enum VendorStatus {
  PENDING
  APPROVED
  SUSPENDED
}

// enum AddressType {
//   BUSINESS
//   SHIPPING
// }

enum CategoryStatus {
  ACTIVE
  INACTIVE
}

enum ProductStatus {
  ACTIVE
  INACTIVE
  OUT_OF_STOCK
}

enum CartStatus {
  ACTIVE // Cart is in use, items can be added or removed
  CHECKED_OUT // Cart has been converted into an order
  ABANDONED // Cart was left without checkout
  EXPIRED // Cart was abandoned and expired after a certain period
}

enum OrderStatus {
  // Order has been placed but not yet processed
  PENDING
  // Order has been confirmed by the vendor
  CONFIRMED
  // Order has been shipped to the customer
  SHIPPED
  // Order has been successfully delivered
  DELIVERED
  // Order was canceled before fulfillment
  CANCELLED
  // Customer returned the order
  RETURNED
  // Payment has been refunded
  REFUNDED
}

enum PaymentStatus {
  PENDING
  PAID
}

enum PaymentMethod {
  BANK_TRANSFER
  CASH_ON_DELIVERY
  STRIPE
  CHAPA
}

enum TransactionType {
  ORDER_PAYMENT // When a vendor receives payment from a completed order
  WITHDRAWAL // When a vendor withdraws money from their balance
  REFUND // When a refund is processed for an order
  ADJUSTMENT // For manual adjustments by admin
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
}

// enum AccountStatus {
//   ACTIVE
//   INACTIVE
//   DELETED
// }

enum WithdrawalStatus {
  PENDING // Initial request
  APPROVED // Approved by admin
  PROCESSING // Being processed
  COMPLETED // Successfully transferred
  REJECTED // Rejected by admin
  CANCELLED // Cancelled by vendor
  FAILED // Transfer failed
}

enum WithdrawalPaymentMethod {
  BANK_TRANSFER
  MOBILE_MONEY
  CHAPA
  OTHER
}
</file>

<file path="prisma/seed.ts">
import {
  PrismaClient,
  UserRole,
  UserStatus,
  AuthProvider,
  VendorStatus,
  CategoryStatus,
  ProductStatus,
  CartStatus,
  OrderStatus,
  PaymentStatus,
  PaymentMethod,
  TransactionType,
  TransactionStatus,
  WithdrawalStatus,
  WithdrawalPaymentMethod,
  Gender,
} from '@prisma/client';
import { faker } from '@faker-js/faker';
import * as bcrypt from 'bcryptjs';

const prisma = new PrismaClient();

const NUM_USERS = 30;
const NUM_VENDORS = 5;
const NUM_CATEGORIES = 10;
const NUM_PRODUCTS_PER_VENDOR = 15;
const NUM_ADDRESSES_PER_USER = 1;
const NUM_CARTS_PER_USER = 1;
const NUM_ORDERS_FROM_CARTS = 15;
const NUM_REVIEWS = 50;
const NUM_WITHDRAWAL_REQUESTS_PER_VENDOR = 3;
const NUM_VENDOR_TRANSACTIONS = 20;

async function main() {
  console.log('Start seeding ...');

  // --- Clear existing data (Optional) ---
  // await prisma.review.deleteMany();
  // await prisma.payment.deleteMany();
  // await prisma.orderItem.deleteMany();
  // await prisma.order.deleteMany();
  // await prisma.cartItem.deleteMany();
  // await prisma.cart.deleteMany();
  // await prisma.address.deleteMany();
  // await prisma.product.deleteMany();
  // await prisma.category.deleteMany();
  // await prisma.vendorBankAccount.deleteMany();
  // await prisma.withdrawalRequest.deleteMany();
  // await prisma.vendorTransaction.deleteMany();
  // await prisma.vendorBalance.deleteMany();
  // await prisma.vendor.deleteMany();
  // await prisma.user.deleteMany();
  console.log('Cleaned up existing data.');

  // --- Seed Users ---
  const users = [];
  const salt = await bcrypt.genSalt();
  for (let i = 0; i < NUM_USERS; i++) {
    const isVendor = i < NUM_VENDORS;
    const password = await bcrypt.hash('password123', salt);
    // Corrected faker.phone.number usage
    const phoneNumber = `+2519${faker.string.numeric(8)}`; // Generate 8 digits and prepend prefix

    const user = await prisma.user.create({
      data: {
        email: faker.internet.email().toLowerCase(),
        phone_number: phoneNumber,
        password: password,
        role: isVendor ? UserRole.VENDOR : UserRole.CUSTOMER,
        first_name: isVendor
          ? faker.person.firstName('male')
          : faker.person.firstName(),
        last_name: isVendor
          ? faker.person.lastName('male')
          : faker.person.lastName(),
        date_of_birth: faker.date.birthdate({ min: 18, max: 65, mode: 'age' }),
        gender: faker.helpers.arrayElement([Gender.male, Gender.female]),
        profile_picture: faker.image.avatar(),
        is_onboarding: !isVendor,
        need_reset_password: false,
        verify_status: faker.helpers.arrayElement([
          'UNVERIFIED',
          'VERIFIED',
          'REQUESTED',
          'DECLINED',
        ]), // Include all verify statuses
      },
    });
    users.push(user);
    console.log(`Created user with id: ${user.id}`);
  }
  const customerUsers = users.filter((user) => user.role === UserRole.CUSTOMER);
  const vendorUsers = users.filter((user) => user.role === UserRole.VENDOR);

  // --- Seed Vendors ---
  const vendors = [];
  for (let i = 0; i < NUM_VENDORS; i++) {
    const vendorUser = vendorUsers[i];
    // Corrected faker.phone.number usage
    const vendorPhoneNumber = `+2519${faker.string.numeric(8)}`;

    const vendor = await prisma.vendor.create({
      data: {
        business_name: faker.company.name(),
        business_email: faker.internet.email().toLowerCase(),
        phone_number: vendorPhoneNumber,
        logo_url: faker.image.urlLoremFlickr({
          category: 'business',
          width: 320,
          height: 240,
        }),
        status: faker.helpers.arrayElement([
          VendorStatus.APPROVED,
          VendorStatus.PENDING,
          VendorStatus.SUSPENDED,
        ]), // Include all vendor statuses
        have_bank_details: i % 2 === 0,
        userId: vendorUser.id,
        VendorBalance: {
          create: {
            // Corrected faker.number.float usage with fractionDigits
            total_earnings: faker.number.float({
              min: 1000,
              max: 100000,
              fractionDigits: 2,
            }),
            available_balance: faker.number.float({
              min: 500,
              max: 50000,
              fractionDigits: 2,
            }),
            withdrawn_amount: faker.number.float({
              min: 0,
              max: 10000,
              fractionDigits: 2,
            }),
            pending_withdrawals: faker.number.float({
              min: 0,
              max: 5000,
              fractionDigits: 2,
            }),
          },
        },
        ...(i % 2 === 0 && {
          VendorBankAccount: {
            create: {
              account_name: vendorUser.first_name + ' ' + vendorUser.last_name,
              account_number: faker.finance.accountNumber(10),
              bank_name: faker.helpers.arrayElement([
                'CBE',
                'Awash Bank',
                'Abyssinia Bank',
                'Dashen Bank',
              ]),
              currency: 'ETB',
            },
          },
        }),
      },
    });
    vendors.push(vendor);
    console.log(`Created vendor with id: ${vendor.id}`);
  }

  // --- Seed Categories ---
  const categories = [];
  for (let i = 0; i < NUM_CATEGORIES; i++) {
    const name = faker.commerce.department();
    const category = await prisma.category.create({
      data: {
        name: name,
        slug:
          faker.helpers.slugify(name).toLowerCase() +
          '-' +
          faker.string.alphanumeric(4),
        image_url: faker.image.url({
          width: 320,
          height: 240,
        }), // Updated image url method
        status: faker.helpers.arrayElement([
          CategoryStatus.ACTIVE,
          CategoryStatus.INACTIVE,
        ]),
      },
    });
    categories.push(category);
    console.log(`Created category with id: ${category.id}`);
  }

  // --- Seed Products ---
  const products = [];
  for (const vendor of vendors) {
    for (let i = 0; i < NUM_PRODUCTS_PER_VENDOR; i++) {
      const productName = faker.commerce.productName();
      // Corrected faker.number.float usage with fractionDigits
      const price = faker.number.float({
        min: 10,
        max: 1000,
        fractionDigits: 2,
      });
      const discountPriceValue =
        price > 50
          ? faker.number.float({ min: 1, max: price * 0.5, fractionDigits: 2 })
          : 0; // Corrected usage
      const product = await prisma.product.create({
        data: {
          name: productName,
          description: faker.commerce.productDescription(),
          price: price,
          discount_price: discountPriceValue > 0 ? discountPriceValue : null,
          unit: faker.helpers.arrayElement(['kg', 'liter', 'pcs', 'gram']),
          stock: faker.number.int({ min: 0, max: 1000 }),
          image_url: faker.image.url({
            width: 640,
            height: 480,
          }), // Updated image url method
          status: faker.helpers.arrayElement([
            ProductStatus.ACTIVE,
            ProductStatus.INACTIVE,
            ProductStatus.OUT_OF_STOCK,
          ]),
          is_featured: i % 5 === 0,
          vendorId: vendor.id,
          categories: {
            connect: faker.helpers
              .arrayElements(categories, { min: 1, max: 3 })
              .map((cat) => ({ id: cat.id })),
          },
        },
      });
      products.push(product);
      console.log(`Created product with id: ${product.id}`);
    }
  }

  // --- Seed Addresses (for Users) ---
  const userAddresses = [];
  for (const user of customerUsers) {
    const address = await prisma.address.create({
      data: {
        street: faker.location.streetAddress(),
        city: faker.location.city(),
        sub_city: faker.location.county() + ' Subcity', // Use county as alternative
        zip_code: faker.location.zipCode(),
        country: 'Ethiopia',
        latitude: parseFloat(faker.location.latitude().toFixed(6)),
        longitude: parseFloat(faker.location.longitude().toFixed(6)),
        is_default: true,
        userId: user.id,
      },
    });
    userAddresses.push(address);
    console.log(`Created address with id: ${address.id} for user ${user.id}`);
  }

  // --- Seed Addresses (for Vendors) ---
  const vendorAddresses = [];
  for (const vendor of vendors) {
    const numVendorAddresses = faker.number.int({ min: 1, max: 2 });
    for (let i = 0; i < numVendorAddresses; i++) {
      const address = await prisma.address.create({
        data: {
          street: faker.location.streetAddress(),
          city: faker.location.city(),
          sub_city: faker.location.county() + ' Subcity', // Use county as alternative
          zip_code: faker.location.zipCode(),
          country: 'Ethiopia',
          latitude: parseFloat(faker.location.latitude().toFixed(6)),
          longitude: parseFloat(faker.location.longitude().toFixed(6)),
          is_default: i === 0,
          vendorId: vendor.id,
        },
      });
      vendorAddresses.push(address);
      console.log(
        `Created address with id: ${address.id} for vendor ${vendor.id}`,
      );
    }
  }

  // --- Seed Carts ---
  const carts = [];
  for (const user of customerUsers) {
    const cart = await prisma.cart.create({
      data: {
        userId: user.id,
        status: CartStatus.ACTIVE,
        total_price: 0,
      },
    });
    carts.push(cart);
    console.log(`Created cart with id: ${cart.id} for user ${user.id}`);

    const numItemsInCart = faker.number.int({ min: 1, max: 5 });
    let cartTotal = 0;
    const productsToAdd = faker.helpers.arrayElements(
      products.filter((p) => p.stock > 0),
      numItemsInCart,
    ); // Only add products with stock

    for (const product of productsToAdd) {
      const quantity = faker.number.int({
        min: 1,
        max: product.stock > 5 ? 5 : product.stock || 1,
      }); // Limit quantity
      const price =
        product.discount_price !== null
          ? product.discount_price
          : product.price;
      const subTotal = parseFloat(
        (parseFloat(price.toString()) * quantity).toFixed(2),
      );

      try {
        await prisma.cartItem.create({
          data: {
            cartId: cart.id,
            productId: product.id,
            quantity: quantity,
            price: parseFloat(price.toString()),
            sub_total: subTotal,
          },
        });
        cartTotal += subTotal;
      } catch (e) {
        // Catch potential unique constraint errors if somehow the same product is added multiple times in this loop (shouldn't happen with arrayElements)
        console.error(
          `Failed to add item ${product.id} to cart ${cart.id}:`,
          e,
        );
      }
    }
    await prisma.cart.update({
      where: { id: cart.id },
      data: { total_price: parseFloat(cartTotal.toFixed(2)) },
    });
    console.log(
      `Added ${numItemsInCart} items to cart ${cart.id}, total: ${cartTotal.toFixed(2)}`,
    );
  }

  // --- Seed Orders (by checking out some carts) ---
  const orders = [];
  const cartsToCheckout = faker.helpers.arrayElements(
    carts.filter(
      (c) => c.CartItems.length > 0 && c.status === CartStatus.ACTIVE,
    ),
    NUM_ORDERS_FROM_CARTS >
      carts.filter(
        (c) => c.CartItems.length > 0 && c.status === CartStatus.ACTIVE,
      ).length
      ? carts.filter(
          (c) => c.CartItems.length > 0 && c.status === CartStatus.ACTIVE,
        ).length
      : NUM_ORDERS_FROM_CARTS,
  ); // Select carts that have items and are active

  for (const cart of cartsToCheckout) {
    const user = customerUsers.find((u) => u.id === cart.userId);
    if (!user) continue;

    const userAddress = userAddresses.find((a) => a.userId === user.id);
    if (!userAddress) {
      console.warn(
        `User ${user.id} has a cart but no address, skipping order creation.`,
      );
      continue;
    }

    const cartItems = await prisma.cartItem.findMany({
      where: { cartId: cart.id },
      include: { Product: true },
    });

    if (cartItems.length === 0) continue;

    const ordersToCreatePerVendor: {
      [vendorId: string]: { items: typeof cartItems; total: number };
    } = {};
    for (const item of cartItems) {
      const vendorId = item.Product!.vendorId;
      if (!ordersToCreatePerVendor[vendorId]) {
        ordersToCreatePerVendor[vendorId] = { items: [], total: 0 };
      }
      ordersToCreatePerVendor[vendorId].items.push(item);
      ordersToCreatePerVendor[vendorId].total += parseFloat(
        item.sub_total.toString(),
      );
    }

    for (const vendorId in ordersToCreatePerVendor) {
      const vendor = vendors.find((v) => v.id === vendorId);
      if (!vendor) continue;

      const orderItemsData = ordersToCreatePerVendor[vendorId].items;
      const orderTotal = parseFloat(
        ordersToCreatePerVendor[vendorId].total.toFixed(2),
      );
      // Corrected OrderStatus enum values
      const orderStatus = faker.helpers.arrayElement([
        OrderStatus.PENDING,
        OrderStatus.CONFIRMED,
        OrderStatus.SHIPPED,
        OrderStatus.DELIVERED,
        OrderStatus.CANCELLED,
        OrderStatus.RETURNED,
        OrderStatus.REFUNDED, // Include REFUNDED
      ]);

      const order = await prisma.order.create({
        data: {
          cartId: cart.id,
          userId: user.id,
          vendorId: vendor.id,
          addressId: userAddress.id,
          total_price: orderTotal,
          status: orderStatus,
          shippedAt:
            orderStatus === OrderStatus.SHIPPED ||
            orderStatus === OrderStatus.DELIVERED ||
            orderStatus === OrderStatus.RETURNED
              ? faker.date.past({ years: 0.5 })
              : null,
          deliveredAt:
            orderStatus === OrderStatus.DELIVERED ||
            orderStatus === OrderStatus.RETURNED
              ? faker.date.past({ years: 0.2 })
              : null,
          receivedAt:
            orderStatus === OrderStatus.DELIVERED ||
            orderStatus === OrderStatus.RETURNED
              ? faker.date.past({ years: 0.1 })
              : null,
          OrderItems: {
            create: orderItemsData.map((item) => ({
              productId: item.productId,
              quantity: parseFloat(item.quantity.toString()), // Ensure Decimal type for quantity if schema is Decimal
              price: item.price,
              sub_total: item.sub_total,
              reviewed: false,
            })),
          },
        },
        include: { OrderItems: true },
      });
      orders.push(order);
      console.log(
        `Created order with id: ${order.id} for user ${user.id} and vendor ${vendor.id}`,
      );

      // Mark the cart as CHECKED_OUT
      await prisma.cart.update({
        where: { id: cart.id },
        data: { status: CartStatus.CHECKED_OUT },
      });
    }
  }

  // --- Seed Payments (for some PAID orders) ---
  // An order should be PAID if its status is not PENDING, CANCELLED, RETURNED, or REFUNDED
  const paidOrders = orders.filter(
    (order) =>
      order.status !== OrderStatus.PENDING &&
      order.status !== OrderStatus.CANCELLED &&
      order.status !== OrderStatus.RETURNED &&
      order.status !== OrderStatus.REFUNDED,
  );

  for (const order of paidOrders) {
    const existingPayment = await prisma.payment.findUnique({
      where: { orderId: order.id },
    });
    if (existingPayment) continue;

    const paymentMethod = faker.helpers.arrayElement([
      PaymentMethod.CHAPA,
      PaymentMethod.BANK_TRANSFER,
      PaymentMethod.STRIPE,
    ]); // Include all PaymentMethods
    // Payment status should align with order status. If order is DELIVERED/SHIPPED etc., payment should be PAID.
    const paymentStatus = PaymentStatus.PAID; // Assuming these paid orders have PAID payment

    await prisma.payment.create({
      data: {
        orderId: order.id,
        amount: order.total_price,
        status: paymentStatus,
        paymentMethod: paymentMethod,
        reference: faker.string.uuid(),
        paidAt: faker.date.past({ years: 0.1 }), // Paid in the past
      },
    });
    console.log(`Created payment for order ${order.id}`);
  }

  // --- Seed Reviews (for some DELIVERED orders/items) ---
  const deliveredOrders = orders.filter(
    (order) => order.status === OrderStatus.DELIVERED,
  );
  const reviewableItems = [];
  for (const order of deliveredOrders) {
    const orderItems = await prisma.orderItem.findMany({
      where: { orderId: order.id },
    });
    reviewableItems.push(...orderItems);
  }

  const itemsToReview = faker.helpers.arrayElements(
    reviewableItems.filter((item) => !item.reviewed),
    NUM_REVIEWS > reviewableItems.filter((item) => !item.reviewed).length
      ? reviewableItems.filter((item) => !item.reviewed).length
      : NUM_REVIEWS,
  );

  for (const item of itemsToReview) {
    const existingReview = await prisma.review.findUnique({
      where: { orderItemId: item.id },
    });
    if (existingReview) continue;

    const order = orders.find((o) => o.id === item.orderId);
    if (!order) continue;

    await prisma.review.create({
      data: {
        orderItemId: item.id,
        userId: order.userId,
        rating: faker.number.int({ min: 1, max: 5 }),
        comment: faker.lorem.sentence(),
      },
    });
    console.log(
      `Created review for order item ${item.id} by user ${order.userId}`,
    );

    await prisma.orderItem.update({
      where: { id: item.id },
      data: { reviewed: true },
    });
  }

  // --- Seed Vendor Transactions and Withdrawal Requests ---
  const vendorBalances = await prisma.vendorBalance.findMany();
  for (const balance of vendorBalances) {
    // Seed some withdrawal requests
    for (let i = 0; i < NUM_WITHDRAWAL_REQUESTS_PER_VENDOR; i++) {
      const requestedAmount = faker.number.float({
        min: 100,
        max:
          parseFloat(balance.available_balance.toString()) > 100
            ? parseFloat(balance.available_balance.toString()) * 0.5
            : 100,
        fractionDigits: 2,
      }); // Request up to 50% or min 100
      if (requestedAmount > parseFloat(balance.available_balance.toString()))
        continue; // Don't request more than available

      await prisma.withdrawalRequest.create({
        data: {
          vendor_balance_id: balance.id,
          amount: requestedAmount,
          status: faker.helpers.arrayElement([
            WithdrawalStatus.PENDING,
            WithdrawalStatus.APPROVED,
            WithdrawalStatus.COMPLETED,
            WithdrawalStatus.REJECTED,
            WithdrawalStatus.FAILED,
            WithdrawalStatus.PROCESSING,
            WithdrawalStatus.CANCELLED,
          ]), // Include all statuses
          payment_method: faker.helpers.arrayElement([
            WithdrawalPaymentMethod.CHAPA,
            WithdrawalPaymentMethod.BANK_TRANSFER,
            WithdrawalPaymentMethod.MOBILE_MONEY,
          ]), // Include relevant payment methods
          notes: faker.lorem.sentence(),
          processed_at: faker.helpers.arrayElement([
            null,
            faker.date.past({ years: 0.1 }),
          ]),
          transaction_reference: faker.helpers.arrayElement([
            null,
            faker.string.uuid(),
          ]),
        },
      });
    }

    // Seed some vendor transactions
    for (let i = 0; i < NUM_VENDOR_TRANSACTIONS / vendors.length; i++) {
      const type = faker.helpers.arrayElement([
        TransactionType.ORDER_PAYMENT,
        TransactionType.WITHDRAWAL,
      ]);
      const status = faker.helpers.arrayElement([
        TransactionStatus.PENDING,
        TransactionStatus.COMPLETED,
        TransactionStatus.FAILED,
      ]);
      const amountValue =
        type === TransactionType.ORDER_PAYMENT
          ? faker.number.float({ min: 50, max: 1000, fractionDigits: 2 })
          : faker.number.float({ min: 50, max: 500, fractionDigits: 2 }) * -1; // Generate positive amount, then negate for withdrawal

      await prisma.vendorTransaction.create({
        data: {
          vendor_balance_id: balance.id,
          amount: amountValue,
          type: type,
          status: status,
          description: faker.lorem.sentence(),
          reference_id: faker.string.uuid(), // Use uuid as a generic placeholder
        },
      });
    }
  }

  console.log('Seeding finished.');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
</file>

<file path="src/api/addresses/dto/users/create-user-address.dto.ts">
import { CreateAddressDto } from '../create-address.dto';

export class CreateUserAddressDto extends CreateAddressDto {
  userId: string;
}
</file>

<file path="src/api/addresses/dto/users/update-user-address.dto.ts">
import { PartialType } from '@nestjs/mapped-types';
import { CreateUserAddressDto } from './create-user-address.dto';

export class UpdateUserAddressDto extends PartialType(CreateUserAddressDto) {}
</file>

<file path="src/api/addresses/dto/vendors/create-vendor-address.dto.ts">
import { CreateAddressDto } from '../create-address.dto';

export class CreateVendorAddressDto extends CreateAddressDto {
  userId: string;
}
</file>

<file path="src/api/addresses/dto/vendors/update-vendor-address.dto.ts">
import { PartialType } from '@nestjs/mapped-types';
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsUUID } from 'class-validator';
import { CreateVendorAddressDto } from './create-vendor-address.dto';

export class UpdateVendorAddressDto extends PartialType(
  CreateVendorAddressDto,
) {
  @ApiProperty({
    description: 'address id.',
  })
  @IsNotEmpty()
  @IsUUID()
  addressId: string;
}
</file>

<file path="src/api/addresses/dto/create-address.dto.ts">
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsNotEmpty, IsNumber, IsOptional, IsString } from 'class-validator';

export class CreateAddressDto {
  @ApiPropertyOptional({ description: 'country name' })
  @IsNotEmpty()
  @IsString()
  country: string;

  @ApiProperty({ description: 'city name' })
  @IsNotEmpty()
  @IsString()
  city: string;

  @ApiProperty({ description: 'sub city name' })
  @IsNotEmpty()
  @IsString()
  sub_city: string;

  @ApiProperty({
    description: 'street address',
  })
  @IsNotEmpty()
  @IsString()
  street: string;

  @ApiPropertyOptional({ description: 'postal code' })
  @IsNotEmpty()
  @IsString()
  zip_code: string;

  @ApiPropertyOptional({ description: 'geolocation - latitude' })
  @IsOptional()
  @IsNumber()
  latitude?: number;

  @ApiPropertyOptional({ description: 'geolocation - longitude' })
  @IsOptional()
  @IsNumber()
  longitude?: number;
}
</file>

<file path="src/api/addresses/dto/update-address.dto.ts">
import { PartialType } from '@nestjs/mapped-types';
import { CreateAddressDto } from './create-address.dto';

export class UpdateAddressDto extends PartialType(CreateAddressDto) {}
</file>

<file path="src/api/addresses/interfaces/delete-vendor-address-by-id.interface.ts">
export interface IDeleteVendorAddressById {
  addressId: string;
  userId: string;
}
</file>

<file path="src/api/addresses/providers/users/create-user-address.provider.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
} from '@nestjs/common';
import { Address } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { CreateUserAddressDto } from '../../dto/users/create-user-address.dto';
import { FindOneAddressProvider } from '../find-one-address.provider';

@Injectable()
export class CreateUserAddressProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly findOneAddressProvider: FindOneAddressProvider,
  ) {}

  public async createUserAddress(createUserAddressDto: CreateUserAddressDto) {
    const {
      city,
      country,
      street,
      sub_city,
      zip_code,
      latitude,
      longitude,
      userId,
    } = createUserAddressDto;

    let address: Address | undefined;

    address = await this.findOneAddressProvider.findOneAdress({ userId });

    if (address) {
      throw new BadRequestException(
        'User has created address already. you can update it.',
      );
    }

    // create address and link that address to user
    try {
      address = await this.prisma.address.create({
        data: {
          city,
          country,
          latitude,
          longitude,
          street,
          zip_code,
          sub_city,
          userId,
        },
      });
    } catch (err) {
      console.log('CreateUserAddressProvider: ', err);
      throw new InternalServerErrorException(
        'Unable to create user address, please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'create user address successfull.',
      data: address,
    });
  }
}
</file>

<file path="src/api/addresses/providers/users/find-user-address-by-id.provider.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class FindUserAddressByIdProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findUserAdressById(userId: string) {
    if (!userId) throw new NotFoundException('user id not found.');
    try {
      const address = await this.prisma.address.findFirst({
        where: { userId },
        include: {
          User: {
            select: {
              id: true,
              first_name: true,
              last_name: true,
              email: true,
              phone_number: true,
            },
          },
        },
      });

      if (!address) {
        return CreateApiResponse({
          status: 'error',
          message: 'User has no address yet.',
          data: null,
        });
      }

      return CreateApiResponse({
        status: 'success',
        message: 'find user address successfull.',
        data: address,
      });
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'Unable to find user address. please try again later.',
      );
    }
  }
}
</file>

<file path="src/api/addresses/providers/users/update-user-address.provider.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { FindOneAddressProvider } from '../find-one-address.provider';
import { UpdateUserAddressDto } from '../../dto/users/update-user-address.dto';
import { Address } from '@prisma/client';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class UpdateUserAddressProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly findOneAddressProvider: FindOneAddressProvider,
  ) {}

  public async updateUserAddress(updateUserAddressDto: UpdateUserAddressDto) {
    const {
      city,
      country,
      latitude,
      longitude,
      street,
      sub_city,
      userId,
      zip_code,
    } = updateUserAddressDto;

    let address: Address | undefined;
    // check if address exists
    address = await this.findOneAddressProvider.findOneAdress({ userId });
    if (!address) {
      throw new NotFoundException('User address not found.');
    }
    // update address
    try {
      address = await this.prisma.address.update({
        where: { id: address.id, userId },
        data: {
          city: city ?? address.city,
          country: country ?? address.country,
          latitude: latitude ?? address.latitude,
          longitude: longitude ?? address.longitude,
          street: street ?? address.street,
          sub_city: sub_city ?? address.sub_city,
          zip_code: zip_code ?? address.zip_code,
          userId: address.userId,
        },
      });
    } catch (err) {
      console.log('update user address', err);
      throw new InternalServerErrorException(
        'Unable to Create an address, please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'user address updated successfully.',
      data: address,
    });
  }
}
</file>

<file path="src/api/addresses/providers/vendors/create-vendor-address.provider.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { CreateVendorAddressDto } from '../../dto/vendors/create-vendor-address.dto';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { VendorsService } from 'src/api/vendors/vendors/vendors.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { Address } from '@prisma/client';

@Injectable()
export class CreateVendorAddressProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly vendorsService: VendorsService,
  ) {}

  public async createVendorAddress(
    createVendorAddressDto: CreateVendorAddressDto,
  ) {
    const {
      city,
      country,
      street,
      sub_city,
      zip_code,
      latitude,
      longitude,
      userId,
    } = createVendorAddressDto;

    let address: Address | undefined;

    // check if user has a vendor and its existence
    const vendor = await this.vendorsService.findOneVendor({ userId });
    if (!vendor) {
      throw new NotFoundException('vendor for user not found.');
    }

    // create address and link that address to vendor
    try {
      address = await this.prisma.address.create({
        data: {
          city,
          country,
          latitude,
          longitude,
          street,
          zip_code,
          sub_city,
          vendorId: vendor.id,
        },
      });
    } catch (err) {
      console.log('CreateUserAddressProvider: ', err);
      throw new InternalServerErrorException(
        'Unable to create user address, please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'create vendor address successfull.',
      data: address,
    });
  }
}
</file>

<file path="src/api/addresses/providers/vendors/delete-vendor-address-by-id.provider.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { VendorsService } from 'src/api/vendors/vendors/vendors.service';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { FindOneAddressProvider } from '../find-one-address.provider';
import { IDeleteVendorAddressById } from '../../interfaces/delete-vendor-address-by-id.interface';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class DeleteVendorAddressByIdProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly vendorsService: VendorsService,
    private readonly findOneAddressProvider: FindOneAddressProvider,
  ) {}

  public async deleteVendorAddressById(options: IDeleteVendorAddressById) {
    const { addressId, userId } = options;
    // check if vendor exists
    const vendor = await this.vendorsService.findOneVendor({ userId });
    if (!vendor) {
      throw new NotFoundException('vendor not found.');
    }

    // check if address exists
    const address = await this.findOneAddressProvider.findOneAdress({
      id: addressId,
    });
    if (!address) {
      throw new NotFoundException('Address not found.');
    }

    // delete address
    try {
      await this.prisma.address.delete({ where: { id: addressId } });
    } catch (err) {
      console.log('delete-vendor-address-by-id', err);
      throw new InternalServerErrorException('Unable to find vendor address.');
    }

    // send response
    return CreateApiResponse({
      status: 'success',
      message: 'delete vendor address by id successfull.',
      data: null,
    });
  }
}
</file>

<file path="src/api/addresses/providers/vendors/find-vendor-addresses-by-id.provider.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
} from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class FindVendorAddressesByIdProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findVendorAdressesById(vendorId: string) {
    if (!vendorId) throw new BadRequestException('vendor id is required.');

    try {
      const addresses = await this.prisma.address.findMany({
        where: { vendorId },
      });

      return CreateApiResponse({
        status: 'success',
        message: 'find vendor addresses by id successfull.',
        data: addresses,
      });
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'Unable too find vendor addresses.',
      );
    }
  }
}
</file>

<file path="src/api/addresses/providers/vendors/update-vendor-address.provider.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { Address } from '@prisma/client';
import { VendorsService } from 'src/api/vendors/vendors/vendors.service';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { UpdateVendorAddressDto } from '../../dto/vendors/update-vendor-address.dto';
import { FindOneAddressProvider } from '../find-one-address.provider';

@Injectable()
export class UpdateVendorAddressProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly vendorsService: VendorsService,
    private readonly findOneAddressProvider: FindOneAddressProvider,
  ) {}
  public async updateVendorAddress(
    updateVendorAddressDto: UpdateVendorAddressDto,
  ) {
    const {
      city,
      country,
      latitude,
      longitude,
      street,
      sub_city,
      userId,
      zip_code,
      addressId,
    } = updateVendorAddressDto;
    let address: Address | undefined;

    // check if vendor exists
    const vendor = await this.vendorsService.findOneVendor({ userId });
    if (!vendor) {
      throw new NotFoundException('vendor not found to update the address');
    }

    // check if address exists
    address = await this.findOneAddressProvider.findOneAdress({
      id: addressId,
    });
    if (!address) {
      throw new NotFoundException('User address not found.');
    }

    // update address
    try {
      address = await this.prisma.address.update({
        where: { id: addressId },
        data: {
          city: city ?? address.city,
          country: country ?? address.country,
          latitude: latitude ?? address.latitude,
          longitude: longitude ?? address.longitude,
          street: street ?? address.street,
          sub_city: sub_city ?? address.sub_city,
          zip_code: zip_code ?? address.zip_code,
        },
      });
    } catch (err) {
      console.log('update user address', err);
      throw new InternalServerErrorException(
        'Unable to Create an address, please try again later.',
      );
    }

    // send the response
    return CreateApiResponse({
      status: 'success',
      message: 'update vendor address successfull.',
      data: address,
    });
  }
}
</file>

<file path="src/api/addresses/providers/delete-address-by-id.provider.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
} from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { FindOneAddressProvider } from './find-one-address.provider';

@Injectable()
export class DeleteAddressByIdProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly findOneAddressProvider: FindOneAddressProvider,
  ) {}

  public async deleteAddressById(id: string) {
    const address = await this.findOneAddressProvider.findOneAdress({ id });
    if (!address) {
      throw new BadRequestException('Address not found when deleting.');
    }

    try {
      await this.prisma.address.delete({ where: { id } });
    } catch (err) {
      console.log('delete address by id provider', err);
      throw new InternalServerErrorException(
        'Unable to delete address by id, please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'delete address by id successfull',
      data: null,
    });
  }
}
</file>

<file path="src/api/addresses/providers/find-address-by-id.provider.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { Address } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class FindAddressByIdProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findAddressById(id: string) {
    let address: Address | undefined;

    try {
      address = await this.prisma.address.findFirst({ where: { id } });
    } catch (err) {
      console.log('find address by id provider: ', err);
      throw new InternalServerErrorException(
        'Unable to find address by id, please try again later.',
      );
    }

    if (!address) {
      throw new NotFoundException('Address not found.');
    }

    return CreateApiResponse({
      status: 'success',
      message: 'find address by id successfull.',
      data: address,
    });
  }
}
</file>

<file path="src/api/addresses/providers/find-all-addresses.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { Address } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class FindAllAddressesProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findAllAddresses() {
    let addresses: Address[] | undefined;
    try {
      addresses = await this.prisma.address.findMany();
    } catch (err) {
      console.log('find all addresses', err);
      throw new InternalServerErrorException(
        'Unable to fetch addresses, please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'find all addresses successfull',
      metadata: {},
      data: addresses,
    });
  }
}
</file>

<file path="src/api/addresses/providers/find-one-address.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { Address } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';

@Injectable()
export class FindOneAddressProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findOneAdress(option: Partial<Address>) {
    try {
      const address = await this.prisma.address.findFirst({
        where: option,
      });
      return address;
    } catch (err) {
      console.log('find one address: ', err);
      throw new InternalServerErrorException(
        'Unable to fetch address, please try again later.',
      );
    }
  }
}
</file>

<file path="src/api/addresses/providers/update-address-by-id.provider.ts">
import { Injectable } from '@nestjs/common';

@Injectable()
export class UpdateAddressByIdProvider {}
</file>

<file path="src/api/addresses/addresses.controller.ts">
import {
  BadRequestException,
  Body,
  Controller,
  Delete,
  Get,
  HttpCode,
  HttpStatus,
  NotFoundException,
  Param,
  Patch,
  Post,
  Query,
} from '@nestjs/common';
import {
  ApiBearerAuth,
  ApiBody,
  ApiOperation,
  ApiParam,
  ApiQuery,
} from '@nestjs/swagger';
import { UserRole, Vendor } from '@prisma/client';
import { ActiveUser, Role } from '../auth/decorators';
import { AddressesService } from './addresses.service';
import { CreateUserAddressDto } from './dto/users/create-user-address.dto';
import { UpdateUserAddressDto } from './dto/users/update-user-address.dto';
import { CreateVendorAddressDto } from './dto/vendors/create-vendor-address.dto';
import { UpdateVendorAddressDto } from './dto/vendors/update-vendor-address.dto';
import { IActiveUserData } from '../auth/interfaces/active-user-data.interface';
import { UsersService } from '../users/users.service';
import { VendorsService } from '../vendors/vendors/vendors.service';

@Controller('addresses')
export class AddressesController {
  constructor(
    private readonly addressesService: AddressesService,
    private readonly usersService: UsersService,
    private readonly vendorsService: VendorsService,
  ) {}

  // createUserAddress
  @ApiOperation({
    summary: 'Create User Address',
    description: 'use this api endpoint to create an address for user.',
  })
  @ApiBody({
    type: CreateUserAddressDto,
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.CUSTOMER)
  @Post('user')
  createUserAddress(
    @Body() createUserAddressDto: CreateUserAddressDto,
    @ActiveUser('sub') userId: string,
  ) {
    createUserAddressDto.userId = userId;
    return this.addressesService.createUserAddress(createUserAddressDto);
  }

  // createVendorAddress
  @ApiOperation({
    summary: 'Create Vendor Address',
    description: 'use this api endpoint to create an address for Vendor.',
  })
  @ApiBody({
    type: CreateVendorAddressDto,
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.VENDOR)
  @Post('vendor')
  createVendorAddress(createVendorAddressDto: CreateVendorAddressDto) {
    return this.addressesService.createVendorAddress(createVendorAddressDto);
  }

  // FindUserAddressByIdProvider
  @ApiOperation({
    summary: 'Find User Address By User Id.',
  })
  @ApiQuery({
    name: 'userId',
    description:
      'admins can get the address of a user by sending userId. but customers can get their own address only.',
    required: false,
  })
  @ApiBearerAuth()
  @Get('user')
  async findUserAdressById(
    @Query('userId') userId: string,
    @ActiveUser() activeUserData: IActiveUserData,
  ) {
    const { role, sub } = activeUserData;
    if (role === UserRole.CUSTOMER) {
      userId = sub;
    } else {
      if (!userId) throw new BadRequestException('user id is required.');
      // check if user exists
      const user = await this.usersService.findOneUser({ id: userId });
      if (!user) {
        throw new BadRequestException('user not found.');
      }
    }
    return this.addressesService.findUserAdressById(userId);
  }

  // FindVendorAddressesByIdProvider
  @ApiOperation({
    summary: 'Find Vendor Addresses By Id.',
    description: 'Find Vendor Addresses By Id.',
  })
  @ApiQuery({
    name: 'userId',
    description:
      'admins can get the address of vendors. userId is the id of ther user who owns the vendor.',
    required: false,
  })
  @ApiBearerAuth()
  @Role(UserRole.VENDOR, UserRole.ADMIN)
  @Get('vendor')
  async findVendorAdressesById(
    @Query('userId') userId: string,
    @ActiveUser() activeUserData: IActiveUserData,
  ) {
    const { role, sub } = activeUserData;
    let vendorId: string;
    let vendor: Vendor;
    if (role === UserRole.VENDOR) {
      vendor = await this.vendorsService.findOneVendor({
        userId: sub,
      });
      if (!vendor) throw new NotFoundException('vendor not found.');
      vendorId = vendor.id;
    } else {
      if (!userId) throw new BadRequestException('user id is required.');

      vendor = await this.vendorsService.findOneVendor({
        userId,
      });
      if (!vendor) throw new NotFoundException('vendor not found.');
      vendorId = vendor.id;
    }
    return this.addressesService.findVendorAdressesById(vendorId);
  }

  // findAllAddresses
  @ApiOperation({
    summary: 'Find All Addresses.',
    description: 'use this endpoint to find all addresses',
  })
  @ApiBearerAuth()
  @Role(UserRole.ADMIN)
  @Get()
  findAllAddresses() {
    return this.addressesService.findAllAddresses();
  }

  // findAddressById
  @ApiOperation({
    summary: 'Find Address By ID',
    description: 'use this api endpoint to find address by id.',
  })
  @ApiParam({
    name: 'id',
    required: true,
    description: 'address id',
  })
  @ApiBearerAuth()
  @Role(UserRole.ADMIN)
  @Get(':id')
  findAddressById(@Param('id') id: string) {
    return this.addressesService.findAddressById(id);
  }

  // updateUserAddress
  @ApiOperation({
    summary: 'Update User Address',
  })
  @ApiBody({
    type: UpdateUserAddressDto,
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.CUSTOMER)
  @Patch('user')
  updateUserAddress(
    @Body() updateUserAddressDto: UpdateUserAddressDto,
    @ActiveUser('sub') userId: string,
  ) {
    updateUserAddressDto.userId = userId;
    return this.addressesService.updateUserAddress(updateUserAddressDto);
  }

  // updateVendorAddress
  @ApiOperation({
    summary: 'Update Vendor Address',
  })
  @ApiBody({
    type: UpdateVendorAddressDto,
    required: true,
  })
  @ApiParam({
    name: 'addressId',
    required: true,
    description: 'address id',
  })
  @ApiBearerAuth()
  @Role(UserRole.VENDOR)
  @Patch('vendor/:addressId')
  updateVendorAddress(
    @Body() updateVendorAddressDto: UpdateVendorAddressDto,
    @ActiveUser('sub') userId: string,
  ) {
    updateVendorAddressDto.userId = userId;
    return this.addressesService.updateVendorAddress(updateVendorAddressDto);
  }

  // deleteVendorAddressById
  @ApiOperation({
    summary: 'Delete Vendor Address',
  })
  @ApiParam({
    name: 'addressId',
    required: true,
    description: 'address id',
  })
  @ApiBearerAuth()
  @Role(UserRole.VENDOR)
  @HttpCode(HttpStatus.NO_CONTENT)
  @Delete('vendor/:addressId')
  deleteVendorAddressById(
    @Param('addressId') addressId: string,
    @ActiveUser('sub') userId: string,
  ) {
    return this.addressesService.deleteVendorAddressById({
      addressId,
      userId,
    });
  }

  // deleteAddressById
  @ApiOperation({
    summary: 'Delete Address by ID',
    description: 'Use this api endpoint to delete address by ID.',
  })
  @ApiParam({
    name: 'id',
    required: true,
    description: 'address id.',
  })
  @ApiBearerAuth()
  @Role(UserRole.ADMIN)
  @HttpCode(HttpStatus.NO_CONTENT)
  @Delete(':id')
  deleteAddressById(@Param('id') id: string) {
    return this.addressesService.deleteAddressById(id);
  }
}
</file>

<file path="src/api/addresses/addresses.module.ts">
import { Module } from '@nestjs/common';
import { PrismaModule } from 'src/common/prisma/prisma.module';
import { UsersModule } from '../users/users.module';
import { VendorsModule } from '../vendors/vendors/vendors.module';
import { AddressesController } from './addresses.controller';
import { AddressesService } from './addresses.service';
import { CreateUserAddressProvider } from './providers/users/create-user-address.provider';
import { CreateVendorAddressProvider } from './providers/vendors/create-vendor-address.provider';
import { FindAddressByIdProvider } from './providers/find-address-by-id.provider';
import { FindAllAddressesProvider } from './providers/find-all-addresses.provider';
import { FindOneAddressProvider } from './providers/find-one-address.provider';
import { UpdateAddressByIdProvider } from './providers/update-address-by-id.provider';
import { UpdateUserAddressProvider } from './providers/users/update-user-address.provider';
import { UpdateVendorAddressProvider } from './providers/vendors/update-vendor-address.provider';
import { DeleteVendorAddressByIdProvider } from './providers/vendors/delete-vendor-address-by-id.provider';
import { DeleteAddressByIdProvider } from './providers/delete-address-by-id.provider';
import { FindUserAddressByIdProvider } from './providers/users/find-user-address-by-id.provider';
import { FindVendorAddressesByIdProvider } from './providers/vendors/find-vendor-addresses-by-id.provider';

@Module({
  controllers: [AddressesController],
  providers: [
    AddressesService,
    FindAddressByIdProvider,
    FindAllAddressesProvider,
    FindOneAddressProvider,
    CreateUserAddressProvider,
    CreateVendorAddressProvider,
    UpdateAddressByIdProvider,
    UpdateUserAddressProvider,
    UpdateVendorAddressProvider,
    DeleteVendorAddressByIdProvider,
    DeleteAddressByIdProvider,
    FindUserAddressByIdProvider,
    FindVendorAddressesByIdProvider,
  ],
  imports: [PrismaModule, UsersModule, VendorsModule],
  exports: [AddressesService],
})
export class AddressesModule {}
</file>

<file path="src/api/addresses/addresses.service.ts">
import { Injectable } from '@nestjs/common';
import { Address } from '@prisma/client';
import { CreateUserAddressDto } from './dto/users/create-user-address.dto';
import { UpdateUserAddressDto } from './dto/users/update-user-address.dto';
import { CreateVendorAddressDto } from './dto/vendors/create-vendor-address.dto';
import { UpdateVendorAddressDto } from './dto/vendors/update-vendor-address.dto';
import { IDeleteVendorAddressById } from './interfaces/delete-vendor-address-by-id.interface';
import { DeleteAddressByIdProvider } from './providers/delete-address-by-id.provider';
import { FindAddressByIdProvider } from './providers/find-address-by-id.provider';
import { FindAllAddressesProvider } from './providers/find-all-addresses.provider';
import { FindOneAddressProvider } from './providers/find-one-address.provider';
import { CreateUserAddressProvider } from './providers/users/create-user-address.provider';
import { UpdateUserAddressProvider } from './providers/users/update-user-address.provider';
import { CreateVendorAddressProvider } from './providers/vendors/create-vendor-address.provider';
import { DeleteVendorAddressByIdProvider } from './providers/vendors/delete-vendor-address-by-id.provider';
import { UpdateVendorAddressProvider } from './providers/vendors/update-vendor-address.provider';
import { FindUserAddressByIdProvider } from './providers/users/find-user-address-by-id.provider';
import { FindVendorAddressesByIdProvider } from './providers/vendors/find-vendor-addresses-by-id.provider';

@Injectable()
export class AddressesService {
  constructor(
    private readonly findOneAddressProvider: FindOneAddressProvider,
    private readonly findAllAddressesProvider: FindAllAddressesProvider,
    private readonly findAddressByIdProvider: FindAddressByIdProvider,
    private readonly deleteAddressByIdProvider: DeleteAddressByIdProvider,
    private readonly createUserAddressProvider: CreateUserAddressProvider,
    private readonly createVendorAddressProvider: CreateVendorAddressProvider,
    private readonly updateUserAddressProvider: UpdateUserAddressProvider,
    private readonly updateVendorAddressProvider: UpdateVendorAddressProvider,
    private readonly deleteVendorAddressByIdProvider: DeleteVendorAddressByIdProvider,
    private readonly findUserAddressByIdProvider: FindUserAddressByIdProvider,
    private readonly findVendorAddressesByIdProvider: FindVendorAddressesByIdProvider,
  ) {}

  createUserAddress(createUserAddressDto: CreateUserAddressDto) {
    return this.createUserAddressProvider.createUserAddress(
      createUserAddressDto,
    );
  }

  createVendorAddress(createVendorAddressDto: CreateVendorAddressDto) {
    return this.createVendorAddressProvider.createVendorAddress(
      createVendorAddressDto,
    );
  }

  findAllAddresses() {
    return this.findAllAddressesProvider.findAllAddresses();
  }

  findAddressById(id: string) {
    return this.findAddressByIdProvider.findAddressById(id);
  }

  updateUserAddress(updateUserAddressDto: UpdateUserAddressDto) {
    return this.updateUserAddressProvider.updateUserAddress(
      updateUserAddressDto,
    );
  }

  findUserAdressById(userId: string) {
    return this.findUserAddressByIdProvider.findUserAdressById(userId);
  }

  updateVendorAddress(updateVendorAddressDto: UpdateVendorAddressDto) {
    return this.updateVendorAddressProvider.updateVendorAddress(
      updateVendorAddressDto,
    );
  }

  findVendorAdressesById(vendorId: string) {
    return this.findVendorAddressesByIdProvider.findVendorAdressesById(
      vendorId,
    );
  }

  deleteVendorAddressById(options: IDeleteVendorAddressById) {
    return this.deleteVendorAddressByIdProvider.deleteVendorAddressById(
      options,
    );
  }

  deleteAddressById(id: string) {
    return this.deleteAddressByIdProvider.deleteAddressById(id);
  }

  findOneAddress(option: Partial<Address>) {
    return this.findOneAddressProvider.findOneAdress(option);
  }
}
</file>

<file path="src/api/auth/constants/auth.constant.ts">
export const REQUEST_USER_KEY = 'user';
export const AUTH_TYPE_KEY = 'authType';
export const ROLES_KEY = 'role';
export const ACCESS_TOKEN = 'access_token';
export const REFRESH_TOKEN = 'refresh_token';
</file>

<file path="src/api/auth/decorators/active-user.decorator.ts">
import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { Request } from 'express';
import { REQUEST_USER_KEY } from '../constants/auth.constant';
import { IActiveUserData } from '../interfaces/active-user-data.interface';

const ActiveUser = createParamDecorator(
  (field: keyof IActiveUserData | undefined, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest<Request>();

    const user: IActiveUserData = request[REQUEST_USER_KEY];

    return field ? user?.[field] : user;
  },
);
export default ActiveUser;
</file>

<file path="src/api/auth/decorators/auth.decorator.ts">
import { SetMetadata } from '@nestjs/common';
import { AUTH_TYPE_KEY } from '../constants/auth.constant';
import { AuthType } from '../enums/auth-type.enum';

const Auth = (...authType: AuthType[]) => SetMetadata(AUTH_TYPE_KEY, authType);

export default Auth;
</file>

<file path="src/api/auth/decorators/index.ts">
export { default as Auth } from './auth.decorator';
export { default as ActiveUser } from './active-user.decorator';
export { default as Role } from './role.decorator';
</file>

<file path="src/api/auth/decorators/role.decorator.ts">
import { SetMetadata } from '@nestjs/common';
import { UserRole } from '@prisma/client';
import { ROLES_KEY } from '../constants/auth.constant';

const Role = (...role: UserRole[]) => SetMetadata(ROLES_KEY, role);

export default Role;
</file>

<file path="src/api/auth/dtos/forgot-password.dto.ts">
import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsEmail, IsOptional, IsPhoneNumber } from 'class-validator';
import { EmailOrPhone } from 'src/common/decorators/email-or-phone.decorator';

export class ForgotPasswordDto {
  @ApiPropertyOptional({
    description:
      'email of the user, password reset token will be sent to this email if it exists.',
  })
  @IsOptional()
  @IsEmail()
  email?: string;

  @ApiPropertyOptional({
    description:
      'Phone Number of the user. password reset token will be sent as sms message to this phone number',
  })
  @IsOptional()
  @IsPhoneNumber()
  phoneNumber?: string;

  @EmailOrPhone({
    message: 'Either email or phone number is required.',
  })
  emailOrPhone: string;
}
</file>

<file path="src/api/auth/dtos/refresh-token.dto.ts">
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString } from 'class-validator';

export class RefreshTokenDto {
  @ApiProperty({
    description: 'valid refresh token.',
    example: 'your refresh token',
  })
  @IsString()
  @IsNotEmpty()
  refreshToken: string;
}
</file>

<file path="src/api/auth/dtos/reset-password.dto.ts">
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString, MinLength } from 'class-validator';
import { CheckPasswordConfirm } from 'src/common/decorators/check-password-confirm.decorator';

export class ResetPasswordDto {
  @ApiProperty({
    description: 'your new password',
    example: 'test1234',
  })
  @IsNotEmpty()
  @IsString()
  @MinLength(8, { message: 'password length should at least 8 characters.' })
  password: string;

  @ApiProperty({
    description: 'Confirm you new password',
    example: 'test1234',
  })
  @IsNotEmpty()
  @IsString()
  @MinLength(8, { message: 'password length should at least 8 characters.' })
  passwordConfirm: string;

  @CheckPasswordConfirm({
    message: 'password and password confirm should be the same',
  })
  checkPasswordConfirm: string;
}
</file>

<file path="src/api/auth/dtos/sign-in.dto.ts">
import { ApiPropertyOptional } from '@nestjs/swagger';
import {
  IsEmail,
  IsNotEmpty,
  IsOptional,
  IsPhoneNumber,
  IsString,
} from 'class-validator';
import { EmailOrPhone } from 'src/common/decorators/email-or-phone.decorator';

export class SignInDto {
  @ApiPropertyOptional({
    description:
      'email of the user. either email or phoneNumber must be provided.',
  })
  @IsOptional()
  @IsEmail()
  email?: string;

  @ApiPropertyOptional({
    description:
      'phoneNumber of the user. either phoneNumber or email is required to be able to signin.',
  })
  @IsOptional()
  @IsPhoneNumber()
  phoneNumber?: string;

  @ApiPropertyOptional({
    description: 'user password',
  })
  @IsNotEmpty()
  @IsString()
  password: string;

  @EmailOrPhone({
    message: 'Either email or phoneNumber must be provided.',
  })
  emailOrPhone: string;
}
</file>

<file path="src/api/auth/dtos/sign-up.dto.ts">
import { ApiProperty } from '@nestjs/swagger';
import {
  IsEmail,
  IsNotEmpty,
  IsPhoneNumber,
  IsString,
  MinLength,
} from 'class-validator';
import { CheckPasswordConfirm } from 'src/common/decorators/check-password-confirm.decorator';

export class SignupDto {
  @ApiProperty({
    description: 'email of the user',
  })
  @IsNotEmpty()
  @IsEmail()
  email: string;

  @ApiProperty({
    description: 'phone number of the user',
  })
  @IsNotEmpty()
  @IsPhoneNumber()
  phoneNumber: string;

  @ApiProperty({
    description: 'your password.',
  })
  @IsNotEmpty()
  @IsString()
  @MinLength(8, { message: 'password length should at least be 8 characters' })
  password: string;

  @ApiProperty({
    description: 'confirm your password',
  })
  @IsNotEmpty()
  @IsString()
  @MinLength(8, { message: 'password length should at least be 8 characters' })
  passwordConfirm: string;

  @CheckPasswordConfirm({
    message: 'password and password confirm should be the same',
  })
  checkPasswordConfirm: string;
}
</file>

<file path="src/api/auth/enums/auth-type.enum.ts">
export enum AuthType {
  BEARER,
  NONE,
}
</file>

<file path="src/api/auth/guards/access-token/access-token.guard.ts">
import {
  CanActivate,
  ExecutionContext,
  Inject,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { Request } from 'express';
import { ACCESS_TOKEN, REQUEST_USER_KEY } from '../../constants/auth.constant';
import { JwtService } from '@nestjs/jwt';
import { ConfigType } from '@nestjs/config';
import { jwtConfig } from 'src/common/configuration/config';

@Injectable()
export class AccessTokenGuard implements CanActivate {
  constructor(
    private readonly jwtService: JwtService,

    @Inject(jwtConfig.KEY)
    private readonly jwtConfiguration: ConfigType<typeof jwtConfig>,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest<Request>();

    const token = this.extractToken(request);

    if (!token) {
      throw new UnauthorizedException(
        'you are not logged in. please login to get access.',
      );
    }

    try {
      const payload = await this.jwtService.verifyAsync(
        token,
        this.jwtConfiguration,
      );

      request[REQUEST_USER_KEY] = payload;
    } catch {
      throw new UnauthorizedException(
        'Invalid or expired token. please login to get access',
      );
    }

    return true;
  }

  private extractToken(request: Request) {
    const authHeader = request.headers.authorization;
    // if token is bearer token
    if (authHeader) {
      return authHeader.split(' ')[1];
    }

    // if token is not in the auth header then check the cookie
    return request.cookies?.[ACCESS_TOKEN];
  }
}
</file>

<file path="src/api/auth/guards/authentication/authentication.guard.ts">
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { AccessTokenGuard } from '../access-token/access-token.guard';
import { AUTH_TYPE_KEY } from '../../constants/auth.constant';
import { AuthType } from '../../enums/auth-type.enum';

@Injectable()
export class AuthenticationGuard implements CanActivate {
  private static readonly defaultAuthType = AuthType.BEARER;

  private readonly authTypeGuardMap: Record<
    AuthType,
    CanActivate | CanActivate[]
  > = {
    [AuthType.BEARER]: this.accessTokenGuard,
    [AuthType.NONE]: { canActivate: () => true },
  };

  constructor(
    private readonly reflector: Reflector,
    private readonly accessTokenGuard: AccessTokenGuard,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const authTypes = this.reflector.getAllAndOverride<AuthType[]>(
      AUTH_TYPE_KEY,
      [context.getHandler(), context.getClass()],
    ) ?? [AuthenticationGuard.defaultAuthType];

    const guards = authTypes.map((type) => this.authTypeGuardMap[type]).flat();

    let error = new UnauthorizedException();

    // loop guards canActivates
    for (const instance of guards) {
      const canActivate = await Promise.resolve(
        instance.canActivate(context),
      ).catch((err) => {
        error = err;
      });

      if (canActivate) {
        return true;
      }
    }

    throw error;
  }
}
</file>

<file path="src/api/auth/guards/authorization/authorization.guard.ts">
import {
  CanActivate,
  ExecutionContext,
  ForbiddenException,
  Injectable,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Observable } from 'rxjs';
import { REQUEST_USER_KEY, ROLES_KEY } from '../../constants/auth.constant';
import { UserRole } from '@prisma/client';
import { IActiveUserData } from '../../interfaces/active-user-data.interface';
import { Request } from 'express';

@Injectable()
export class AuthorizationGuard implements CanActivate {
  constructor(private readonly reflector: Reflector) {}

  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    const contextRoles = this.reflector.getAllAndOverride<UserRole[]>(
      ROLES_KEY,
      [context.getHandler(), context.getClass()],
    );

    if (!contextRoles) {
      console.log('access granted');
      return true;
    }

    const user: IActiveUserData = context.switchToHttp().getRequest<Request>()[
      REQUEST_USER_KEY
    ];

    if (!contextRoles.includes(user.role)) {
      throw new ForbiddenException(
        'Access denied. you are not authorized to perform this action.',
      );
    }

    return true;
  }
}
</file>

<file path="src/api/auth/interfaces/active-user-data.interface.ts">
import { UserRole } from '@prisma/client';

export interface IActiveUserData {
  sub: string;
  email: string;
  role: UserRole;
}
</file>

<file path="src/api/auth/providers/hash-password/bcrypt.provider.ts">
import { Injectable } from '@nestjs/common';
import { HashingProvider } from './hashing.provider';
import * as bcrypt from 'bcryptjs';

@Injectable()
export class BcryptProvider implements HashingProvider {
  async hashPassword(data: string | Buffer): Promise<string> {
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(data.toString(), salt);
    return hashedPassword;
  }
  async comparePassword(data: string | Buffer, hash: any): Promise<boolean> {
    return await bcrypt.compare(data.toString(), hash);
  }
}
</file>

<file path="src/api/auth/providers/hash-password/hashing.provider.ts">
import { Injectable } from '@nestjs/common';

@Injectable()
export abstract class HashingProvider {
  abstract hashPassword(data: string | Buffer): Promise<string>;
  abstract comparePassword(
    data: string | Buffer,
    hash: string,
  ): Promise<boolean>;
}
</file>

<file path="src/api/auth/providers/jwt-token/generate-token.provider.ts">
import { Inject, Injectable } from '@nestjs/common';
import { ConfigType } from '@nestjs/config';
import { JwtService } from '@nestjs/jwt';
import { User } from '@prisma/client';
import { jwtConfig } from 'src/common/configuration/config';

@Injectable()
export class GenerateTokenProvider {
  constructor(
    // inject jwt service
    private readonly jwtService: JwtService,

    // inject jwt configuration
    @Inject(jwtConfig.KEY)
    private readonly jwtConfiguration: ConfigType<typeof jwtConfig>,
  ) {}
  // sign token method
  public async signToken<T>(userId: string, expiresIn: number, payload?: T) {
    const token = this.jwtService.signAsync(
      {
        sub: userId,
        ...payload,
      },
      {
        secret: this.jwtConfiguration.secret,
        audience: this.jwtConfiguration.audience,
        issuer: this.jwtConfiguration.issuer,
        expiresIn,
      },
    );

    return token;
  }
  // generate token method
  public async generateToken(user: User) {
    const [accessToken, refreshToken] = await Promise.all([
      this.signToken(user.id, this.jwtConfiguration.accessTokenTtl, {
        email: user.email,
        role: user.role,
      }),
      this.signToken(user.id, this.jwtConfiguration.refreshTokenTtl, {
        email: user.email,
        role: user.role,
      }),
    ]);

    return { accessToken, refreshToken };
  }
}
</file>

<file path="src/api/auth/providers/jwt-token/refresh-token.provider.ts">
import { BadRequestException, Inject, Injectable } from '@nestjs/common';
import { ConfigType } from '@nestjs/config';
import { JwtService } from '@nestjs/jwt';
import { jwtConfig } from 'src/common/configuration/config';
import { GenerateTokenProvider } from './generate-token.provider';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { RefreshTokenDto } from '../../dtos/refresh-token.dto';
import { IActiveUserData } from '../../interfaces/active-user-data.interface';

@Injectable()
export class RefreshTokenProvider {
  constructor(
    private readonly jwtService: JwtService,
    @Inject(jwtConfig.KEY)
    private readonly jwtConfiguration: ConfigType<typeof jwtConfig>,

    private readonly generateTokenProvider: GenerateTokenProvider,
    private readonly prisma: PrismaService,
  ) {}

  public async refreshToken(refreshTokenDto: RefreshTokenDto) {
    try {
      const { sub } = await this.jwtService.verifyAsync<IActiveUserData>(
        refreshTokenDto.refreshToken,
        {
          secret: this.jwtConfiguration.secret,
          audience: this.jwtConfiguration.audience,
          issuer: this.jwtConfiguration.issuer,
        },
      );

      const user = await this.prisma.user.findUnique({
        where: { id: sub },
      });

      if (!user) {
        throw new BadRequestException('Invalid credentials provided.');
      }

      const tokens = await this.generateTokenProvider.generateToken(user);
      return tokens;
    } catch (err) {
      console.log('err when refreshing token: ', err);
      throw new BadRequestException(
        (err as Error).message ||
          'Unable to refresh token at the moment. please try again later',
      );
    }
  }
}
</file>

<file path="src/api/auth/providers/password-reset/forgot-password.provider.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { User } from '@prisma/client';
import * as crypto from 'crypto';
import { EmailService } from 'src/common/email/email.service';
import { MessageService } from 'src/common/message/message.service';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { GetResetPassEmailHtmlTemplate } from 'src/lib/helpers/get-reset-password-email-template.helper';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { ForgotPasswordDto } from '../../dtos/forgot-password.dto';

@Injectable()
export class ForgotPasswordProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly configService: ConfigService,
    private readonly emailService: EmailService,
    private readonly messageService: MessageService,
  ) {}

  public async forgotMyPassword(forgotPasswordDto: ForgotPasswordDto) {
    const { email, phoneNumber } = forgotPasswordDto;
    const isEmail = Boolean(email);

    let user: User;
    try {
      user = await this.prisma.user.findFirst({
        where: isEmail ? { email } : { phone_number: phoneNumber },
      });
    } catch (err) {
      console.log('forgot-password: error: ', err);
      throw new InternalServerErrorException(
        'Unable to find a user please try again later.',
      );
    }

    if (!user) throw new NotFoundException('User not found.');

    const resetToken = isEmail
      ? crypto.randomBytes(32).toString('hex')
      : String(Math.random()).slice(-6);
    const resetTokenHash = crypto
      .createHash('sha256')
      .update(resetToken)
      .digest('hex');
    const resetTokenExpires = new Date(Date.now() + 10 * 60 * 1000);
    const appName = this.configService.get('appConfig.appName');
    const resetUrl = `${this.configService.get('appConfig.resetPasswordFrontendUrl')}/${resetToken}`;

    try {
      await this.prisma.$transaction(async (tx) => {
        await tx.user.update({
          where: { id: user.id },
          data: {
            reset_password_token: resetTokenHash,
            reset_password_token_expires_at: resetTokenExpires,
          },
        });
      });

      if (isEmail) {
        const message = `
          Dear ${user.first_name} ${user.last_name},
          We received a request to reset your password for your account at ${appName}.
          To reset your password, please use the link below. This link will expire in 10 minutes for your security: ${resetUrl}
          If you did not request a password reset, please disregard this email. Your account is safe, and no action is needed.
          For any questions or assistance, feel free to reach out to our support team. We're here to help!
          Hotelify Team`;
        const html = GetResetPassEmailHtmlTemplate({
          appName,
          resetUrl,
          user,
        });

        await this.emailService.sendEmail({
          html,
          message,
          recipient_email: user.email,
          subject: 'Your password reset token (valid for 10 min)',
        });
      } else if (phoneNumber) {
        await this.messageService.sendSMS({
          message: `${appName} Token to reset your password ${resetToken}`,
          recieptPhoneNumber: phoneNumber,
        });
      }
    } catch (err) {
      console.log('forgot-password error: ', err);
      throw new InternalServerErrorException(
        'Error happened when sending reset token. please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: `Password reset url is sent to your ${isEmail ? 'email' : 'phone number'} successfully. please check you email.`,
      data: null,
    });
  }
}
</file>

<file path="src/api/auth/providers/password-reset/reset-password.provider.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
} from '@nestjs/common';
import * as crypto from 'crypto';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { HashingProvider } from '../hash-password/hashing.provider';
import { ResetPasswordDto } from '../../dtos/reset-password.dto';
import { User } from '@prisma/client';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class ResetPasswordProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly hashingProvider: HashingProvider,
  ) {}

  public async resetMyPassword(
    resetToken: string,
    resetPasswordDto: ResetPasswordDto,
  ) {
    let user: User;
    try {
      user = await this.prisma.user.findFirst({
        where: {
          reset_password_token: crypto
            .createHash('sha256')
            .update(resetToken)
            .digest('hex'),
          reset_password_token_expires_at: {
            gt: new Date(),
          },
        },
      });
    } catch (err) {
      console.error('Error finding user:', err);
      throw new InternalServerErrorException(
        'Unable to find a user. Please try again later.',
      );
    }

    if (!user) {
      throw new BadRequestException(
        'Invalid or expired token. please try again.',
      );
    }

    try {
      const password = await this.hashingProvider.hashPassword(
        resetPasswordDto.password,
      );
      user = await this.prisma.user.update({
        where: { id: user.id },
        data: {
          reset_password_token: null,
          reset_password_token_expires_at: null,
          password,
        },
      });
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'Unable to reset password, please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'password reset successfull, now you can login to your account.',
      data: null,
    });
  }
}
</file>

<file path="src/api/auth/providers/sign-in/sign-in.provider.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
} from '@nestjs/common';
import { AuthProvider, User } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { SignInDto } from '../../dtos/sign-in.dto';
import { HashingProvider } from '../hash-password/hashing.provider';
import { GenerateTokenProvider } from '../jwt-token/generate-token.provider';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class SignInProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly hashingProvider: HashingProvider,
    private readonly generateTokenProvider: GenerateTokenProvider,
  ) {}
  public async signin(signinDto: SignInDto) {
    const { email, password, phoneNumber } = signinDto;

    // if both email and phone number are provided throw bad request error
    if (email && phoneNumber) {
      throw new BadRequestException(
        'choose sign in method. Use either email or phone number.',
      );
    }
    // check if the user exists
    let user: User | undefined;
    try {
      user = email
        ? await this.prisma.user.findFirst({
            where: { email },
          })
        : await this.prisma.user.findFirst({
            where: {
              phone_number: phoneNumber,
            },
          });
    } catch (err) {
      console.log('error fetching user. ', err);
      throw new InternalServerErrorException(
        'Unable to fetch user. please try again later.',
      );
    }

    if (!user) {
      throw new BadRequestException(
        'user not found. please check your email or phone number and try again later.',
      );
    }
    // check the auth provider
    if (user.authProvider !== AuthProvider.EMAIL) {
      throw new BadRequestException(
        `Please login via ${user.authProvider} provider.`,
      );
    }

    // check if user needs to reset his password
    if (user.need_reset_password) {
      throw new BadRequestException(
        'user needs to reset his password. please reset your password first and login again.',
      );
    }
    // check password is correct by comparing it
    const isCorrect = await this.hashingProvider.comparePassword(
      password,
      user.password,
    );

    if (!isCorrect) {
      throw new BadRequestException('Invalid credentials. try again later.');
    }

    // sign a new token and return success message
    const { accessToken, refreshToken } =
      await this.generateTokenProvider.generateToken(user);

    return CreateApiResponse({
      status: 'success',
      message: 'signin successfull',
      data: {
        accessToken,
        refreshToken,
        user,
      },
    });
  }
}
</file>

<file path="src/api/auth/providers/sign-up/sign-up.provider.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
} from '@nestjs/common';
import { SignupDto } from '../../dtos/sign-up.dto';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { HashingProvider } from '../hash-password/hashing.provider';
import { User } from '@prisma/client';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class SignUpProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly hashingProvider: HashingProvider,
  ) {}

  public async signup(signupDto: SignupDto) {
    const { email, password, phoneNumber } = signupDto;

    let user: User | undefined;

    try {
      user = await this.prisma.user.findFirst({
        where: {
          OR: [{ email }, { phone_number: phoneNumber }],
        },
      });
    } catch (err) {
      console.log('error fetching user: ', err);
      throw new InternalServerErrorException(
        'Unable to fetch user. please try again later',
      );
    }

    if (user) {
      throw new BadRequestException(
        'User with this email or phone number already exists.',
      );
    }

    try {
      user = await this.prisma.user.create({
        data: {
          email,
          password: await this.hashingProvider.hashPassword(password),
          phone_number: phoneNumber,
          first_name: null,
          last_name: null,
        },
      });
    } catch (err) {
      console.log('error when saving user data: ', err);
      throw new InternalServerErrorException(
        'Unable to create a signup a user. please try again later',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'sign up success full',
      data: user,
    });
  }
}
</file>

<file path="src/api/auth/auth.controller.ts">
import {
  Body,
  Controller,
  HttpCode,
  HttpStatus,
  Param,
  Patch,
  Post,
  Res,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { SignInDto } from './dtos/sign-in.dto';
import { SignupDto } from './dtos/sign-up.dto';
import {
  ApiBearerAuth,
  ApiBody,
  ApiOperation,
  ApiParam,
} from '@nestjs/swagger';
import { AuthType } from './enums/auth-type.enum';
import { Response } from 'express';
import { ACCESS_TOKEN, REFRESH_TOKEN } from './constants/auth.constant';
import { ConfigService } from '@nestjs/config';
import { Auth } from './decorators';
import { RefreshTokenDto } from './dtos/refresh-token.dto';
import { ForgotPasswordDto } from './dtos/forgot-password.dto';
import { ResetPasswordDto } from './dtos/reset-password.dto';

@Controller('auth')
export class AuthController {
  constructor(
    private readonly authService: AuthService,
    private readonly configService: ConfigService,
  ) {}

  @ApiOperation({
    summary: 'Signup a User',
    description: 'Signup a User. use this route to signup a new user.',
  })
  @ApiBody({
    type: SignupDto,
    required: true,
  })
  @Auth(AuthType.NONE)
  @HttpCode(HttpStatus.OK)
  @Post('sign-up')
  signup(@Body() signupDto: SignupDto) {
    return this.authService.signup(signupDto);
  }

  @ApiOperation({
    summary: 'Signin/Login a user',
    description: 'Signin/Login a user. use this endpoint to login a user.',
  })
  @ApiBody({
    type: SignInDto,
    required: true,
  })
  @Auth(AuthType.NONE)
  @HttpCode(HttpStatus.OK)
  @Post('sign-in')
  async signin(
    @Body() signinDto: SignInDto,
    @Res({ passthrough: true }) res: Response,
  ) {
    const data = await this.authService.signin(signinDto);
    // Set access token as an HTTP-only secure cookie
    res.cookie(ACCESS_TOKEN, data.data.accessToken, {
      httpOnly: true,
      secure: true, // Ensure secure (HTTPS) in production
      maxAge: this.configService.get('cookieConfig.accessTokenExpiresIn'),
    });
    // Set refresh token as an HTTP-only secure cookie
    res.cookie(REFRESH_TOKEN, data.data.refreshToken, {
      httpOnly: true,
      secure: true, // Ensure secure (HTTPS) in production
      maxAge: this.configService.get('cookieConfig.refreshTokenExpiresIn'),
    });

    return data;
  }

  @ApiOperation({
    summary: 'Refresh Token',
  })
  @ApiBody({
    type: RefreshTokenDto,
    required: true,
  })
  @Auth(AuthType.NONE)
  @HttpCode(HttpStatus.OK)
  @Post('refresh-token')
  refreshToken(@Body() refreshTokenDto: RefreshTokenDto) {
    return this.authService.refreshToken(refreshTokenDto);
  }

  @ApiOperation({
    summary: 'forgot password.',
    description:
      'forgot your password? use this endpoint to get the reset token.',
  })
  @ApiBody({
    type: ForgotPasswordDto,
    required: true,
  })
  @Auth(AuthType.NONE)
  @HttpCode(HttpStatus.OK)
  @Post('forgot-password')
  forgotMyPassword(@Body() forgotPasswordDto: ForgotPasswordDto) {
    return this.authService.forgotMyPassword(forgotPasswordDto);
  }

  // reset my password
  @ApiOperation({
    summary: 'Reset My Password',
    description:
      'Reset My Password. Use this route to reset you password  incase you forgot it. you will recieve an email or sms message with the reset url.',
  })
  @ApiBody({
    type: ResetPasswordDto,
    required: true,
  })
  @ApiParam({
    name: 'resetToken',
    required: true,
    description: 'reset token you get from the email or sms reset url',
  })
  @Auth(AuthType.NONE)
  @Post('reset-password/:resetToken')
  @HttpCode(HttpStatus.OK)
  public resetMyPassword(
    @Param('resetToken') resetToken: string,
    @Body() resetPasswordDto: ResetPasswordDto,
  ) {
    return this.authService.resetMyPassword(resetToken, resetPasswordDto);
  }

  @ApiOperation({
    summary: 'Logout',
    description: 'Logout a user. use this endpoint to logout a user.',
  })
  @ApiBearerAuth()
  @Patch('logout')
  logout(@Res({ passthrough: true }) res: Response) {
    res.clearCookie(ACCESS_TOKEN);
    res.clearCookie(REFRESH_TOKEN);
    return {
      stats: 'success',
      message: 'Logout successful',
    };
  }
}
</file>

<file path="src/api/auth/auth.module.ts">
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { APP_GUARD } from '@nestjs/core';
import { JwtModule } from '@nestjs/jwt';
import { jwtConfig } from 'src/common/configuration/config';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';
import { AccessTokenGuard } from './guards/access-token/access-token.guard';
import { AuthenticationGuard } from './guards/authentication/authentication.guard';
import { AuthorizationGuard } from './guards/authorization/authorization.guard';
import { BcryptProvider } from './providers/hash-password/bcrypt.provider';
import { HashingProvider } from './providers/hash-password/hashing.provider';
import { GenerateTokenProvider } from './providers/jwt-token/generate-token.provider';
import { RefreshTokenProvider } from './providers/jwt-token/refresh-token.provider';
import { SignInProvider } from './providers/sign-in/sign-in.provider';
import { SignUpProvider } from './providers/sign-up/sign-up.provider';
import { PrismaModule } from 'src/common/prisma/prisma.module';
import { ForgotPasswordProvider } from './providers/password-reset/forgot-password.provider';
import { ResetPasswordProvider } from './providers/password-reset/reset-password.provider';
import { EmailModule } from 'src/common/email/email.module';
import { MessageModule } from 'src/common/message/message.module';

@Module({
  controllers: [AuthController],
  providers: [
    AuthService,
    { provide: APP_GUARD, useClass: AuthenticationGuard },
    { provide: APP_GUARD, useClass: AuthorizationGuard },
    AccessTokenGuard,
    {
      provide: HashingProvider,
      useClass: BcryptProvider,
    },
    GenerateTokenProvider,
    RefreshTokenProvider,
    SignInProvider,
    SignUpProvider,
    ForgotPasswordProvider,
    ResetPasswordProvider,
  ],
  imports: [
    PrismaModule,
    EmailModule,
    MessageModule,
    ConfigModule.forFeature(jwtConfig),
    JwtModule.registerAsync(jwtConfig.asProvider()),
  ],
  exports: [HashingProvider],
})
export class AuthModule {}
</file>

<file path="src/api/auth/auth.service.ts">
import { Injectable } from '@nestjs/common';
import { SignInDto } from './dtos/sign-in.dto';
import { SignupDto } from './dtos/sign-up.dto';
import { SignInProvider } from './providers/sign-in/sign-in.provider';
import { SignUpProvider } from './providers/sign-up/sign-up.provider';
import { RefreshTokenProvider } from './providers/jwt-token/refresh-token.provider';
import { RefreshTokenDto } from './dtos/refresh-token.dto';
import { ForgotPasswordProvider } from './providers/password-reset/forgot-password.provider';
import { ForgotPasswordDto } from './dtos/forgot-password.dto';
import { ResetPasswordDto } from './dtos/reset-password.dto';
import { ResetPasswordProvider } from './providers/password-reset/reset-password.provider';

@Injectable()
export class AuthService {
  constructor(
    private readonly signinProvider: SignInProvider,
    private readonly signupProvider: SignUpProvider,
    private readonly refreshTokenProvider: RefreshTokenProvider,
    private readonly forgotPasswordProvider: ForgotPasswordProvider,
    private readonly resetPasswordProvider: ResetPasswordProvider,
  ) {}
  signin(signinDto: SignInDto) {
    return this.signinProvider.signin(signinDto);
  }

  signup(signupDto: SignupDto) {
    return this.signupProvider.signup(signupDto);
  }

  refreshToken(refreshTokenDto: RefreshTokenDto) {
    return this.refreshTokenProvider.refreshToken(refreshTokenDto);
  }

  forgotMyPassword(forgotPasswordDto: ForgotPasswordDto) {
    return this.forgotPasswordProvider.forgotMyPassword(forgotPasswordDto);
  }

  resetMyPassword(resetToken: string, resetPasswordDto: ResetPasswordDto) {
    return this.resetPasswordProvider.resetMyPassword(
      resetToken,
      resetPasswordDto,
    );
  }
}
</file>

<file path="src/api/cart/dto/create-cart.dto.ts">
export class CreateCartDto {}
</file>

<file path="src/api/cart/dto/update-cart.dto.ts">
import { PartialType } from '@nestjs/swagger';
import { CreateCartDto } from './create-cart.dto';

export class UpdateCartDto extends PartialType(CreateCartDto) {}
</file>

<file path="src/api/cart/providers/create-cart.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { FindOneCartProvider } from './find-one-cart.provider';
import { CartStatus } from '@prisma/client';

@Injectable()
export class CreateCartProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly findOneCartProvider: FindOneCartProvider,
  ) {}

  public async createCart({ userId }: { userId: string }) {
    let cart = await this.findOneCartProvider.findOneCart({
      userId,
      status: CartStatus.ACTIVE,
    });

    if (cart) return cart;

    try {
      cart = await this.prisma.cart.create({
        data: {
          userId,
        },
      });
      return cart;
    } catch (err) {
      console.log('create-cart: ', err);
      throw new InternalServerErrorException(
        'Unable to create a cart, please try again later.',
      );
    }
  }
}
</file>

<file path="src/api/cart/providers/find-my-cart.provider.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { Cart, CartStatus } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class FindMyCartProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findMyCart(userId: string) {
    let cart: Cart;

    try {
      cart = await this.prisma.cart.findFirst({
        where: { userId, status: CartStatus.ACTIVE },
        include: {
          CartItems: {
            include: {
              Product: true,
            },
          },
        },
      });
    } catch (err) {
      console.log('find-my-cart: ', err);
      throw new InternalServerErrorException(
        'Unable to find cart, please try again later.',
      );
    }

    if (!cart) {
      throw new NotFoundException('There is no active cart for this user');
    }

    return CreateApiResponse({
      status: 'success',
      message: 'Cart found successfully',
      data: cart,
    });
  }
}
</file>

<file path="src/api/cart/providers/find-my-carts.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class FindMyCartsProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findMyCarts(userId: string) {
    try {
      const carts = await this.prisma.cart.findMany({
        where: { userId },
        include: {
          CartItems: true,
        },
      });

      return CreateApiResponse({
        status: 'success',
        message: 'Carts found successfully',
        data: carts,
      });
    } catch (err) {
      console.log('find-my-carts: ', err);
      throw new InternalServerErrorException(
        'Unable to find carts, please try again later.',
      );
    }
  }
}
</file>

<file path="src/api/cart/providers/find-one-cart.provider.ts">
import { Injectable } from '@nestjs/common';
import { Cart, CartStatus } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';

@Injectable()
export class FindOneCartProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findOneCart(options: Partial<Cart>) {
    try {
      const cart = await this.prisma.cart.findFirst({
        where: {
          ...options,
          status: CartStatus.ACTIVE,
        },
      });

      return cart;
    } catch (err) {
      console.log('FindOneCartProvider: ', err);
    }
  }
}
</file>

<file path="src/api/cart/cart.controller.ts">
import { Controller, Get } from '@nestjs/common';
import { CartService } from './cart.service';
import { ActiveUser, Role } from '../auth/decorators';
import { ApiBearerAuth, ApiOperation } from '@nestjs/swagger';
import { UserRole } from '@prisma/client';

@Controller('cart')
export class CartController {
  constructor(private readonly cartService: CartService) {}

  @ApiOperation({
    summary: 'Get my cart',
  })
  @ApiBearerAuth()
  @Role(UserRole.CUSTOMER)
  @Get('my-cart')
  findMyCart(@ActiveUser('sub') userId: string) {
    return this.cartService.findMyCart(userId);
  }

  @ApiOperation({
    summary: 'Get all my carts',
  })
  @ApiBearerAuth()
  @Role(UserRole.CUSTOMER)
  @Get('my-carts')
  findMyCarts(@ActiveUser('sub') userId: string) {
    return this.cartService.findMyCarts(userId);
  }
}
</file>

<file path="src/api/cart/cart.module.ts">
import { Module } from '@nestjs/common';
import { CartService } from './cart.service';
import { CartController } from './cart.controller';
import { FindOneCartProvider } from './providers/find-one-cart.provider';
import { PrismaModule } from 'src/common/prisma/prisma.module';
import { CreateCartProvider } from './providers/create-cart.provider';
import { FindMyCartProvider } from './providers/find-my-cart.provider';
import { FindMyCartsProvider } from './providers/find-my-carts.provider';

@Module({
  controllers: [CartController],
  providers: [
    CartService,
    FindOneCartProvider,
    CreateCartProvider,
    FindMyCartProvider,
    FindMyCartsProvider,
  ],
  imports: [PrismaModule],
  exports: [CartService],
})
export class CartModule {}
</file>

<file path="src/api/cart/cart.service.ts">
import { Injectable } from '@nestjs/common';
import { Cart } from '@prisma/client';
import { CreateCartProvider } from './providers/create-cart.provider';
import { FindMyCartProvider } from './providers/find-my-cart.provider';
import { FindOneCartProvider } from './providers/find-one-cart.provider';
import { FindMyCartsProvider } from './providers/find-my-carts.provider';

@Injectable()
export class CartService {
  constructor(
    private readonly findOneCartProvider: FindOneCartProvider,
    private readonly createCartProvider: CreateCartProvider,
    private readonly findMyCartProvider: FindMyCartProvider,
    private readonly findMyCartsProvider: FindMyCartsProvider,
  ) {}
  createCart({ userId }: { userId: string }) {
    return this.createCartProvider.createCart({ userId });
  }

  findMyCart(userId: string) {
    return this.findMyCartProvider.findMyCart(userId);
  }

  findMyCarts(userId: string) {
    return this.findMyCartsProvider.findMyCarts(userId);
  }

  findOneCart(options: Partial<Cart>) {
    return this.findOneCartProvider.findOneCart(options);
  }
}
</file>

<file path="src/api/cart_items/dto/create-cart_item.dto.ts">
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsNumber, IsUUID, Min } from 'class-validator';

export class CreateCartItemDto {
  @ApiProperty({
    description: 'quantity of the cart item',
  })
  @IsNotEmpty()
  @IsNumber()
  @Min(1, { message: 'quantity must be greater than 0' })
  quantity: number;

  @ApiProperty({
    description: 'product id',
  })
  @IsNotEmpty()
  @IsUUID()
  productId: string;

  userId: string;
}
</file>

<file path="src/api/cart_items/dto/update-cart_item.dto.ts">
import { OmitType, PartialType } from '@nestjs/swagger';
import { CreateCartItemDto } from './create-cart_item.dto';

export class UpdateCartItemDto extends PartialType(
  OmitType(CreateCartItemDto, ['productId'] as const),
) {}
</file>

<file path="src/api/cart_items/interfaces/delete-cart-item-by-id.interface.ts">
export interface IDeleteCartItemById {
  cartItemId: string;
  userId?: string;
}
</file>

<file path="src/api/cart_items/interfaces/find-cart-by-id.interface.ts">
export interface IFindCartItemById {
  cartItemId: string;
  userId?: string;
}
</file>

<file path="src/api/cart_items/providers/create-cart-item.provider.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { CartItem } from '@prisma/client';
import { CartService } from 'src/api/cart/cart.service';
import { ProductsService } from 'src/api/products/products.service';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { CreateCartItemDto } from '../dto/create-cart_item.dto';
import { FindOneCartItemProvider } from './find-one-cart-item.provider';

@Injectable()
export class CreateCartItemProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly productsService: ProductsService,
    private readonly cartService: CartService,
    private readonly findOneCartItemProvider: FindOneCartItemProvider,
  ) {}

  public async createCartItem(createCartItemDto: CreateCartItemDto) {
    const { productId, quantity, userId } = createCartItemDto;
    // check if product id exists
    const product = await this.productsService.findOneProduct({
      id: productId,
    });

    if (!product) {
      throw new NotFoundException('Product not found.');
    }
    // check if cart is created if not create one else find and attach it to the cart item.
    const cart = await this.cartService.createCart({ userId });
    if (!cart) {
      throw new InternalServerErrorException(
        'Unable to find cart for the user',
      );
    }
    // create cart item
    let cartItem: CartItem | undefined;
    // check if that product is already added to the cart if so update the quantity
    cartItem = await this.findOneCartItemProvider.findOneCartItem({
      productId,
      cartId: cart.id,
    });

    try {
      // start transaction
      await this.prisma.$transaction(async (tx) => {
        if (!cartItem) {
          // else create a new cart item
          cartItem = await tx.cartItem.create({
            data: {
              price: product.price,
              quantity,
              sub_total: product.price.mul(quantity),
              cartId: cart.id,
              productId: product.id,
            },
          });
        } else {
          cartItem = await tx.cartItem.update({
            where: { id: cartItem.id },
            data: {
              quantity: { increment: quantity },
              sub_total: cartItem.sub_total.add(product.price.mul(quantity)),
            },
          });
        }
        // update cart total
        await tx.cart.update({
          where: { id: cart.id },
          data: {
            total_price: cart.total_price.add(cartItem.sub_total),
          },
        });
      });
    } catch (err) {
      console.log('createCartItem: ', err);
      throw new InternalServerErrorException(
        'Unable to create cart item. please try again later.',
      );
    }
    // return response
    return CreateApiResponse({
      status: 'success',
      message: 'create cart item successfull.',
      data: cartItem,
    });
  }
}
</file>

<file path="src/api/cart_items/providers/delete-cart-item-by-id.provider.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { Prisma } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { IDeleteCartItemById } from '../interfaces/delete-cart-item-by-id.interface';

@Injectable()
export class DeleteCartItemByIdProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async deleteCartItemById(data: IDeleteCartItemById) {
    let cartItem: Prisma.CartItemGetPayload<{
      include: { Cart: true };
    }>;

    try {
      cartItem = await this.prisma.cartItem.findFirst({
        where: { id: data.cartItemId, Cart: { userId: data.userId } },
        include: {
          Cart: true,
        },
      });
    } catch (err) {
      console.log('deleteCartItemById: ', err);
      throw new InternalServerErrorException(
        'Unable to delete cart item. please try again later.',
      );
    }

    if (!cartItem) {
      throw new NotFoundException('Cart item not found.');
    }

    try {
      // delete cart item and update cart total
      await this.prisma.$transaction([
        this.prisma.cartItem.delete({
          where: { id: data.cartItemId, Cart: { userId: data.userId } },
        }),
        this.prisma.cart.update({
          where: { id: cartItem.cartId, userId: data.userId },
          data: {
            total_price: cartItem.Cart.total_price.sub(cartItem.sub_total),
          },
        }),
      ]);
    } catch (err) {
      console.log('deleteCartItemById: ', err);
      throw new InternalServerErrorException(
        'Unable to delete cart item. please try again later.',
      );
    }
  }
}
</file>

<file path="src/api/cart_items/providers/find-all-cart-items.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class FindAllCartItemsProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findAllCartItems() {
    try {
      const cartItems = await this.prisma.cartItem.findMany({
        include: {
          Cart: true,
          Product: true,
        },
      });

      return CreateApiResponse({
        status: 'success',
        message: 'find all cart items successfully.',
        data: cartItems,
      });
    } catch (err) {
      console.log('findAllCartItems: ', err);
      throw new InternalServerErrorException(
        'Unable to find cart items. please try again later.',
      );
    }
  }
}
</file>

<file path="src/api/cart_items/providers/find-cart-item-by-id.provider.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { CartItem } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { IFindCartItemById } from '../interfaces/find-cart-by-id.interface';

@Injectable()
export class FindCartItemByIdProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findCartItemById(data: IFindCartItemById) {
    let cartItem: CartItem | undefined;
    try {
      cartItem = await this.prisma.cartItem.findFirst({
        where: { id: data.cartItemId, Cart: { userId: data.userId } },
        include: {
          Cart: true,
          Product: true,
        },
      });
    } catch (err) {
      console.log('findCartItemById: ', err);
      throw new InternalServerErrorException(
        'Unable to find cart item. please try again later.',
      );
    }

    if (!cartItem) {
      throw new NotFoundException('Cart item not found.');
    }

    return CreateApiResponse({
      status: 'success',
      message: 'find cart item successfull.',
      data: cartItem,
    });
  }
}
</file>

<file path="src/api/cart_items/providers/find-one-cart-item.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { CartItem } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';

@Injectable()
export class FindOneCartItemProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findOneCartItem(options: Partial<CartItem>) {
    try {
      const cartItem = await this.prisma.cartItem.findFirst({ where: options });
      return cartItem;
    } catch (err) {
      console.log('findOneCartItem: ', err);
      throw new InternalServerErrorException(
        'Unable to find one cart item. please try again later.',
      );
    }
  }
}
</file>

<file path="src/api/cart_items/providers/find-user-cart-items.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class FindUserCartItemsProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findUserCartItems(userId: string) {
    try {
      const cartItems = await this.prisma.cartItem.findMany({
        where: {
          Cart: {
            userId,
          },
        },
        include: {
          Product: true,
        },
      });

      return CreateApiResponse({
        status: 'success',
        message: 'find cart items successfull.',
        data: cartItems,
      });
    } catch (err) {
      console.log('findUserCartItems: ', err);
      throw new InternalServerErrorException(
        'Unable to find cart items. please try again later.',
      );
    }
  }
}
</file>

<file path="src/api/cart_items/providers/index.ts">
export { CreateCartItemProvider } from './create-cart-item.provider';
export { DeleteCartItemByIdProvider } from './delete-cart-item-by-id.provider';
export { FindAllCartItemsProvider } from './find-all-cart-items.provider';
export { FindCartItemByIdProvider } from './find-cart-item-by-id.provider';
export { FindOneCartItemProvider } from './find-one-cart-item.provider';
export { UpdateCartItemByIdProvider } from './update-cart-item-by-id.provider';
export { FindUserCartItemsProvider } from './find-user-cart-items.provider';
</file>

<file path="src/api/cart_items/providers/update-cart-item-by-id.provider.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { UpdateCartItemDto } from '../dto/update-cart_item.dto';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CartItem } from '@prisma/client';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class UpdateCartItemByIdProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async updateCartItemById(
    id: string,
    updateCartItemDto: UpdateCartItemDto,
  ) {
    const { quantity, userId } = updateCartItemDto;

    let cartItem: CartItem;
    try {
      cartItem = await this.prisma.cartItem.findFirst({
        where: { id, Cart: { userId } },
      });
    } catch (err) {
      console.log('UpdateCartItemByIdProvider: ', err);
      throw new InternalServerErrorException(
        'Unable to find cart item. please try again later.',
      );
    }
    if (!cartItem) {
      throw new NotFoundException('Cart item not found.');
    }

    let updatedCartItem: CartItem;
    try {
      await this.prisma.$transaction(async (prisma) => {
        updatedCartItem = await prisma.cartItem.update({
          where: { id },
          data: {
            quantity,
            sub_total: cartItem.price.mul(quantity),
          },
          include: {
            Product: true,
          },
        });

        const subTotalAfterUpdate = cartItem.price.mul(quantity).toNumber();

        await prisma.cart.update({
          where: { id: cartItem.cartId, userId },
          data: {
            total_price: {
              increment: subTotalAfterUpdate - cartItem.sub_total.toNumber(),
            },
          },
        });
      });
    } catch (err) {
      console.log('UpdateCartItemByIdProvider: ', err);
      throw new InternalServerErrorException(
        'Unable to update cart item. please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'Cart item updated successfully.',
      data: updatedCartItem,
    });
  }
}
</file>

<file path="src/api/cart_items/cart_items.controller.ts">
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { CartItemsService } from './cart_items.service';
import { CreateCartItemDto } from './dto/create-cart_item.dto';
import { UpdateCartItemDto } from './dto/update-cart_item.dto';
import {
  ApiBearerAuth,
  ApiBody,
  ApiOperation,
  ApiParam,
} from '@nestjs/swagger';
import { ActiveUser, Role } from '../auth/decorators';
import { UserRole } from '@prisma/client';
import { IActiveUserData } from '../auth/interfaces/active-user-data.interface';
import { IFindCartItemById } from './interfaces/find-cart-by-id.interface';

@Controller('cart-items')
export class CartItemsController {
  constructor(private readonly cartItemsService: CartItemsService) {}

  // Create cart item
  @ApiOperation({
    summary: 'Create a new cart item',
  })
  @ApiBody({
    type: CreateCartItemDto,
    description: 'Create a new cart item',
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.CUSTOMER)
  @Post()
  createCartItem(
    @Body() createCartItemDto: CreateCartItemDto,
    @ActiveUser('sub') userId: string,
  ) {
    createCartItemDto.userId = userId;
    return this.cartItemsService.createCartItem(createCartItemDto);
  }

  // Find all cart items for a user
  @ApiOperation({
    summary: 'Find all cart items for a user',
  })
  @ApiBearerAuth()
  @Role(UserRole.CUSTOMER)
  @Get('/user')
  findUserCartItems(@ActiveUser('sub') userId: string) {
    return this.cartItemsService.findUserCartItems(userId);
  }

  // Find all cart items
  @ApiOperation({
    summary: 'Find all cart items',
  })
  @ApiBearerAuth()
  @Role(UserRole.ADMIN)
  @Get()
  findAllCartItems() {
    return this.cartItemsService.findAllCartItems();
  }

  // Find cart item by id
  @ApiOperation({
    summary: 'Find a cart item by id',
  })
  @ApiParam({
    name: 'id',
    description: 'cart item id',
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.CUSTOMER, UserRole.ADMIN)
  @Get(':id')
  findCartItemById(
    @Param('id') id: string,
    @ActiveUser() activeUserData: IActiveUserData,
  ) {
    const condition: IFindCartItemById = {
      cartItemId: id,
    };
    if (activeUserData.role === UserRole.CUSTOMER) {
      condition.userId = activeUserData.sub;
    }
    return this.cartItemsService.findCartItemById(condition);
  }

  // Update cart item by id
  @ApiOperation({
    summary: 'Update a cart item by id',
  })
  @ApiBody({
    type: UpdateCartItemDto,
    description: 'Update a cart item by id',
    required: true,
  })
  @ApiParam({
    name: 'id',
    description: 'cart item id',
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.CUSTOMER, UserRole.ADMIN)
  @Patch(':id')
  updateCartItemById(
    @Param('id') id: string,
    @Body() updateCartItemDto: UpdateCartItemDto,
    @ActiveUser() activeUserData: IActiveUserData,
  ) {
    if (activeUserData.role === UserRole.CUSTOMER) {
      updateCartItemDto.userId = activeUserData.sub;
    }

    return this.cartItemsService.updateCartItemById(id, updateCartItemDto);
  }

  // Delete cart item by id
  @ApiOperation({
    summary: 'Delete a cart item by id',
  })
  @ApiParam({
    name: 'id',
    description: 'cart item id',
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.CUSTOMER)
  @HttpCode(HttpStatus.NO_CONTENT)
  @Delete(':id')
  deleteCartItemById(
    @Param('id') id: string,
    @ActiveUser() activeUserData: IActiveUserData,
  ) {
    const condition: IFindCartItemById = {
      cartItemId: id,
    };
    if (activeUserData.role === UserRole.CUSTOMER) {
      condition.userId = activeUserData.sub;
    }
    return this.cartItemsService.deleteCartItemById(condition);
  }
}
</file>

<file path="src/api/cart_items/cart_items.module.ts">
import { Module } from '@nestjs/common';
import { PrismaModule } from 'src/common/prisma/prisma.module';
import { CartModule } from '../cart/cart.module';
import { ProductsModule } from '../products/products.module';
import { CartItemsController } from './cart_items.controller';
import { CartItemsService } from './cart_items.service';
import { CreateCartItemProvider } from './providers/create-cart-item.provider';
import { DeleteCartItemByIdProvider } from './providers/delete-cart-item-by-id.provider';
import { FindAllCartItemsProvider } from './providers/find-all-cart-items.provider';
import { FindCartItemByIdProvider } from './providers/find-cart-item-by-id.provider';
import { FindOneCartItemProvider } from './providers/find-one-cart-item.provider';
import { UpdateCartItemByIdProvider } from './providers/update-cart-item-by-id.provider';
import { FindUserCartItemsProvider } from './providers/find-user-cart-items.provider';

@Module({
  controllers: [CartItemsController],
  providers: [
    CartItemsService,
    FindOneCartItemProvider,
    FindAllCartItemsProvider,
    FindCartItemByIdProvider,
    UpdateCartItemByIdProvider,
    DeleteCartItemByIdProvider,
    CreateCartItemProvider,
    FindUserCartItemsProvider,
  ],
  imports: [PrismaModule, ProductsModule, CartModule],
})
export class CartItemsModule {}
</file>

<file path="src/api/cart_items/cart_items.service.ts">
import { Injectable } from '@nestjs/common';
import { CreateCartItemDto } from './dto/create-cart_item.dto';
import { UpdateCartItemDto } from './dto/update-cart_item.dto';
import {
  CreateCartItemProvider,
  DeleteCartItemByIdProvider,
  FindAllCartItemsProvider,
  FindCartItemByIdProvider,
  FindOneCartItemProvider,
  FindUserCartItemsProvider,
  UpdateCartItemByIdProvider,
} from './providers';
import { CartItem } from '@prisma/client';
import { IFindCartItemById } from './interfaces/find-cart-by-id.interface';
import { IDeleteCartItemById } from './interfaces/delete-cart-item-by-id.interface';

@Injectable()
export class CartItemsService {
  constructor(
    private readonly createCartItemProvider: CreateCartItemProvider,
    private readonly deleteCartItemByIdProvider: DeleteCartItemByIdProvider,
    private readonly findAllCartItemsProvider: FindAllCartItemsProvider,
    private readonly findCartItemByIdProvider: FindCartItemByIdProvider,
    private readonly findOneCartItemProvider: FindOneCartItemProvider,
    private readonly updateCartItemByIdProvider: UpdateCartItemByIdProvider,
    private readonly findUserCartItemsProvider: FindUserCartItemsProvider,
  ) {}

  createCartItem(createCartItemDto: CreateCartItemDto) {
    return this.createCartItemProvider.createCartItem(createCartItemDto);
  }

  findAllCartItems() {
    return this.findAllCartItemsProvider.findAllCartItems();
  }

  findUserCartItems(userId: string) {
    return this.findUserCartItemsProvider.findUserCartItems(userId);
  }

  findCartItemById(data: IFindCartItemById) {
    return this.findCartItemByIdProvider.findCartItemById(data);
  }

  updateCartItemById(id: string, updateCartItemDto: UpdateCartItemDto) {
    return this.updateCartItemByIdProvider.updateCartItemById(
      id,
      updateCartItemDto,
    );
  }

  deleteCartItemById(data: IDeleteCartItemById) {
    return this.deleteCartItemByIdProvider.deleteCartItemById(data);
  }

  findOneCartItem(options: Partial<CartItem>) {
    return this.findOneCartItemProvider.findOneCartItem(options);
  }
}
</file>

<file path="src/api/categories/dto/create-category.dto.ts">
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString } from 'class-validator';

export class CreateCategoryDto {
  @ApiProperty({
    description: 'category name',
  })
  @IsNotEmpty()
  @IsString()
  name: string;

  @ApiProperty({
    type: 'string',
    format: 'binary',
    description: 'category image',
  })
  image: string;

  // for internal use
  slug: string;

  image_url: string;
}
</file>

<file path="src/api/categories/dto/update-category.dto.ts">
import { PartialType } from '@nestjs/mapped-types';
import { CreateCategoryDto } from './create-category.dto';

export class UpdateCategoryDto extends PartialType(CreateCategoryDto) {}
</file>

<file path="src/api/categories/providers/create-category.provider.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
} from '@nestjs/common';
import { Category } from '@prisma/client';
import slugify from 'slugify';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { CreateCategoryDto } from '../dto/create-category.dto';

@Injectable()
export class CreateCategoryProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async createCategory(createCategoryDto: CreateCategoryDto) {
    // check if slug already exists
    let category: Category | undefined;
    const { name, image_url } = createCategoryDto;

    try {
      createCategoryDto.slug = slugify(name, '_');
      category = await this.prisma.category.findFirst({
        where: { slug: createCategoryDto.slug },
      });
    } catch (err) {
      console.log('createCategory: ', err);
      throw new InternalServerErrorException(
        'Unable to find one category. please try again later.',
      );
    }

    if (category) {
      throw new BadRequestException(
        'Category with the same name or slug already exists. please update the name of the category.',
      );
    }
    // create category
    try {
      category = await this.prisma.category.create({
        data: {
          name,
          image_url,
          slug: createCategoryDto.slug,
        },
      });
    } catch (err) {
      console.log('createCategory: ', err);
      throw new InternalServerErrorException(
        'Unable to create category. please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'create category successfull.',
      data: category,
    });
  }
}
</file>

<file path="src/api/categories/providers/delete-category-by-id.provider.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { FindOneCategoryProvider } from './find-one-category.provider';

@Injectable()
export class DeleteCategoryByIdProvider {
  constructor(
    private readonly prisma: PrismaService,

    private readonly findOneCategoryProvider: FindOneCategoryProvider,
  ) {}

  public async deleteCategoryById(id: string) {
    const category = await this.findOneCategoryProvider.findOneCategory({ id });

    if (!category) {
      throw new NotFoundException('category not found.');
    }

    // delete category.
    try {
      await this.prisma.category.delete({ where: { id } });
    } catch (err) {
      console.log('deleteCategoryById: ', err);
      throw new InternalServerErrorException(
        'Unable to delete category. please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'delete category by id successfull.',
      data: null,
    });
  }
}
</file>

<file path="src/api/categories/providers/find-all-categories.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { Category } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class FindAllCategoriesProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findAllCategories() {
    let categories: Category[] | undefined;

    try {
      categories = await this.prisma.category.findMany();
    } catch (err) {
      console.log('findAllCategories: ', err);
      throw new InternalServerErrorException(
        'Unable to all find categories. please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'find all categories successfull.',
      metadata: {},
      data: categories,
    });
  }
}
</file>

<file path="src/api/categories/providers/find-category-by-id.provider.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { Category } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class FindCategoryByIdProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findCategoryById(id: string) {
    let category: Category | undefined;
    try {
      // check if category exists
      category = await this.prisma.category.findFirst({
        where: {
          id,
        },
      });
    } catch (err) {
      console.log('findCategoryById: ', err);
      throw new InternalServerErrorException(
        'Unable to find category by id. please try again later.',
      );
    }

    if (!category) {
      throw new NotFoundException('category not found.');
    }

    return CreateApiResponse({
      status: 'success',
      message: 'find category by id successfull.',
      data: category,
    });
  }
}
</file>

<file path="src/api/categories/providers/find-one-category.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { Category } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';

@Injectable()
export class FindOneCategoryProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findOneCategory(options: Partial<Category>) {
    try {
      const category = await this.prisma.category.findFirst({
        where: options,
      });

      return category;
    } catch (err) {
      console.log('findOneCategory: ', err);
      throw new InternalServerErrorException(
        'Unable to find one category. please try again later.',
      );
    }
  }
}
</file>

<file path="src/api/categories/providers/index.ts">
export { CreateCategoryProvider } from './create-category.provider';
export { DeleteCategoryByIdProvider } from './delete-category-by-id.provider';
export { FindAllCategoriesProvider } from './find-all-categories.provider';
export { FindCategoryByIdProvider } from './find-category-by-id.provider';
export { FindOneCategoryProvider } from './find-one-category.provider';
export { UpdateCategoryByIdProvider } from './update-category-by-id.provider';
</file>

<file path="src/api/categories/providers/update-category-by-id.provider.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import slugify from 'slugify';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { UpdateCategoryDto } from '../dto/update-category.dto';
import { FindOneCategoryProvider } from './find-one-category.provider';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class UpdateCategoryByIdProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly findOneCategoryProvider: FindOneCategoryProvider,
  ) {}

  public async updateCategoryById(
    id: string,
    updateCategoryDto: UpdateCategoryDto,
  ) {
    const { name, image_url } = updateCategoryDto;
    // check if category exists
    let category = await this.findOneCategoryProvider.findOneCategory({ id });
    if (!category) {
      throw new NotFoundException('category not found.');
    }

    // check if name changed, check the slug
    try {
      updateCategoryDto.slug = slugify(name, '_');
      category = await this.prisma.category.findFirst({
        where: {
          slug: updateCategoryDto.slug,
          NOT: { id },
        },
      });
    } catch (err) {
      console.log('UpdateCategoryByIdProvider: ', err);
      throw new InternalServerErrorException('');
    }

    if (category) {
      throw new InternalServerErrorException(
        'Category with the same name or slug already exists. please update the name of the category.',
      );
    }

    // update category
    try {
      category = await this.prisma.category.update({
        where: { id },
        data: {
          name: name ?? category.name,
          slug: updateCategoryDto.slug ?? category.slug,
          image_url: image_url ?? category.image_url,
        },
      });
    } catch (err) {
      console.log('UpdateCategoryByIdProvider: ', err);
    }

    return CreateApiResponse({
      status: 'success',
      message: 'update category by id successfull.',
      data: category,
    });
  }
}
</file>

<file path="src/api/categories/categories.controller.ts">
import {
  Body,
  Controller,
  Delete,
  Get,
  HttpCode,
  HttpStatus,
  Param,
  Patch,
  Post,
  UploadedFile,
  UseInterceptors,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import {
  ApiBearerAuth,
  ApiBody,
  ApiConsumes,
  ApiOperation,
  ApiParam,
} from '@nestjs/swagger';
import { UserRole } from '@prisma/client';
import { FileUploadService } from 'src/common/file-upload/file-upload.service';
import { FileUploadDirNames } from 'src/lib/constants/file-upload-dir-names';
import { Auth, Role } from '../auth/decorators';
import { CategoriesService } from './categories.service';
import { CreateCategoryDto } from './dto/create-category.dto';
import { UpdateCategoryDto } from './dto/update-category.dto';
import { AuthType } from '../auth/enums/auth-type.enum';

@Controller('categories')
export class CategoriesController {
  constructor(
    private readonly categoriesService: CategoriesService,
    private readonly fileUploadService: FileUploadService,
  ) {}

  @ApiOperation({
    summary: 'Create Category.',
  })
  @ApiBody({
    type: CreateCategoryDto,
    required: true,
  })
  @UseInterceptors(
    FileInterceptor(
      'image',
      FileUploadService.saveImageToStorage({
        dirName: FileUploadDirNames.category,
      }),
    ),
  )
  @ApiConsumes('multipart/form-data')
  @ApiBearerAuth()
  @Role(UserRole.ADMIN)
  @Post()
  createCategory(
    @Body() createCategoryDto: CreateCategoryDto,
    @UploadedFile() image: Express.Multer.File,
  ) {
    if (image) {
      createCategoryDto.image_url = this.fileUploadService.getFilePath(image);
    }
    return this.categoriesService.createCategory(createCategoryDto);
  }

  @ApiOperation({
    summary: 'Find All Categories.',
  })
  @Auth(AuthType.NONE)
  @Get()
  findAllCategories() {
    return this.categoriesService.findAllCategories();
  }

  @ApiOperation({
    summary: 'Find Category by ID.',
  })
  @ApiParam({
    name: 'id',
    description: 'category id',
    required: true,
  })
  @ApiBearerAuth()
  @Auth(AuthType.NONE)
  @Get(':id')
  findCategoryById(@Param('id') id: string) {
    return this.categoriesService.findCategoryById(id);
  }

  @ApiOperation({
    summary: 'Update Category.',
  })
  @ApiBody({
    type: UpdateCategoryDto,
    required: true,
  })
  @ApiParam({
    name: 'id',
    description: 'category id',
    required: true,
  })
  @UseInterceptors(
    FileInterceptor(
      'image',
      FileUploadService.saveImageToStorage({
        dirName: FileUploadDirNames.category,
      }),
    ),
  )
  @ApiConsumes('multipart/form-data')
  @ApiBearerAuth()
  @Role(UserRole.ADMIN)
  @Patch(':id')
  updateCategoryById(
    @Param('id') id: string,
    @Body() updateCategoryDto: UpdateCategoryDto,
  ) {
    return this.categoriesService.updateCategoryById(id, updateCategoryDto);
  }

  @ApiOperation({
    summary: 'Delete Category by ID.',
  })
  @ApiParam({
    name: 'id',
    description: 'category id',
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.ADMIN)
  @HttpCode(HttpStatus.NO_CONTENT)
  @Delete(':id')
  deleteCategoryById(@Param('id') id: string) {
    return this.categoriesService.deleteCategoryById(id);
  }
}
</file>

<file path="src/api/categories/categories.module.ts">
import { Module } from '@nestjs/common';
import { FileUploadModule } from 'src/common/file-upload/file-upload.module';
import { PrismaModule } from 'src/common/prisma/prisma.module';
import { CategoriesController } from './categories.controller';
import { CategoriesService } from './categories.service';
import { CreateCategoryProvider } from './providers/create-category.provider';
import { DeleteCategoryByIdProvider } from './providers/delete-category-by-id.provider';
import { FindAllCategoriesProvider } from './providers/find-all-categories.provider';
import { FindCategoryByIdProvider } from './providers/find-category-by-id.provider';
import { FindOneCategoryProvider } from './providers/find-one-category.provider';
import { UpdateCategoryByIdProvider } from './providers/update-category-by-id.provider';

@Module({
  controllers: [CategoriesController],
  providers: [
    CategoriesService,
    FindAllCategoriesProvider,
    FindOneCategoryProvider,
    FindCategoryByIdProvider,
    UpdateCategoryByIdProvider,
    DeleteCategoryByIdProvider,
    CreateCategoryProvider,
  ],
  imports: [PrismaModule, FileUploadModule],
})
export class CategoriesModule {}
</file>

<file path="src/api/categories/categories.service.ts">
import { Injectable } from '@nestjs/common';
import { Category } from '@prisma/client';
import { CreateCategoryDto } from './dto/create-category.dto';
import { UpdateCategoryDto } from './dto/update-category.dto';
import {
  CreateCategoryProvider,
  DeleteCategoryByIdProvider,
  FindAllCategoriesProvider,
  FindCategoryByIdProvider,
  FindOneCategoryProvider,
  UpdateCategoryByIdProvider,
} from './providers';

@Injectable()
export class CategoriesService {
  constructor(
    private readonly createCategoryProvider: CreateCategoryProvider,
    private readonly deleteCategoryByIdProvider: DeleteCategoryByIdProvider,
    private readonly findAllCategoriesProvider: FindAllCategoriesProvider,
    private readonly findCategoryByIdProvider: FindCategoryByIdProvider,
    private readonly findOneCategoryProvider: FindOneCategoryProvider,
    private readonly updateCategoryByIdProvider: UpdateCategoryByIdProvider,
  ) {}

  createCategory(createCategoryDto: CreateCategoryDto) {
    return this.createCategoryProvider.createCategory(createCategoryDto);
  }

  findAllCategories() {
    return this.findAllCategoriesProvider.findAllCategories();
  }

  findCategoryById(id: string) {
    return this.findCategoryByIdProvider.findCategoryById(id);
  }

  updateCategoryById(id: string, updateCategoryDto: UpdateCategoryDto) {
    return this.updateCategoryByIdProvider.updateCategoryById(
      id,
      updateCategoryDto,
    );
  }

  deleteCategoryById(id: string) {
    return this.deleteCategoryByIdProvider.deleteCategoryById(id);
  }

  findOneCategory(options: Partial<Category>) {
    return this.findOneCategoryProvider.findOneCategory(options);
  }
}
</file>

<file path="src/api/order_items/order_items.controller.ts">
import { Controller } from '@nestjs/common';
import { OrderItemsService } from './order_items.service';

@Controller('order-items')
export class OrderItemsController {
  constructor(private readonly orderItemsService: OrderItemsService) {}
}
</file>

<file path="src/api/order_items/order_items.module.ts">
import { Module } from '@nestjs/common';
import { OrderItemsService } from './order_items.service';
import { OrderItemsController } from './order_items.controller';

@Module({
  controllers: [OrderItemsController],
  providers: [OrderItemsService],
})
export class OrderItemsModule {}
</file>

<file path="src/api/order_items/order_items.service.ts">
import { Injectable } from '@nestjs/common';

@Injectable()
export class OrderItemsService {}
</file>

<file path="src/api/orders/dtos/checkout.dto.ts">
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsUUID } from 'class-validator';

export class CheckOutDto {
  @ApiProperty({
    description: 'The ID of the cart to check out',
  })
  @IsNotEmpty()
  @IsUUID()
  cartId: string;

  @ApiProperty({
    description: 'The ID of the address to ship to',
  })
  @IsNotEmpty()
  @IsUUID()
  addressId: string;

  userId: string;
  // TODO: add more properties as later
  // couponCode?: string;
  // note?: string;
}
</file>

<file path="src/api/orders/dtos/update-order-status.dto.ts">
import { ApiProperty } from '@nestjs/swagger';
import { OrderStatus } from '@prisma/client';
import { IsEnum, IsNotEmpty } from 'class-validator';

export class UpdateOrderStatusDto {
  @ApiProperty({
    description: 'The status of the order',
    enum: OrderStatus,
    example: OrderStatus.PENDING,
  })
  @IsNotEmpty()
  @IsEnum(OrderStatus)
  status: OrderStatus;
}
</file>

<file path="src/api/orders/helpers/checkStatusTransition.ts">
import { OrderStatus, UserRole } from '@prisma/client';

export function checkStatusTransition(
  current: OrderStatus,
  next: OrderStatus,
  role: UserRole,
): boolean {
  const matrix = {
    CUSTOMER: {
      PENDING: [OrderStatus.CANCELLED],
      DELIVERED: [OrderStatus.RETURNED],
    },
    VENDOR: {
      PENDING: [OrderStatus.CONFIRMED],
      CONFIRMED: [OrderStatus.SHIPPED, OrderStatus.CANCELLED],
    },
    ADMIN: {
      '*': [
        OrderStatus.CONFIRMED,
        OrderStatus.SHIPPED,
        OrderStatus.DELIVERED,
        OrderStatus.CANCELLED,
        OrderStatus.RETURNED,
        OrderStatus.REFUNDED,
      ],
    },
  };

  const allowed = matrix[role]?.[current] || matrix[role]?.['*'] || [];

  return allowed.includes(next);
}
</file>

<file path="src/api/orders/providers/check-out.provider.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { CartStatus, Order, OrderStatus, Prisma } from '@prisma/client';
import { AddressesService } from 'src/api/addresses/addresses.service';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { CheckOutDto } from '../dtos/checkout.dto';

@Injectable()
export class CheckOutProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly addressesService: AddressesService,
  ) {}

  public async checkOut(checOutDto: CheckOutDto) {
    const { cartId, userId, addressId } = checOutDto;
    // fetch cart and cart item
    let cart: Prisma.CartGetPayload<{
      include: {
        CartItems: { include: { Product: { include: { Vendor: true } } } };
      };
    }>;

    try {
      cart = await this.prisma.cart.findFirst({
        where: {
          id: cartId,
          userId,
          status: CartStatus.ACTIVE,
        },
        include: {
          CartItems: {
            include: {
              Product: {
                include: {
                  Vendor: true,
                },
              },
            },
          },
        },
      });
    } catch (err) {
      console.log('check out', err);
      throw new InternalServerErrorException(
        'Unable to fetch cart. please try again later.',
      );
    }
    // check if cart is empty
    if (!cart) throw new NotFoundException('Cart not found.');
    if (!cart.CartItems.length) throw new BadRequestException('Cart is empty.');

    // check if address is valid
    const address = await this.addressesService.findOneAddress({
      id: addressId,
    });
    if (!address) {
      throw new NotFoundException('Address not found.');
    }

    // Double Checkout Prevention
    let existingOrder: Order;
    try {
      existingOrder = await this.prisma.order.findFirst({
        where: {
          cartId,
          userId,
          status: {
            in: [
              OrderStatus.PENDING,
              OrderStatus.CONFIRMED,
              OrderStatus.SHIPPED,
              OrderStatus.DELIVERED,
            ],
          },
        },
      });
    } catch (err) {
      console.log('check out', err);
      throw new InternalServerErrorException(
        'Unable to fetch order. please try again later.',
      );
    }

    if (existingOrder) {
      throw new BadRequestException(
        'An order has already been placed for this cart.',
      );
    }

    // stock validation
    const outOfStack: string[] = [];
    for (const item of cart.CartItems) {
      if (item.Product.stock < item.quantity) {
        outOfStack.push(item.Product.name);
      }
    }

    if (outOfStack.length) {
      throw new NotFoundException(
        `The following items are out of stock: ${outOfStack.join(', ')}`,
      );
    }

    try {
      const createdOrders = await this.prisma.$transaction(async (tx) => {
        const groupedByVendor = cart.CartItems.reduce(
          (acc, item) => {
            const vendorId = item.Product.vendorId;
            if (!acc[vendorId]) acc[vendorId] = [];
            acc[vendorId].push(item);
            return acc;
          },
          {} as Record<string, typeof cart.CartItems>,
        );

        const orders = await Promise.all(
          Object.entries(groupedByVendor).map(async ([vendorId, items]) => {
            const vendorTotalPrice = items.reduce((acc, item) => {
              return acc + item.sub_total.toNumber();
            }, 0);

            // create order for each vendor
            const createdOrder = await tx.order.create({
              data: {
                total_price: vendorTotalPrice,
                addressId,
                userId,
                cartId,
                vendorId,
                OrderItems: {
                  create: items.map((item) => ({
                    productId: item.productId,
                    quantity: item.quantity,
                    price: item.price,
                    sub_total: item.sub_total,
                  })),
                },
              },
              include: {
                Adress: true,
                OrderItems: true,
              },
            });

            // Update product stock in parallel
            await Promise.all(
              items.map(async (item) =>
                tx.product.update({
                  where: { id: item.productId },
                  data: {
                    stock: {
                      decrement: item.quantity,
                    },
                  },
                }),
              ),
            );

            return createdOrder;
          }),
        );

        // Update cart status
        await tx.cart.update({
          where: { id: cartId },
          data: { status: CartStatus.CHECKED_OUT },
        });

        return orders;
      });

      // return response
      return CreateApiResponse({
        status: 'success',
        message: 'Order created successfully.',
        data: createdOrders,
      });
    } catch (err) {
      console.log('check out', err);
      throw new InternalServerErrorException(
        'Unable to create order. please try again later.',
      );
    }
  }
}
</file>

<file path="src/api/orders/providers/find-all-orders.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class FindAllOrdersProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findAllOrders() {
    try {
      const orders = await this.prisma.order.findMany({
        include: {
          Adress: true,
          OrderItems: true,
          User: true,
        },
      });

      return CreateApiResponse({
        status: 'success',
        message: 'Orders fetched successfully',
        metadata: {},
        data: orders,
      });
    } catch (err) {
      console.log('find all orders error', err);
      throw new InternalServerErrorException(
        'Unable to fetch orders, please try again',
      );
    }
  }
}
</file>

<file path="src/api/orders/providers/find-all-vendor-orders.provider.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { VendorsService } from 'src/api/vendors/vendors/vendors.service';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class FindAllVendorOrdersProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly vendorsService: VendorsService,
  ) {}

  public async findAllVendorOrders(vendorId: string, userId: string) {
    const vendor = await this.vendorsService.findOneVendor({
      id: vendorId,
      userId,
    });

    if (!vendor) {
      throw new NotFoundException('Vendor not found');
    }

    try {
      const orders = await this.prisma.order.findMany({
        where: {
          OrderItems: {
            some: {
              Product: {
                vendorId,
              },
            },
          },
        },
        include: {
          Adress: true,
          OrderItems: true,
          User: true,
        },
      });

      return CreateApiResponse({
        status: 'success',
        message: 'Orders fetched successfully',
        metadata: {},
        data: orders,
      });
    } catch (err) {
      console.log('find all vendor orders error', err);
      throw new InternalServerErrorException(
        'Unable to fetch orders, please try again',
      );
    }
  }
}
</file>

<file path="src/api/orders/providers/find-my-order.provider.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class FindMyOrderProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findMyOrder(orderId: string, userId: string) {
    let order: any;
    try {
      order = await this.prisma.order.findFirst({
        where: {
          id: orderId,
          userId,
        },
        include: {
          Adress: true,
          OrderItems: {
            include: {
              Product: true,
            },
          },
        },
      });
    } catch (err) {
      console.log('find my order error', err);
      throw new InternalServerErrorException(
        'Unable to fetch order, please try again',
      );
    }

    if (!order) {
      throw new NotFoundException('Order not found');
    }

    return CreateApiResponse({
      status: 'success',
      message: 'Order fetched successfully',
      data: order,
    });
  }
}
</file>

<file path="src/api/orders/providers/find-my-orders.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class FindMyOrdersProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findMyOrders(userId: string) {
    try {
      const orders = await this.prisma.order.findMany({
        where: {
          userId,
        },
        include: {
          Adress: true,
          OrderItems: {
            include: {
              Product: true,
            },
          },
        },
      });

      return CreateApiResponse({
        status: 'success',
        message: 'Orders fetched successfully',
        data: orders,
      });
    } catch (err) {
      console.log('find my orders error', err);
      throw new InternalServerErrorException(
        'Unable to fetch orders, please try again',
      );
    }
  }
}
</file>

<file path="src/api/orders/providers/find-one-order.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { Order } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';

@Injectable()
export class FindOneOrderProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findOneOrder(options: Partial<Order>) {
    try {
      const order = await this.prisma.order.findFirst({
        where: options,
      });

      return order;
    } catch (err) {
      console.log('findOneOrderProvider error', err);
      throw new InternalServerErrorException(
        'Unable to find one order, please try again later',
      );
    }
  }
}
</file>

<file path="src/api/orders/providers/find-order-by-id.provider.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class FindOrderByIdProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findOrderById(orderId: string) {
    let order: any;
    try {
      order = await this.prisma.order.findFirst({
        where: { id: orderId },
        include: {
          Adress: true,
          OrderItems: {
            include: {
              Product: true,
            },
          },
        },
      });
    } catch (err) {
      console.log('find order by id error', err);
      throw new InternalServerErrorException(
        'Unable to fetch order, please try again',
      );
    }

    if (!order) {
      throw new NotFoundException('Order not found');
    }

    return CreateApiResponse({
      status: 'success',
      message: 'Order fetched successfully',
      data: order,
    });
  }
}
</file>

<file path="src/api/orders/providers/index.ts">
export { CheckOutProvider } from './check-out.provider';
export { FindAllOrdersProvider } from './find-all-orders.provider';
export { FindAllVendorOrdersProvider } from './find-all-vendor-orders.provider';
export { FindMyOrderProvider } from './find-my-order.provider';
export { FindMyOrdersProvider } from './find-my-orders.provider';
export { FindOneOrderProvider } from './find-one-order.provider';
export { FindOrderByIdProvider } from './find-order-by-id.provider';
export { UpdateOrderStatusByIdProvider } from './update-order-status-by-id.provider';
</file>

<file path="src/api/orders/providers/update-order-status-by-id.provider.ts">
import {
  ForbiddenException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { OrderStatus, UserRole } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { UpdateOrderStatusDto } from '../dtos/update-order-status.dto';
import { FindOneOrderProvider } from './find-one-order.provider';

@Injectable()
export class UpdateOrderStatusByIdProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly findOneOrderProvider: FindOneOrderProvider,
  ) {}

  public async updateOrderStatusById(
    orderId: string,
    updateOrderStatusDto: UpdateOrderStatusDto,
    role: UserRole,
  ) {
    const { status: newStatus } = updateOrderStatusDto;

    const order = await this.findOneOrderProvider.findOneOrder({ id: orderId });
    if (!order) {
      throw new NotFoundException('Order not found');
    }

    const allowed = this.checkStatusTransition(order.status, newStatus, role);
    if (!allowed) {
      throw new ForbiddenException('Invalid status transition for your role.');
    }

    const updatedOrder = await this.prisma.order.update({
      where: { id: orderId },
      data: { status: newStatus },
    });

    return CreateApiResponse({
      status: 'success',
      message: 'Order status updated successfully',
      data: updatedOrder,
    });
  }

  private checkStatusTransition(
    current: OrderStatus,
    next: OrderStatus,
    role: UserRole,
  ): boolean {
    const matrix = {
      CUSTOMER: {
        PENDING: [OrderStatus.CANCELLED],
        DELIVERED: [OrderStatus.RETURNED],
      },
      VENDOR: {
        PENDING: [OrderStatus.CONFIRMED],
        CONFIRMED: [OrderStatus.SHIPPED, OrderStatus.CANCELLED],
      },
      ADMIN: {
        '*': [
          OrderStatus.CONFIRMED,
          OrderStatus.SHIPPED,
          OrderStatus.DELIVERED,
          OrderStatus.CANCELLED,
          OrderStatus.RETURNED,
          OrderStatus.REFUNDED,
        ],
      },
    };

    const allowed = matrix[role]?.[current] || matrix[role]?.['*'] || [];

    return allowed.includes(next);
  }
}
</file>

<file path="src/api/orders/orders.controller.ts">
import { Body, Controller, Get, Param, Patch, Post } from '@nestjs/common';
import { OrdersService } from './orders.service';
import {
  ApiBearerAuth,
  ApiBody,
  ApiOperation,
  ApiParam,
} from '@nestjs/swagger';
import { CheckOutDto } from './dtos/checkout.dto';
import { ActiveUser, Role } from '../auth/decorators';
import { UserRole } from '@prisma/client';
import { UpdateOrderStatusDto } from './dtos/update-order-status.dto';

@Controller('orders')
export class OrdersController {
  constructor(private readonly ordersService: OrdersService) {}

  // findAllOrders
  @ApiOperation({
    summary: 'Get all orders',
    description: 'Get all orders.',
  })
  @ApiBearerAuth()
  @Role(UserRole.ADMIN)
  @Get()
  findAllOrders() {
    return this.ordersService.findAllOrders();
  }

  // findAllVendorOrders
  @ApiOperation({
    summary: 'Get all vendor orders',
    description: 'Get all orders for a specific vendor.',
  })
  @ApiParam({
    name: 'vendorId',
    description: 'The ID of the vendor to get orders for.',
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.VENDOR)
  @Get('vendor/:vendorId')
  findAllVendorOrders(
    @Param('vendorId') vendorId: string,
    @ActiveUser('sub') userId: string,
  ) {
    return this.ordersService.findAllVendorOrders(vendorId, userId);
  }

  // findMyOrder
  @ApiOperation({
    summary: 'Get my order',
    description: 'Get a specific order for the authenticated user.',
  })
  @ApiParam({
    name: 'orderId',
    description: 'The ID of the order to get.',
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.CUSTOMER)
  @Get('my-orders/:orderId')
  findMyOrder(
    @Param('orderId') orderId: string,
    @ActiveUser('sub') userId: string,
  ) {
    return this.ordersService.findMyOrder(orderId, userId);
  }

  // findMyOrders
  @ApiOperation({
    summary: 'Get my orders',
    description: 'Get all orders for the authenticated user.',
  })
  @ApiBearerAuth()
  @Role(UserRole.CUSTOMER)
  @Get('my-orders')
  findMyOrders(@ActiveUser('sub') userId: string) {
    return this.ordersService.findMyOrders(userId);
  }

  // findOrderById
  @ApiOperation({
    summary: 'Get order by ID',
    description: 'Get a specific order by its ID.',
  })
  @ApiParam({
    name: 'orderId',
    description: 'The ID of the order to get.',
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.ADMIN)
  @Get(':orderId')
  findOrderById(@Param('orderId') orderId: string) {
    return this.ordersService.findOrderById(orderId);
  }

  // checkOut
  @ApiOperation({
    summary: 'Check out',
    description: 'Check out the cart and create an order.',
  })
  @ApiBody({
    type: CheckOutDto,
    description: 'Check out the cart and create an order.',
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.CUSTOMER)
  @Post('checkout')
  checkOut(
    @Body() checkOutDto: CheckOutDto,
    @ActiveUser('sub') userId: string,
  ) {
    return this.ordersService.checkOut({
      ...checkOutDto,
      userId,
    });
  }

  // updateOrderStatus
  @ApiOperation({
    summary: 'Update order status',
    description: 'Update the status of an order.',
  })
  @ApiBody({
    type: UpdateOrderStatusDto,
    description: 'Update the status of an order.',
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.CUSTOMER, UserRole.VENDOR, UserRole.ADMIN)
  @Patch(':orderId/status')
  updateStatus(
    @Param('orderId') orderId: string,
    @Body() updateOrderStatusDto: UpdateOrderStatusDto,
    @ActiveUser('role') role: UserRole,
  ) {
    return this.ordersService.updateOrderStatusById(
      orderId,
      updateOrderStatusDto,
      role,
    );
  }
}
</file>

<file path="src/api/orders/orders.module.ts">
import { Module } from '@nestjs/common';
import { PrismaModule } from 'src/common/prisma/prisma.module';
import { AddressesModule } from '../addresses/addresses.module';
import { CartModule } from '../cart/cart.module';
import { OrdersController } from './orders.controller';
import { OrdersService } from './orders.service';
import { CheckOutProvider } from './providers/check-out.provider';
import { FindMyOrdersProvider } from './providers/find-my-orders.provider';
import { FindMyOrderProvider } from './providers/find-my-order.provider';
import { FindAllOrdersProvider } from './providers/find-all-orders.provider';
import { FindAllVendorOrdersProvider } from './providers/find-all-vendor-orders.provider';
import { FindOrderByIdProvider } from './providers/find-order-by-id.provider';
import { UpdateOrderStatusByIdProvider } from './providers/update-order-status-by-id.provider';
import { FindOneOrderProvider } from './providers/find-one-order.provider';
import { VendorsModule } from '../vendors/vendors/vendors.module';

@Module({
  controllers: [OrdersController],
  providers: [
    OrdersService,
    CheckOutProvider,
    FindMyOrdersProvider,
    FindMyOrderProvider,
    FindAllOrdersProvider,
    FindAllVendorOrdersProvider,
    FindOrderByIdProvider,
    UpdateOrderStatusByIdProvider,
    FindOneOrderProvider,
  ],
  imports: [PrismaModule, CartModule, AddressesModule, VendorsModule],
  exports: [OrdersService],
})
export class OrdersModule {}
</file>

<file path="src/api/orders/orders.service.ts">
import { Injectable } from '@nestjs/common';
import { UserRole } from '@prisma/client';
import { CheckOutDto } from './dtos/checkout.dto';
import { UpdateOrderStatusDto } from './dtos/update-order-status.dto';
import {
  CheckOutProvider,
  FindAllOrdersProvider,
  FindAllVendorOrdersProvider,
  FindMyOrderProvider,
  FindMyOrdersProvider,
  FindOrderByIdProvider,
  UpdateOrderStatusByIdProvider,
} from './providers';

@Injectable()
export class OrdersService {
  constructor(
    private readonly checkOutProvider: CheckOutProvider,
    private readonly findAllOrdersProvider: FindAllOrdersProvider,
    private readonly findAllVendorOrdersProvider: FindAllVendorOrdersProvider,
    private readonly findMyOrderProvider: FindMyOrderProvider,
    private readonly findMyOrdersProvider: FindMyOrdersProvider,
    private readonly findOrderByIdProvider: FindOrderByIdProvider,
    private readonly updateOrderStatusByIdProvider: UpdateOrderStatusByIdProvider,
  ) {}

  findAllOrders() {
    return this.findAllOrdersProvider.findAllOrders();
  }

  findAllVendorOrders(vendorId: string, userId: string) {
    return this.findAllVendorOrdersProvider.findAllVendorOrders(
      vendorId,
      userId,
    );
  }

  findMyOrder(orderId: string, userId: string) {
    return this.findMyOrderProvider.findMyOrder(orderId, userId);
  }

  findMyOrders(userId: string) {
    return this.findMyOrdersProvider.findMyOrders(userId);
  }

  findOrderById(orderId: string) {
    return this.findOrderByIdProvider.findOrderById(orderId);
  }

  checkOut(checOutDto: CheckOutDto) {
    return this.checkOutProvider.checkOut(checOutDto);
  }

  updateOrderStatusById(
    orderId: string,
    updateOrderStatusDto: UpdateOrderStatusDto,
    role: UserRole,
  ) {
    return this.updateOrderStatusByIdProvider.updateOrderStatusById(
      orderId,
      updateOrderStatusDto,
      role,
    );
  }
}
</file>

<file path="src/api/payments/chapa/dtos/initialize-order-payment.dto.ts">
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsUUID } from 'class-validator';

export class InitializeOrderPaymentDto {
  @ApiProperty({ description: 'Order ID to pay for' })
  @IsNotEmpty()
  @IsUUID()
  orderId: string;

  userId: string;
}
</file>

<file path="src/api/payments/chapa/dtos/verify-order-payment.dto.ts">
export class VerifyOrderPaymentDto {
  tx_ref: string;
}
</file>

<file path="src/api/payments/chapa/interfaces/supported-bank-info.interface.ts">
export interface IBankInfo {
  bank_code: string;
  bank_slug: string;
  bank_name: string;
  acct_length: number;
  currency: string;
  example_acc_num: string;
}
</file>

<file path="src/api/payments/chapa/providers/find-supported-bank-infos.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { IBankInfo } from '../interfaces/supported-bank-info.interface';

@Injectable()
export class FindSupportedBankInfosProvider {
  private chapa_secret_key: string;
  constructor(private readonly configService: ConfigService) {
    this.chapa_secret_key = this.configService.get(
      'paymentConfig.chapaSecretKey',
    );
  }
  public async findSupportedBankInfos() {
    try {
      const response = await fetch('https://api.chapa.co/v1/banks', {
        method: 'GET',
        headers: {
          Authorization: `Bearer ${this.chapa_secret_key}`,
          'Content-Type': 'application/json',
        },
      });

      const resBody = await response.json();
      if (resBody.status === 'failed') {
        throw new InternalServerErrorException(resBody.message);
      }

      const bankInfos: IBankInfo[] = resBody.data.map((bank) => {
        const bankInfo: IBankInfo = {
          bank_name: bank.name,
          bank_code: bank.id,
          bank_slug: bank.slug,
          acct_length: Number(bank.acct_length),
          currency: bank.currency,
          example_acc_num: '1000'.padEnd(
            Number(bank.acct_length),
            Math.random().toString().slice(14),
          ),
        };
        return bankInfo;
      });

      return CreateApiResponse({
        status: 'success',
        message: 'fetching supported bank infos is successfull.',
        data: bankInfos,
      });
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'Unable to find fetching supported bank infos.',
      );
    }
  }
}
</file>

<file path="src/api/payments/chapa/providers/initialize-order-payment.provider.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PaymentMethod, PaymentStatus, Prisma } from '@prisma/client';
import { ChapaService } from 'chapa-nestjs';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { InitializeOrderPaymentDto } from '../dtos/initialize-order-payment.dto';

@Injectable()
export class InitializeOrderPaymentProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly chapaService: ChapaService,
    private readonly configService: ConfigService,
  ) {}

  public async initializeOrderPayment(
    initializeOrderPaymentDto: InitializeOrderPaymentDto,
  ) {
    const { orderId, userId } = initializeOrderPaymentDto;
    let order: Prisma.OrderGetPayload<{ include: { User: true } }>;

    try {
      order = await this.prisma.order.findUnique({
        where: {
          id: orderId,
          userId,
        },
        include: {
          User: true,
        },
      });
    } catch (err) {
      console.log('initializeOrderPayment: ', err);
      throw new InternalServerErrorException(
        'Unablet to fetch the order.  please try again later.',
      );
    }

    if (!order) {
      throw new NotFoundException(
        'The order you are trying to pay for does not exist.',
      );
    }

    // We create a text reference for the Chapa Service
    let txRef: string | undefined;
    try {
      txRef = await this.chapaService.generateTransactionReference();
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'Error occured when generating a transaction reference',
      );
    }

    try {
      // First we create payment with status of PENDING
      await this.prisma.payment.create({
        data: {
          orderId,
          amount: order.total_price,
          status: PaymentStatus.PENDING,
          paymentMethod: PaymentMethod.CHAPA,
          reference: txRef,
        },
      });
    } catch (err) {
      console.log('initializeOrderPayment: ', err);
      throw new InternalServerErrorException(
        'Unable to create payment. Please try again later.',
      );
    }
    // Then we initialize the payment with ChapaService
    const { first_name, last_name, email } = order.User;
    try {
      const response = await this.chapaService.initialize({
        first_name,
        last_name,
        email,
        currency: 'ETB',
        amount: order.total_price.toString(),
        tx_ref: txRef,
        callback_url: this.configService.get('paymentConfig.chapaWebhookUrl'),
      });

      // return response
      return response;
    } catch (err) {
      console.log('initializeOrderPayment: ', err);
      throw new InternalServerErrorException(
        'Unable to initialize payment. Please try again later.',
      );
    }
  }
}
</file>

<file path="src/api/payments/chapa/providers/verify-order-payment.provider.ts">
import { BadRequestException, Injectable } from '@nestjs/common';
import { OrderStatus, Payment, PaymentStatus } from '@prisma/client';
import { ChapaService } from 'chapa-nestjs';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { VerifyOrderPaymentDto } from '../dtos/verify-order-payment.dto';

@Injectable()
export class VerifyOrderPaymentProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly chapaService: ChapaService,
  ) {}

  public async verifyOrderPayment(
    verifyOrderPaymentDto: VerifyOrderPaymentDto,
  ) {
    const { tx_ref } = verifyOrderPaymentDto;

    const response = await this.chapaService.verify({ tx_ref });

    if (response.status !== 'success') {
      throw new BadRequestException(
        'Invalid transaction or Transaction not found	',
      );
    }

    let payment: Payment;
    try {
      payment = await this.prisma.payment.findFirst({
        where: {
          reference: tx_ref,
          status: PaymentStatus.PENDING,
        },
      });
    } catch (err) {
      console.log('verifyPayment error', err);
      throw new BadRequestException(
        'Unable to find payment. please try again later.',
      );
    }

    if (!payment) {
      throw new BadRequestException('Payment not found');
    }

    // if payment found update the status to paid
    try {
      await this.prisma.$transaction([
        this.prisma.payment.update({
          where: { id: payment.id },
          data: {
            status: PaymentStatus.PAID,
            paidAt: new Date(),
          },
        }),
        this.prisma.order.update({
          where: { id: payment.orderId },
          data: {
            status: OrderStatus.CONFIRMED,
          },
        }),
      ]);
    } catch (err) {
      console.log('verifyPayment error', err);
      throw new BadRequestException(
        'Unable to update payment status. please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'Payment verified successfully',
      data: null,
    });
  }
}
</file>

<file path="src/api/payments/chapa/chapa.controller.ts">
import {
  BadRequestException,
  Body,
  Controller,
  Get,
  Headers,
  Post,
} from '@nestjs/common';
import * as crypto from 'crypto';
import { ConfigService } from '@nestjs/config';
import { ApiBearerAuth, ApiBody, ApiOperation, ApiTags } from '@nestjs/swagger';
import { ChapaService } from './chapa.service';
import { InitializeOrderPaymentDto } from './dtos/initialize-order-payment.dto';
import { ActiveUser, Auth } from 'src/api/auth/decorators';
import { AuthType } from 'src/api/auth/enums/auth-type.enum';
import { VerifyOrderPaymentDto } from './dtos/verify-order-payment.dto';

@ApiTags('Payments/Chapa')
@Controller('payments/chapa')
export class ChapaController {
  constructor(
    private readonly chapaService: ChapaService,
    private readonly configService: ConfigService,
  ) {}

  // initialize payment
  @ApiOperation({
    summary: 'Initialize Order Payment',
  })
  @ApiBody({
    type: InitializeOrderPaymentDto,
    required: true,
  })
  @ApiBearerAuth()
  @Post('initialize')
  initializeOrderPayment(
    @Body() initializeOrderPaymentDto: InitializeOrderPaymentDto,
    @ActiveUser('sub') userId: string,
  ) {
    initializeOrderPaymentDto.userId = userId;
    return this.chapaService.initializeOrderPayment(initializeOrderPaymentDto);
  }
  // web hook URL for verifying
  @ApiOperation({
    summary: 'Chapa Webhook url',
    description:
      'Chapa webhook url, this route is called by chapa when their is an event. it helps us to verify the payment.',
  })
  @ApiBody({
    type: VerifyOrderPaymentDto,
    required: true,
  })
  @Auth(AuthType.NONE)
  @Get('chapa/webhook/verify')
  public verifyOrderPayment(
    @Body() verifyOrderPaymentDto: VerifyOrderPaymentDto,
    @Headers('x-chapa-signature') chapaSignature: string,
  ) {
    const hash = crypto
      .createHmac(
        'sha256',
        this.configService.get('appConfig.chapaWebhookSecret'),
      )
      .update(JSON.stringify(verifyOrderPaymentDto))
      .digest('hex');

    if (hash !== chapaSignature) {
      console.error(`Invalid chapa signature: ${hash}`);
      throw new BadRequestException('Invalid Chapa Signature');
    }

    return this.chapaService.verifyOrderPayment(verifyOrderPaymentDto);
  }

  @ApiOperation({
    summary: 'Find All Supported Banks.',
    description: 'Find All Supported Banks and bank codes.',
  })
  @ApiBearerAuth()
  @Get('chapa/supported-banks')
  findSupportedBankInfos() {
    return this.chapaService.findSupportedBankInfos();
  }
}
</file>

<file path="src/api/payments/chapa/chapa.service.ts">
import { Injectable } from '@nestjs/common';
import { InitializeOrderPaymentProvider } from './providers/initialize-order-payment.provider';
import { VerifyOrderPaymentProvider } from './providers/verify-order-payment.provider';
import { InitializeOrderPaymentDto } from './dtos/initialize-order-payment.dto';
import { VerifyOrderPaymentDto } from './dtos/verify-order-payment.dto';
import { FindSupportedBankInfosProvider } from './providers/find-supported-bank-infos.provider';

@Injectable()
export class ChapaService {
  constructor(
    private readonly initializeOrderPaymentProvider: InitializeOrderPaymentProvider,
    private readonly verifyOrderPaymentProvider: VerifyOrderPaymentProvider,
    private readonly findSupportedBankInfosProvider: FindSupportedBankInfosProvider,
  ) {}

  initializeOrderPayment(initializeOrderPaymentDto: InitializeOrderPaymentDto) {
    return this.initializeOrderPaymentProvider.initializeOrderPayment(
      initializeOrderPaymentDto,
    );
  }

  verifyOrderPayment(verifyOrderPaymentDto: VerifyOrderPaymentDto) {
    return this.verifyOrderPaymentProvider.verifyOrderPayment(
      verifyOrderPaymentDto,
    );
  }

  findSupportedBankInfos() {
    return this.findSupportedBankInfosProvider.findSupportedBankInfos();
  }
}
</file>

<file path="src/api/payments/payments.module.ts">
import { Module } from '@nestjs/common';
import { PrismaModule } from 'src/common/prisma/prisma.module';
import { ChapaController } from './chapa/chapa.controller';
import { ChapaService } from './chapa/chapa.service';
import { InitializeOrderPaymentProvider } from './chapa/providers/initialize-order-payment.provider';
import { VerifyOrderPaymentProvider } from './chapa/providers/verify-order-payment.provider';
import { FindSupportedBankInfosProvider } from './chapa/providers/find-supported-bank-infos.provider';

@Module({
  controllers: [ChapaController],
  providers: [
    ChapaService,
    InitializeOrderPaymentProvider,
    VerifyOrderPaymentProvider,
    FindSupportedBankInfosProvider,
  ],
  imports: [PrismaModule],
})
export class PaymentsModule {}
</file>

<file path="src/api/products/dto/create-product.dto.ts">
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Transform } from 'class-transformer';
import {
  IsArray,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
  Min,
} from 'class-validator';
import { ProductUnitEnum } from '../enum/product-unit.enum';

export class CreateProductDto {
  @ApiProperty({
    description: 'product name',
  })
  @IsNotEmpty()
  @IsString()
  name: string;

  @ApiProperty({
    description: 'product description',
  })
  @IsNotEmpty()
  @IsString()
  description: string;

  @ApiProperty({
    description: 'Price per unit (e.g., per kg, per piece).',
  })
  @IsNotEmpty()
  @IsNumber()
  @Min(0)
  price: number;

  @ApiProperty({
    description: 'Optional discount price',
  })
  @IsOptional()
  @IsNumber()
  @Min(0)
  discount_price: number;

  @ApiProperty({
    description: 'Measurement unit',
    enum: ProductUnitEnum,
  })
  @IsNotEmpty()
  @IsString()
  unit: string;

  @ApiProperty({
    description: 'Product availability',
  })
  @IsNotEmpty()
  @IsNumber()
  stock: number;

  @ApiProperty({
    description: 'product image',
    type: 'string',
    format: 'binary',
  })
  @IsOptional()
  @IsString()
  image?: string;

  @ApiPropertyOptional({
    type: 'array',
    items: {
      description: 'Category Ids',
      type: 'string',
    },
  })
  @Transform(({ value }) => {
    console.log({ value });
    if (!value) return []; // Ensure it's always an array
    if (Array.isArray(value)) return value; // Already an array, return as is
    if (
      typeof value === 'string' &&
      value.includes('[') &&
      value.includes(']')
    ) {
      value = String(value.slice(2, -2));
    }
    if (typeof value === 'string') {
      return value.includes(',')
        ? value.split(',').map((v) => v.trim())
        : [value];
    }

    return [];
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  categories?: string[];

  // get it from the current login vendor
  userId: string;
  image_url: string;
}
</file>

<file path="src/api/products/dto/get-products.dto.ts">
import { IntersectionType } from '@nestjs/swagger';
import { PaginationQueryDto } from 'src/common/pagination/dtos/pagination-query.dto';
import { ApiProperty } from '@nestjs/swagger';
import {
  IsNumber,
  IsOptional,
  IsString,
  IsUUID,
  IsBoolean,
  IsEnum,
  Min,
  IsIn,
} from 'class-validator';
import { Type } from 'class-transformer';
import { ProductStatus } from '@prisma/client';

export class GetProductsBaseDto {
  @ApiProperty({
    description: 'Search term for filtering products',
    required: false,
  })
  @IsOptional()
  @IsString()
  search?: string;

  @ApiProperty({
    description: 'Minimum price',
    required: false,
  })
  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(0)
  minPrice?: number;

  @ApiProperty({
    description: 'Maximum price',
    required: false,
  })
  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(0)
  maxPrice?: number;

  @ApiProperty({
    description: 'Product status',
    enum: ProductStatus,
    required: false,
  })
  @IsOptional()
  @IsEnum(ProductStatus)
  status?: ProductStatus;

  @ApiProperty({
    description: 'Vendor ID',
    required: false,
  })
  @IsOptional()
  @IsUUID()
  vendorId?: string;

  @ApiProperty({
    description: 'Category ID',
    required: false,
  })
  @IsOptional()
  @IsUUID()
  categoryId?: string;

  @ApiProperty({
    description: 'Featured products only',
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  @Type(() => Boolean)
  isFeatured?: boolean;

  @ApiProperty({
    description: 'Sort by field',
    required: false,
    enum: ['name', 'price', 'createdAt', 'stock'],
  })
  @IsOptional()
  @IsString()
  @IsIn(['name', 'price', 'createdAt', 'stock'])
  sortBy?: string;

  @ApiProperty({
    description: 'Sort order',
    required: false,
    enum: ['asc', 'desc'],
  })
  @IsOptional()
  @IsString()
  @IsIn(['asc', 'desc'])
  sortOrder?: 'asc' | 'desc';
}

export class GetProductsDto extends IntersectionType(
  GetProductsBaseDto,
  PaginationQueryDto,
) {}
</file>

<file path="src/api/products/dto/update-product.dto.ts">
import { PartialType } from '@nestjs/mapped-types';
import { CreateProductDto } from './create-product.dto';

export class UpdateProductDto extends PartialType(CreateProductDto) {}
</file>

<file path="src/api/products/enum/product-unit.enum.ts">
export enum ProductUnitEnum {
  killogram = 'killogram',
  quintal = 'quintal',
}
</file>

<file path="src/api/products/interfaces/delete-product-by-id.interface.ts">
export interface IDeleteProductById {
  productId: string;
  vendorId: string;
}
</file>

<file path="src/api/products/providers/create-product.provider.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
} from '@nestjs/common';
import { Category } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { CreateProductDto } from '../dto/create-product.dto';
import { VendorsService } from 'src/api/vendors/vendors/vendors.service';

@Injectable()
export class CreateProductProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly vendorService: VendorsService,
  ) {}

  public async createProduct(createProductDto: CreateProductDto) {
    const {
      name,
      description,
      image_url,
      price,
      discount_price,
      unit,
      stock,
      categories,
      userId,
    } = createProductDto;

    // Validate category IDs
    if (categories?.length) {
      let foundCategories: Category[] | undefined;

      try {
        foundCategories = await this.prisma.category.findMany({
          where: {
            id: { in: categories },
          },
        });
      } catch (err) {
        console.log('createProduct: ', err);
        throw new InternalServerErrorException(
          'Unable to find categories. please try again later.',
        );
      }

      const foundIds = foundCategories.map((categ) => categ.id);
      const missingIds = categories.filter((id) => !foundIds.includes(id));

      if (missingIds.length) {
        throw new BadRequestException(
          `Invalid category Ids, ${missingIds.join(', ')}`,
        );
      }
    }

    const vendor = await this.vendorService.findOneVendor({ userId });
    if (!vendor) {
      throw new BadRequestException('vendor not found.');
    }

    try {
      const product = await this.prisma.product.create({
        data: {
          name,
          description,
          price,
          discount_price,
          unit,
          stock,
          vendorId: vendor.id,
          image_url,
          categories: categories
            ? {
                connect: categories.map((id) => ({ id })),
              }
            : undefined,
        },
        include: {
          categories: true,
        },
      });

      return CreateApiResponse({
        status: 'success',
        message: 'create product successfull.',
        data: product,
      });
    } catch (err) {
      console.log('createProduct: ', err);
      throw new InternalServerErrorException('');
    }
  }
}
</file>

<file path="src/api/products/providers/delete-product-by-id.provider.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { FindOneProductProvider } from './find-one-product.provider';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { IDeleteProductById } from '../interfaces/delete-product-by-id.interface';

@Injectable()
export class DeleteProductByIdProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly findOneProductProvider: FindOneProductProvider,
  ) {}

  public async deleteProductById(options: IDeleteProductById) {
    // check if product exists
    const product = await this.findOneProductProvider.findOneProduct({
      id: options.productId,
      vendorId: options.vendorId,
    });

    if (!product) {
      throw new NotFoundException('product not found.');
    }

    try {
      await this.prisma.product.delete({ where: { id: options.productId } });
    } catch (err) {
      console.log('deleteProductById: ', err);
      throw new InternalServerErrorException(
        'Unable to delete product. please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'product deleted successfully.',
      data: null,
    });
  }
}
</file>

<file path="src/api/products/providers/find-all-products.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { Prisma } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { GetProductsDto } from '../dto/get-products.dto';

@Injectable()
export class FindAllProductsProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findAllProducts(query: GetProductsDto) {
    try {
      const {
        search,
        page,
        limit,
        minPrice,
        maxPrice,
        status,
        vendorId,
        categoryId,
        isFeatured,
        sortBy,
        sortOrder,
      } = query;

      // Build the where condition
      const whereCondition: Prisma.ProductWhereInput = {
        AND: [
          // Search across text fields
          search
            ? {
                OR: [
                  { name: { contains: search, mode: 'insensitive' } },
                  { description: { contains: search, mode: 'insensitive' } },
                  { unit: { contains: search, mode: 'insensitive' } },
                ],
              }
            : {},
          // Price range
          minPrice ? { price: { gte: minPrice } } : {},
          maxPrice ? { price: { lte: maxPrice } } : {},
          // Status filter
          status ? { status } : {},
          // Vendor filter
          vendorId ? { vendorId } : {},
          // Featured products filter
          typeof isFeatured === 'boolean' ? { is_featured: isFeatured } : {},
          // Category filter
          categoryId
            ? {
                categories: {
                  some: {
                    id: categoryId,
                  },
                },
              }
            : {},
        ],
      };

      // Build the orderBy condition
      const orderBy: Prisma.ProductOrderByWithRelationInput = {
        [sortBy || 'createdAt']: sortOrder || 'desc',
      };

      // Get products with filters, search and pagination
      const products = await this.prisma.product.findMany({
        where: whereCondition,
        orderBy,
        skip: (page - 1) * limit,
        take: limit,
        include: {
          Vendor: {
            select: {
              id: true,
              business_name: true,
              business_email: true,
              logo_url: true,
            },
          },
          categories: {
            select: {
              id: true,
              name: true,
            },
          },
        },
      });

      // Get total count with filters
      const totalItems = await this.prisma.product.count({
        where: whereCondition,
      });

      const totalPages = Math.ceil(totalItems / limit);

      return CreateApiResponse({
        status: 'success',
        message: 'Find all products successful.',
        metadata: {
          currentPage: page,
          itemsPerPage: limit,
          totalItems,
          totalPages,
        },
        data: products,
      });
    } catch (err) {
      console.log('findAllProducts error: ', err);
      throw new InternalServerErrorException(
        'Unable to find products. Please try again later.',
      );
    }
  }
}
</file>

<file path="src/api/products/providers/find-one-product.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { Product } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';

@Injectable()
export class FindOneProductProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findOneProduct(options: Partial<Product>) {
    try {
      const product = await this.prisma.product.findFirst({ where: options });
      return product;
    } catch (err) {
      console.log('findOneProduct: ', err);
      throw new InternalServerErrorException(
        'Unable to find one products. please try again later.',
      );
    }
  }
}
</file>

<file path="src/api/products/providers/find-product-by-id.provider.ts">
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { FindOneProductProvider } from './find-one-product.provider';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class FindProductByIdProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly findOneProductProvider: FindOneProductProvider,
  ) {}
  public async findProductById(id: string) {
    // check if product exists
    const product = await this.findOneProductProvider.findOneProduct({ id });

    if (!product) {
      throw new NotFoundException('product not found.');
    }

    // return response
    return CreateApiResponse({
      status: 'success',
      message: 'find product by id successfull',
      data: product,
    });
  }
}
</file>

<file path="src/api/products/providers/find-products-by-category.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class FindProductsByCategoryProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findProductByCategory(categoryId: string) {
    let data;

    try {
      data = await this.prisma.category.findFirst({
        where: { id: categoryId },
        include: {
          products: {
            select: {
              id: true,
              name: true,
              description: true,
              price: true,
              discount_price: true,
              unit: true,
              stock: true,
              image_url: true,
              status: true,
              is_featured: true,
              Vendor: true,
            },
          },
        },
      });
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'Unabble to find products by category id.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'find products by category successfull.',
      data,
    });
  }
}
</file>

<file path="src/api/products/providers/index.ts">
export { CreateProductProvider } from './create-product.provider';
export { UpdateProductByIdProvider } from './update-product-by-id.provider';
export { FindProductByIdProvider } from './find-product-by-id.provider';
export { FindOneProductProvider } from './find-one-product.provider';
export { FindAllProductsProvider } from './find-all-products.provider';
export { DeleteProductByIdProvider } from './delete-product-by-id.provider';
</file>

<file path="src/api/products/providers/update-product-by-id.provider.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { Category, Vendor } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { UpdateProductDto } from '../dto/update-product.dto';
import { FindOneProductProvider } from './find-one-product.provider';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class UpdateProductByIdProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly findOneProductProvider: FindOneProductProvider,
  ) {}

  public async updateProductById(
    id: string,
    updateProductDto: UpdateProductDto,
  ) {
    const {
      name,
      description,
      image_url,
      price,
      discount_price,
      unit,
      stock,
      categories,
      userId,
    } = updateProductDto;

    let vendor: Vendor;
    try {
      vendor = await this.prisma.vendor.findFirst({ where: { userId } });
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'unable to find vendor. please try again later.',
      );
    }

    if (!vendor) {
      throw new NotFoundException('vendor not found.');
    }

    // check if product exists
    let product = await this.findOneProductProvider.findOneProduct({
      id,
      vendorId: vendor.id,
    });

    if (!product) {
      throw new NotFoundException('vendor has not this product');
    }

    // Validate category IDs
    if (categories?.length) {
      let foundCategories: Category[] | undefined;

      try {
        foundCategories = await this.prisma.category.findMany({
          where: {
            id: { in: categories },
          },
        });
      } catch (err) {
        console.log('createProduct: ', err);
        throw new InternalServerErrorException(
          'Unable to find categories. please try again later.',
        );
      }

      const foundIds = foundCategories.map((categ) => categ.id);
      const missingIds = categories.filter((id) => !foundIds.includes(id));

      if (missingIds.length) {
        throw new BadRequestException(
          `Invalid category Ids, ${missingIds.join(', ')}`,
        );
      }
    }

    // update products
    try {
      product = await this.prisma.product.update({
        where: { id },
        data: {
          name: name ?? product.name,
          description: description ?? product.description,
          image_url: image_url ?? product.image_url,
          price: price ?? product.price,
          discount_price: discount_price ?? product.discount_price,
          unit: unit ?? product.unit,
          stock: stock ?? product.stock,
          categories: categories
            ? { set: categories.map((id) => ({ id })) }
            : undefined,
        },
        include: {
          categories: true,
        },
      });
    } catch (err) {
      console.log('update-product: ', err);
      throw new InternalServerErrorException('');
    }

    return CreateApiResponse({
      status: 'success',
      message: 'update product successfull',
      data: product,
    });
  }
}
</file>

<file path="src/api/products/products.controller.ts">
import {
  Body,
  Controller,
  Delete,
  Get,
  HttpCode,
  HttpStatus,
  Param,
  Patch,
  Post,
  Query,
  UploadedFile,
  UseInterceptors,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import {
  ApiBearerAuth,
  ApiBody,
  ApiConsumes,
  ApiOperation,
  ApiParam,
} from '@nestjs/swagger';
import { UserRole } from '@prisma/client';
import { FileUploadService } from 'src/common/file-upload/file-upload.service';
import { FileUploadDirNames } from 'src/lib/constants/file-upload-dir-names';
import { ActiveUser, Auth, Role } from '../auth/decorators';
import { AuthType } from '../auth/enums/auth-type.enum';
import { CreateProductDto } from './dto/create-product.dto';
import { GetProductsDto } from './dto/get-products.dto';
import { UpdateProductDto } from './dto/update-product.dto';
import { ProductsService } from './products.service';

@Controller('products')
export class ProductsController {
  constructor(
    private readonly productsService: ProductsService,
    private readonly fileUploadService: FileUploadService,
  ) {}

  @ApiOperation({
    summary: 'Create Product.',
  })
  @ApiBody({
    type: CreateProductDto,
    required: true,
  })
  @UseInterceptors(
    FileInterceptor(
      'image',
      FileUploadService.saveImageToStorage({
        dirName: FileUploadDirNames.product,
      }),
    ),
  )
  @ApiConsumes('multipart/form-data')
  @ApiBearerAuth()
  @Role(UserRole.VENDOR)
  @Post()
  createProduct(
    @Body() createProductDto: CreateProductDto,
    @ActiveUser('sub') userId: string,
    @UploadedFile() image: Express.Multer.File,
  ) {
    createProductDto.userId = userId;
    if (image) {
      createProductDto.image_url = this.fileUploadService.getFilePath(image);
    }
    console.log({ createProductDto });
    return this.productsService.createProduct(createProductDto);
  }

  @ApiOperation({
    summary: 'Find All Products',
  })
  @Auth(AuthType.NONE)
  @Get()
  findAllProducts(@Query() query: GetProductsDto) {
    return this.productsService.findAllProducts(query);
  }

  @ApiOperation({
    summary: 'find products by category',
  })
  @ApiParam({
    name: 'id',
    description: 'category id',
    required: true,
  })
  @Auth(AuthType.NONE)
  @Get('category/:id')
  findProductByCategory(@Param('id') categoryId: string) {
    return this.productsService.findProductByCategory(categoryId);
  }

  @ApiOperation({
    summary: 'Find Product by ID',
  })
  @ApiParam({
    name: 'id',
    description: 'product id',
    required: true,
  })
  @Auth(AuthType.NONE)
  @Get(':id')
  findProductById(@Param('id') id: string) {
    return this.productsService.findProductById(id);
  }

  @ApiOperation({
    summary: 'Create Product.',
  })
  @ApiBody({
    type: UpdateProductDto,
    required: true,
  })
  @ApiParam({
    name: 'id',
    description: 'product id',
    required: true,
  })
  @UseInterceptors(
    FileInterceptor(
      'image',
      FileUploadService.saveImageToStorage({
        dirName: FileUploadDirNames.product,
      }),
    ),
  )
  @ApiConsumes('multipart/form-data')
  @ApiBearerAuth()
  @Role(UserRole.VENDOR)
  @Patch(':id')
  updateProductById(
    @Param('id') id: string,
    @Body() updateProductDto: UpdateProductDto,
    @ActiveUser('sub') userId: string,
    @UploadedFile() image: Express.Multer.File,
  ) {
    updateProductDto.userId = userId;
    if (image) {
      updateProductDto.image_url = this.fileUploadService.getFilePath(image);
    }
    return this.productsService.updateProductById(id, updateProductDto);
  }

  @ApiOperation({
    summary: 'Delete Product by ID',
  })
  @ApiParam({
    name: 'id',
    description: 'product id',
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.VENDOR)
  @HttpCode(HttpStatus.NO_CONTENT)
  @Delete(':id')
  deleteProductById(
    @Param('id') id: string,
    @ActiveUser('sub') vendorId: string,
  ) {
    return this.productsService.deleteProductById({
      productId: id,
      vendorId,
    });
  }
}
</file>

<file path="src/api/products/products.module.ts">
import { Module } from '@nestjs/common';
import { ProductsController } from './products.controller';
import { ProductsService } from './products.service';
import { CreateProductProvider } from './providers/create-product.provider';
import { DeleteProductByIdProvider } from './providers/delete-product-by-id.provider';
import { FindAllProductsProvider } from './providers/find-all-products.provider';
import { FindOneProductProvider } from './providers/find-one-product.provider';
import { FindProductByIdProvider } from './providers/find-product-by-id.provider';
import { UpdateProductByIdProvider } from './providers/update-product-by-id.provider';
import { VendorsModule } from '../vendors/vendors/vendors.module';
import { PrismaModule } from 'src/common/prisma/prisma.module';
import { FileUploadModule } from 'src/common/file-upload/file-upload.module';
import { FindProductsByCategoryProvider } from './providers/find-products-by-category.provider';

@Module({
  controllers: [ProductsController],
  providers: [
    ProductsService,
    CreateProductProvider,
    DeleteProductByIdProvider,
    FindProductByIdProvider,
    FindOneProductProvider,
    FindAllProductsProvider,
    UpdateProductByIdProvider,
    FindProductsByCategoryProvider,
  ],
  imports: [VendorsModule, PrismaModule, FileUploadModule],
  exports: [ProductsService],
})
export class ProductsModule {}
</file>

<file path="src/api/products/products.service.ts">
import { Injectable } from '@nestjs/common';
import { Product } from '@prisma/client';
import { CreateProductDto } from './dto/create-product.dto';
import { UpdateProductDto } from './dto/update-product.dto';
import {
  CreateProductProvider,
  DeleteProductByIdProvider,
  FindAllProductsProvider,
  FindOneProductProvider,
  FindProductByIdProvider,
  UpdateProductByIdProvider,
} from './providers';
import { IDeleteProductById } from './interfaces/delete-product-by-id.interface';
import { GetProductsDto } from './dto/get-products.dto';
import { FindProductsByCategoryProvider } from './providers/find-products-by-category.provider';

@Injectable()
export class ProductsService {
  constructor(
    private readonly createProductProvider: CreateProductProvider,
    private readonly deleteProductByIdProvider: DeleteProductByIdProvider,
    private readonly findAllProductsProvider: FindAllProductsProvider,
    private readonly findProductByIdProvider: FindProductByIdProvider,
    private readonly findOneProductProvider: FindOneProductProvider,
    private readonly updateProductByIdProvider: UpdateProductByIdProvider,
    private readonly findProductsByCategoryProvider: FindProductsByCategoryProvider,
  ) {}

  createProduct(createProductDto: CreateProductDto) {
    return this.createProductProvider.createProduct(createProductDto);
  }

  findAllProducts(query: GetProductsDto) {
    return this.findAllProductsProvider.findAllProducts(query);
  }

  findProductById(id: string) {
    return this.findProductByIdProvider.findProductById(id);
  }

  updateProductById(id: string, updateProductDto: UpdateProductDto) {
    return this.updateProductByIdProvider.updateProductById(
      id,
      updateProductDto,
    );
  }

  deleteProductById(options: IDeleteProductById) {
    return this.deleteProductByIdProvider.deleteProductById(options);
  }

  findOneProduct(options: Partial<Product>) {
    return this.findOneProductProvider.findOneProduct(options);
  }

  findProductByCategory(categoryId: string) {
    return this.findProductsByCategoryProvider.findProductByCategory(
      categoryId,
    );
  }
}
</file>

<file path="src/api/reviews/dto/create-review.dto.ts">
import {
  IsString,
  IsUUID,
  IsInt,
  Min,
  Max,
  IsOptional,
  IsNotEmpty,
} from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class CreateReviewDto {
  @ApiProperty({
    description: 'Unique identifier for the order item being reviewed',
  })
  @IsNotEmpty()
  @IsUUID()
  orderItemId: string;

  @ApiProperty({
    description: 'Rating for the review, from 1 to 5',
    minimum: 1,
    maximum: 5,
  })
  @IsNotEmpty()
  @IsInt()
  @Min(1)
  @Max(5)
  rating: number;

  @ApiPropertyOptional({
    description: 'Optional comment for the review',
  })
  @IsNotEmpty()
  @IsString()
  @IsOptional()
  comment?: string;

  userId: string;
}
</file>

<file path="src/api/reviews/dto/update-review.dto.ts">
import { PartialType } from '@nestjs/swagger';
import { CreateReviewDto } from './create-review.dto';

export class UpdateReviewDto extends PartialType(CreateReviewDto) {}
</file>

<file path="src/api/reviews/reviews.controller.ts">
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { ReviewsService } from './reviews.service';
import { CreateReviewDto } from './dto/create-review.dto';
import { UpdateReviewDto } from './dto/update-review.dto';
import { ActiveUser, Auth, Role } from '../auth/decorators';
import {
  ApiBearerAuth,
  ApiBody,
  ApiOperation,
  ApiParam,
} from '@nestjs/swagger';
import { UserRole } from '@prisma/client';
import { AuthType } from '../auth/enums/auth-type.enum';

@Controller('reviews')
export class ReviewsController {
  constructor(private readonly reviewsService: ReviewsService) {}

  @ApiOperation({
    summary: 'Create Review',
  })
  @ApiBody({
    type: CreateReviewDto,
    description: 'Create a new review',
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.CUSTOMER)
  @Post()
  createReview(
    @Body() createReviewDto: CreateReviewDto,
    @ActiveUser('sub') userId: string,
  ) {
    createReviewDto.userId = userId;
    return this.reviewsService.createReview(createReviewDto);
  }

  @ApiOperation({
    summary: 'Get my reviews',
  })
  @ApiBearerAuth()
  @Role(UserRole.CUSTOMER)
  @Get('my-reviews')
  findMyReviews(@ActiveUser('sub') userId: string) {
    return this.reviewsService.findMyReviews(userId);
  }

  // findReviewsByProductId
  @ApiOperation({
    summary: 'Get reviews by product id',
  })
  @ApiParam({
    name: 'productId',
    description: 'Product ID',
    required: true,
  })
  @Auth(AuthType.NONE)
  @Get('product/:productId')
  findReviewsByProductId(@Param('productId') productId: string) {
    return this.reviewsService.findReviewsByProductId(productId);
  }

  // findReviewById
  @ApiOperation({
    summary: 'Get review by id',
  })
  @ApiParam({
    name: 'id',
    description: 'Review ID',
    required: true,
  })
  @Auth(AuthType.NONE)
  @Get(':id')
  findReviewById(@Param('id') id: string) {
    return this.reviewsService.findReviewById(id);
  }

  // updateMyReview
  @ApiOperation({
    summary: 'Update my review',
  })
  @ApiParam({
    name: 'id',
    description: 'Review ID',
    required: true,
  })
  @ApiBody({
    type: UpdateReviewDto,
    description: 'Update a review',
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.CUSTOMER)
  @Patch(':id')
  updateMyReview(
    @Param('id') id: string,
    @Body() updateReviewDto: UpdateReviewDto,
    @ActiveUser('sub') userId: string,
  ) {
    updateReviewDto.userId = userId;
    return this.reviewsService.updateMyReview(id, updateReviewDto);
  }

  // deleteMyReview
  @ApiOperation({
    summary: 'Delete my review',
  })
  @ApiParam({
    name: 'id',
    description: 'Review ID',
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.CUSTOMER)
  @Delete('/my-reviews/:id')
  deleteMyReview(@Param('id') id: string, @ActiveUser('sub') userId: string) {
    return this.reviewsService.deleteMyReview(id, userId);
  }

  // deleteReview
  @ApiOperation({
    summary: 'Delete review',
  })
  @ApiParam({
    name: 'id',
    description: 'Review ID',
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.ADMIN)
  @Delete(':id')
  deleteReview(@Param('id') id: string) {
    return this.reviewsService.deleteReview(id);
  }
}
</file>

<file path="src/api/reviews/reviews.module.ts">
import { Module } from '@nestjs/common';
import { PrismaModule } from 'src/common/prisma/prisma.module';
import { ReviewsController } from './reviews.controller';
import { ReviewsService } from './reviews.service';

@Module({
  controllers: [ReviewsController],
  providers: [ReviewsService],
  imports: [PrismaModule],
})
export class ReviewsModule {}
</file>

<file path="src/api/reviews/reviews.service.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { Prisma, Review } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { CreateReviewDto } from './dto/create-review.dto';
import { UpdateReviewDto } from './dto/update-review.dto';

@Injectable()
export class ReviewsService {
  constructor(private readonly prisma: PrismaService) {}

  public async createReview(createReviewDto: CreateReviewDto) {
    const { orderItemId, rating, userId, comment } = createReviewDto;

    let orderItem: Prisma.OrderItemGetPayload<{
      include: { Review: true; Order: true };
    }>;
    try {
      orderItem = await this.prisma.orderItem.findUnique({
        where: {
          id: orderItemId,
        },
        include: { Review: true, Order: true },
      });
    } catch (err) {
      console.log('createReview: ', err);
      throw new InternalServerErrorException(
        'Unable to find order item, please try again',
      );
    }

    if (!orderItem || orderItem.Order.userId !== userId) {
      throw new NotFoundException('Order item not found or not yours');
    }

    if (orderItem.Review || orderItem.reviewed) {
      throw new BadRequestException('You already reviewed this product');
    }

    try {
      const [review] = await this.prisma.$transaction([
        this.prisma.review.create({
          data: {
            rating,
            comment,
            userId,
            orderItemId,
          },
        }),
        this.prisma.orderItem.update({
          where: { id: orderItemId },
          data: { reviewed: true },
        }),
      ]);

      return CreateApiResponse({
        status: 'success',
        message: 'Review created successfully',
        data: review,
      });
    } catch (err) {
      console.log('createReview: ', err);
      throw new InternalServerErrorException(
        'Unable to create review, please try again',
      );
    }
  }

  public async findMyReviews(userId: string) {
    let reviews: Review[];
    try {
      reviews = await this.prisma.review.findMany({
        where: { userId },
        include: { OrderItem: true },
      });
    } catch (err) {
      console.error('[ReviewService:getMyReviews]', err);
      throw new InternalServerErrorException('Could not fetch reviews');
    }

    if (!reviews || reviews.length === 0) {
      throw new NotFoundException('No reviews found');
    }

    return CreateApiResponse({
      status: 'success',
      message: 'Reviews fetched successfully',
      data: reviews,
    });
  }

  public async findReviewById(id: string) {
    let review: Review;
    try {
      review = await this.prisma.review.findUnique({
        where: { id },
        include: { OrderItem: { include: { Product: true } } },
      });
    } catch (err) {
      console.error('[ReviewService:getMyReviews]', err);
      throw new InternalServerErrorException('Could not fetch review');
    }

    if (!review) {
      throw new NotFoundException('Review not found');
    }

    return CreateApiResponse({
      status: 'success',
      message: 'Review fetched successfully',
      data: review,
    });
  }

  public async findReviewsByProductId(productId: string) {
    let reviews: Review[];
    try {
      reviews = await this.prisma.review.findMany({
        where: { OrderItem: { productId } },
        include: { OrderItem: { include: { Product: true } } },
      });
    } catch (err) {
      console.error('[ReviewService:getMyReviews]', err);
      throw new InternalServerErrorException('Could not fetch reviews');
    }

    if (!reviews || reviews.length === 0) {
      throw new NotFoundException('No reviews found');
    }

    return CreateApiResponse({
      status: 'success',
      message: 'Reviews fetched successfully',
      data: reviews,
    });
  }

  public async updateMyReview(id: string, updateReviewDto: UpdateReviewDto) {
    const { comment, rating, userId } = updateReviewDto;

    let review: Review;
    try {
      review = await this.prisma.review.findUnique({
        where: { id },
      });
    } catch (err) {
      console.error('[ReviewService:updateReview]', err);
      throw new InternalServerErrorException('Could not fetch review');
    }

    if (!review || review.userId !== userId) {
      throw new NotFoundException('Review not found or not yours');
    }

    try {
      const updatedReview = await this.prisma.review.update({
        where: { id },
        data: {
          comment,
          rating,
        },
      });

      return CreateApiResponse({
        status: 'success',
        message: 'Review updated successfully',
        data: updatedReview,
      });
    } catch (err) {
      console.error('[ReviewService:updateReview]', err);
      throw new InternalServerErrorException('Could not update review');
    }
  }

  public async deleteMyReview(reviewId: string, userId: string) {
    let review: Review;
    try {
      review = await this.prisma.review.findUnique({
        where: { id: reviewId },
      });
    } catch (err) {
      console.error('[ReviewService:updateReview]', err);
      throw new InternalServerErrorException('Could not fetch review');
    }

    if (!review || review.userId !== userId) {
      throw new NotFoundException('Review not found or not yours');
    }

    try {
      await this.prisma.review.delete({
        where: { id: reviewId },
      });

      return CreateApiResponse({
        status: 'success',
        message: 'Review deleted successfully',
      });
    } catch (err) {
      console.error('[ReviewService:updateReview]', err);
      throw new InternalServerErrorException('Could not delete review');
    }
  }

  public async deleteReview(reviewId: string) {
    let review: Review;
    try {
      review = await this.prisma.review.findUnique({
        where: { id: reviewId },
      });
    } catch (err) {
      console.error('[ReviewService:updateReview]', err);
      throw new InternalServerErrorException('Could not fetch review');
    }

    if (!review) {
      throw new NotFoundException('Review not found');
    }

    try {
      await this.prisma.review.delete({
        where: { id: reviewId },
      });

      return CreateApiResponse({
        status: 'success',
        message: 'Review deleted successfully',
      });
    } catch (err) {
      console.error('[ReviewService:updateReview]', err);
      throw new InternalServerErrorException('Could not delete review');
    }
  }
}
</file>

<file path="src/api/users/dto/complete-onboarding.dto.ts">
import { ApiProperty } from '@nestjs/swagger';
import { Gender } from '@prisma/client';
import { IsDateString, IsEnum, IsNotEmpty, IsString } from 'class-validator';

export class CompleteOnboardingDto {
  @ApiProperty({
    description: 'first name of the user.',
  })
  @IsNotEmpty()
  @IsString()
  first_name: string;

  @ApiProperty({
    description: 'last name of the user.',
  })
  @IsNotEmpty()
  @IsString()
  last_name: string;

  @ApiProperty({
    description: 'date of birth.',
  })
  @IsNotEmpty()
  @IsDateString()
  date_of_birth: string;

  @ApiProperty({
    description: 'gender of user',
    enum: Gender,
  })
  @IsNotEmpty()
  @IsEnum(Gender)
  gender: Gender;

  @ApiProperty({
    description: 'Profile picture of the user (file upload)',
    type: 'string',
    format: 'binary',
    required: true,
  })
  profile_picture: string;

  @ApiProperty({
    description: 'users identification card photo front page',
    required: true,
    type: 'string',
    format: 'binary',
  })
  idPhoto_front: string;

  @ApiProperty({
    description: 'users identification card photo front page',
    required: true,
    type: 'string',
    format: 'binary',
  })
  idPhoto_back: string;

  userId: string;
}
</file>

<file path="src/api/users/dto/create-user.dto.ts">
import { ApiProperty } from '@nestjs/swagger';
import { UserRole } from '@prisma/client';
import {
  IsEmail,
  IsEnum,
  IsNotEmpty,
  IsPhoneNumber,
  IsString,
} from 'class-validator';

export class CreateUserDto {
  @ApiProperty({
    description: 'user first name',
  })
  @IsNotEmpty()
  @IsString()
  firstName: string;

  @ApiProperty({
    description: 'user last name',
  })
  @IsNotEmpty()
  @IsString()
  lastName: string;

  @ApiProperty({
    description: 'user email',
  })
  @IsNotEmpty()
  @IsEmail()
  email: string;

  @ApiProperty({
    description: 'user phone number',
  })
  @IsNotEmpty()
  @IsPhoneNumber()
  phoneNumber: string;

  @ApiProperty({
    description: 'user role',
    enum: UserRole,
    example: UserRole.CUSTOMER,
  })
  @IsNotEmpty()
  @IsEnum(UserRole)
  role: UserRole;
}
</file>

<file path="src/api/users/dto/index.ts">
export { VerifyUserDto } from './verify-user.dto';
export { CompleteOnboardingDto } from './complete-onboarding.dto';
export { CreateUserDto } from './create-user.dto';
export { UpdateProfilePictureDto } from './update-profile-picture.dto';
export { UpdateUserDto } from './update-user.dto';
export { UpdateUserDataDto } from './update-user-data.dto';
export { UpdateUserPasswordDto } from './update-user-password.dto';
</file>

<file path="src/api/users/dto/update-profile-picture.dto.ts">
import { ApiProperty } from '@nestjs/swagger';

export class UpdateProfilePictureDto {
  @ApiProperty({
    description: 'Profile picture of the user (file upload)',
    type: 'string',
    format: 'binary',
    required: true,
  })
  profilePicture: string;
}
</file>

<file path="src/api/users/dto/update-user-data.dto.ts">
import { PartialType, OmitType, IntersectionType } from '@nestjs/swagger';
import { CreateUserDto } from './create-user.dto';
import { CompleteOnboardingDto } from './complete-onboarding.dto';

export class UpdateUserDataDto extends IntersectionType(
  PartialType(OmitType(CreateUserDto, ['role'] as const)),
  PartialType(
    OmitType(CompleteOnboardingDto, [
      'userId',
      'first_name',
      'last_name',
      'idPhoto_back',
      'idPhoto_front',
      'profile_picture',
    ] as const),
  ),
) {}
</file>

<file path="src/api/users/dto/update-user-password.dto.ts">
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString, MinLength } from 'class-validator';
import { CheckPasswordConfirm } from 'src/common/decorators/check-password-confirm.decorator';

export class UpdateUserPasswordDto {
  @ApiProperty({
    description: 'users old or current password',
  })
  @IsNotEmpty()
  @IsString()
  @MinLength(8, { message: 'Password should at least be 8 characters' })
  oldPassword: string;

  @ApiProperty({
    description: 'users new password',
  })
  @IsNotEmpty()
  @IsString()
  @MinLength(8, { message: 'Password should at least be 8 characters' })
  password: string;

  @ApiProperty({
    description: 'confirm your password',
  })
  @IsNotEmpty()
  @IsString()
  @MinLength(8, { message: 'Password should at least be 8 characters' })
  passwordConfirm: string;

  @CheckPasswordConfirm({
    message: 'password and password confirm should be the same',
  })
  checkPasswordConfirm: string;
}
</file>

<file path="src/api/users/dto/update-user.dto.ts">
import { PartialType } from '@nestjs/swagger';
import { CreateUserDto } from './create-user.dto';

export class UpdateUserDto extends PartialType(CreateUserDto) {}
</file>

<file path="src/api/users/dto/verify-user.dto.ts">
import { ApiProperty } from '@nestjs/swagger';
import { UserAccountVerifyStatus } from '@prisma/client';
import { IsEnum, IsNotEmpty, IsUUID } from 'class-validator';

export class VerifyUserDto {
  @ApiProperty({
    description: 'user id to verify.',
  })
  @IsUUID()
  @IsNotEmpty()
  userId: string;

  @ApiProperty({
    description: 'verify status',
    enum: UserAccountVerifyStatus,
    default: UserAccountVerifyStatus.VERIFIED,
  })
  @IsEnum(UserAccountVerifyStatus)
  @IsNotEmpty()
  verify_status: UserAccountVerifyStatus;
}
</file>

<file path="src/api/users/providers/account/complete-onboarding.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CompleteOnboardingDto } from '../../dto/complete-onboarding.dto';
import { User } from '@prisma/client';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class CompleteOnboardingProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async completeOnboarding(
    completeOnboardingDto: CompleteOnboardingDto,
  ) {
    const {
      first_name,
      last_name,
      date_of_birth,
      gender,
      idPhoto_back,
      idPhoto_front,
      userId,
      profile_picture,
    } = completeOnboardingDto;

    let user: User;
    try {
      user = await this.prisma.user.update({
        where: { id: userId },
        data: {
          first_name,
          last_name,
          date_of_birth,
          gender,
          idPhoto_front,
          idPhoto_back,
          profile_picture,
          is_onboarding: false,
        },
      });
    } catch (err) {
      console.log('complete Onboarding Error: ', err);
      throw new InternalServerErrorException(
        'Unable to complete the onboarding process.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'complete onboarding process successfull.',
      data: user,
    });
  }
}
</file>

<file path="src/api/users/providers/account/find-all-verification-requests.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { UserAccountVerifyStatus } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class FindAllVerificationRequestsProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findAllVerificationRequests() {
    try {
      const user = await this.prisma.user.findMany({
        where: {
          verify_status: UserAccountVerifyStatus.REQUESTED,
        },
      });

      return CreateApiResponse({
        status: 'success',
        message: 'find all verification requests succfull.',
        data: user,
      });
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'Unable to find all verification requests. please try again later.',
      );
    }
  }
}
</file>

<file path="src/api/users/providers/account/request-account-verification.provider.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
} from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { FindOneUserProvider } from '../find-one-user.provider';
import { UserAccountVerifyStatus } from '@prisma/client';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class RequestAccountVerificationProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly findOneUserProvider: FindOneUserProvider,
  ) {}

  async requestAccountVerification(userId: string) {
    // check if users finishes his onboarding process.
    const user = await this.findOneUserProvider.findOneUser({
      id: userId,
      is_onboarding: false,
    });

    if (!user) {
      throw new BadRequestException(
        'User should complete the onboarding process first.',
      );
    }

    // check if account already verified
    if (
      user.verify_status === UserAccountVerifyStatus.REQUESTED ||
      user.verify_status === UserAccountVerifyStatus.VERIFIED
    ) {
      throw new BadRequestException(
        'User account is either verified or is beging requested.',
      );
    }

    // update verify_status to REQUESTED
    try {
      await this.prisma.user.update({
        where: { id: userId },
        data: {
          verify_status: UserAccountVerifyStatus.REQUESTED,
        },
      });
    } catch (err) {
      console.log('requestAccountVerification error: ', err);
      throw new InternalServerErrorException(
        'Unable to request account verification. please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'acount verification request successfull.',
      data: null,
    });
  }
}
</file>

<file path="src/api/users/providers/account/update-profile-picture.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { UpdateProfilePictureDto } from '../../dto';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { FindOneUserProvider } from '../find-one-user.provider';
import { FileUploadService } from 'src/common/file-upload/file-upload.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class UpdateProfilePictureProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly findOneUserProvider: FindOneUserProvider,
    private readonly fileUploadService: FileUploadService,
  ) {}
  public async updateProfilePicture(
    id: string,
    updateProfilePictureDto: UpdateProfilePictureDto,
  ) {
    // find user
    let user = await this.findOneUserProvider.findOneUser({ id });
    // check if he have profile picture
    // if their remove it from the file system
    if (user.profile_picture) {
      this.fileUploadService.removeFile(user.profile_picture);
    }
    // update users profile picture
    try {
      user = await this.prisma.user.update({
        where: { id },
        data: {
          profile_picture: updateProfilePictureDto.profilePicture,
        },
      });
    } catch (err) {
      console.log('updateProfilePicture: ', err);
      throw new InternalServerErrorException(
        'Unable to update user profile picture. please try again later.',
      );
    }
    // send response;
    return CreateApiResponse({
      status: 'success',
      message: 'user profile picture updated successfully.',
      data: user,
    });
  }
}
</file>

<file path="src/api/users/providers/account/update-user-data.provider.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { UpdateUserDataDto } from '../../dto';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { FindOneUserProvider } from '../find-one-user.provider';
import { User } from '@prisma/client';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class UpdateUserDataProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly findOneUserProvider: FindOneUserProvider,
  ) {}

  public async updateUserData(
    id: string,
    updateUserDataDto: UpdateUserDataDto,
  ) {
    // check if user still exists
    let user: User | undefined;
    const { email, firstName, lastName, phoneNumber, date_of_birth, gender } =
      updateUserDataDto;

    try {
      user = await this.prisma.user.findUnique({
        where: { id },
      });
    } catch (err) {
      console.log('unable to fetch a user: ', err);
      throw new InternalServerErrorException(
        'unable to fetch a user. please try again later.',
      );
    }

    if (!user) {
      throw new NotFoundException('User not found to update.');
    }

    // check if email is provided and is different from the current email
    if (email && email !== user.email) {
      const existingUser = await this.findOneUserProvider.findOneUser({
        email,
      });

      if (existingUser) {
        throw new BadRequestException(
          'User already exists with this email, Please use another email',
        );
      }
    }
    // check if phone number is provided and is different from the current phone number
    if (phoneNumber && phoneNumber !== user.phone_number) {
      const existingUser = await this.findOneUserProvider.findOneUser({
        phone_number: phoneNumber,
      });

      if (existingUser) {
        throw new BadRequestException(
          'User already exists with this phone number, Please use another phone number',
        );
      }
    }

    // updated user body
    const updatedBody: Partial<User> = {};
    updatedBody.first_name = firstName ?? user.first_name;
    updatedBody.last_name = lastName ?? user.last_name;
    updatedBody.email = email ?? user.email;
    updatedBody.phone_number = phoneNumber ?? user.phone_number;
    updatedBody.date_of_birth = date_of_birth
      ? new Date(date_of_birth)
      : user.date_of_birth;
    updatedBody.gender = gender ?? user.gender;

    try {
      user = await this.prisma.user.update({
        where: { id },
        data: updatedBody,
      });
    } catch (err) {
      console.log('unable to update user: ', err);
      throw new InternalServerErrorException(
        'Unable to update user. please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'update user successfull',
      data: user,
    });
  }
}
</file>

<file path="src/api/users/providers/account/update-user-password.provider.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { FindOneUserProvider } from '../find-one-user.provider';
import { UpdateUserPasswordDto } from '../../dto';
import { HashingProvider } from 'src/api/auth/providers/hash-password/hashing.provider';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class UpdateUserPasswordProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly findOneUserProvider: FindOneUserProvider,
    private readonly hashingProvider: HashingProvider,
  ) {}

  public async updateUserPassword(
    id: string,
    updateUserPasswordDto: UpdateUserPasswordDto,
  ) {
    const { password, oldPassword } = updateUserPasswordDto;
    // check if the user still exists
    let user = await this.findOneUserProvider.findOneUser({ id });

    if (!user) {
      throw new NotFoundException('User not found to update.');
    }

    // compare if the old password is correct password
    const isCorrect = await this.hashingProvider.comparePassword(
      oldPassword,
      user.password,
    );

    if (!isCorrect) {
      throw new BadRequestException(
        'Incorrect password. please make sure you put correct password. if you dont remember you can reset your password.',
      );
    }

    // update password
    try {
      user = await this.prisma.user.update({
        where: { id },
        data: {
          password: await this.hashingProvider.hashPassword(password),
        },
      });
    } catch (err) {
      console.log('Unable to update password please try again later: ', err);
      throw new InternalServerErrorException(
        'Unable to update password please try again later',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'password update successfully',
      data: user,
    });
  }
}
</file>

<file path="src/api/users/providers/account/verify-user.provider.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { FindOneUserProvider } from '../find-one-user.provider';
import { VerifyUserDto } from '../../dto';
import { UserAccountVerifyStatus } from '@prisma/client';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class VerifyUserProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly findOneUserProvider: FindOneUserProvider,
  ) {}

  public async verifyUser(verifyUserDto: VerifyUserDto) {
    const { userId, verify_status } = verifyUserDto;

    let user = await this.findOneUserProvider.findOneUser({ id: userId });

    if (!user) {
      throw new NotFoundException('User not found.');
    }

    if (user.is_onboarding) {
      throw new BadRequestException(
        'User not completed filling user information.',
      );
    }

    if (user.verify_status !== UserAccountVerifyStatus.REQUESTED) {
      throw new BadRequestException(
        'user has not requested to verify his account.',
      );
    }

    try {
      user = await this.prisma.user.update({
        where: { id: userId },
        data: {
          verify_status,
        },
      });
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'Unable to update user account verify status. please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: `user account verify status changed to ${verify_status} successfully.`,
      data: user,
    });
  }
}
</file>

<file path="src/api/users/providers/crud/create-user.provider.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { User } from '@prisma/client';
import { HashingProvider } from 'src/api/auth/providers/hash-password/hashing.provider';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { CreateUserDto } from '../../dto';

@Injectable()
export class CreateUserProvider {
  constructor(
    private readonly configService: ConfigService,
    private readonly hashingProvider: HashingProvider,
    private readonly prisma: PrismaService,
  ) {}

  public async createUser(createUserDto: CreateUserDto) {
    // admin creates a user with default system password.
    let user: User | undefined;

    try {
      user = await this.prisma.user.findFirst({
        where: {
          OR: [
            { email: createUserDto.email },
            { phone_number: createUserDto.phoneNumber },
          ],
        },
      });
    } catch (err) {
      console.log('error fetching user: ', err);
      throw new InternalServerErrorException(
        'Unable to fetch user. please try again later',
      );
    }

    if (user) {
      throw new BadRequestException(
        'User with this email or phone number already exists.',
      );
    }

    try {
      user = await this.prisma.user.create({
        data: {
          email: createUserDto.email,
          password: await this.hashingProvider.hashPassword(
            this.configService.get<string>('appConfig.defaultSysPassword'),
          ),
          phone_number: createUserDto.phoneNumber,
          first_name: createUserDto.firstName,
          last_name: createUserDto.lastName,
          role: createUserDto.role,
          need_reset_password: true,
        },
      });
    } catch (err) {
      console.log('error when saving user data: ', err);
      throw new InternalServerErrorException(
        'Unable to create a signup a user. please try again later',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'sign up success full',
      data: user,
    });
  }
}
</file>

<file path="src/api/users/providers/crud/delete-user-by-id.provider.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
} from '@nestjs/common';
import { FileUploadService } from 'src/common/file-upload/file-upload.service';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { FindOneUserProvider } from '../find-one-user.provider';

@Injectable()
export class DeleteUserByIdProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly fileUploadService: FileUploadService,
    private readonly findOneUserProvider: FindOneUserProvider,
  ) {}
  async deleteUserById(id: string) {
    const user = await this.findOneUserProvider.findOneUser({ id });

    if (!user) {
      throw new BadRequestException('User not found.');
    }

    try {
      await this.prisma.user.delete({ where: { id } });
      // remove file related to user from the server.
      this.fileUploadService.removeFile(user.profile_picture);
    } catch (err) {
      console.log('Error delete user: ', err);
      throw new InternalServerErrorException(
        'Unable to delete user. please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'Delete user by id successfull.',
      data: null,
    });
  }
}
</file>

<file path="src/api/users/providers/crud/find-all-users.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';

@Injectable()
export class FindAllUsersProvider {
  constructor(private readonly prisma: PrismaService) {}

  async findAllUsers() {
    try {
      const users = await this.prisma.user.findMany();
      return users;
    } catch (err) {
      console.log('Error find all users: ', err);
      throw new InternalServerErrorException(
        'Unable to find all user. please try again later.',
      );
    }
  }
}
</file>

<file path="src/api/users/providers/crud/find-user-by-id.provider.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { User } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class FindUserByIdProvider {
  constructor(private readonly prisma: PrismaService) {}

  async findUserById(id: string) {
    let user: User | undefined;

    try {
      user = await this.prisma.user.findUnique({
        where: { id },
        include: {
          Review: true,
          address: true,
          cart: true,
          orders: true,
          vendor: true,
        },
      });
    } catch (err) {
      console.log('find user by id', err);
      throw new InternalServerErrorException(
        'Unable to fetch a user at the moment. please try again later',
      );
    }

    if (!user) {
      throw new NotFoundException('User not found.');
    }

    return CreateApiResponse({
      status: 'success',
      message: 'fetch user by id successfull',
      data: user,
    });
  }
}
</file>

<file path="src/api/users/providers/crud/update-user-by-id.provider.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { User } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { UpdateUserDto } from '../../dto';
import { FindOneUserProvider } from '../find-one-user.provider';

@Injectable()
export class UpdateUserByIdProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly findOneUserProvider: FindOneUserProvider,
  ) {}

  async updateUserById(id: string, updateUserDto: UpdateUserDto) {
    // check if user still exists
    let user: User | undefined;
    try {
      user = await this.prisma.user.findUnique({
        where: { id },
      });
    } catch (err) {
      console.log('unable to fetch a user: ', err);
      throw new InternalServerErrorException(
        'unable to fetch a user. please try again later.',
      );
    }

    if (!user) {
      throw new NotFoundException('User not found to update.');
    }

    // check if email is provided and is different from the current email
    if (updateUserDto.email && updateUserDto.email !== user.email) {
      const existingUser = await this.findOneUserProvider.findOneUser({
        email: updateUserDto.email,
      });

      if (existingUser) {
        throw new BadRequestException(
          'User already exists with this email, Please use another email',
        );
      }
    }
    // check if phone number is provided and is different from the current phone number
    if (
      updateUserDto.phoneNumber &&
      updateUserDto.phoneNumber !== user.phone_number
    ) {
      const existingUser = await this.findOneUserProvider.findOneUser({
        phone_number: updateUserDto.phoneNumber,
      });

      if (existingUser) {
        throw new BadRequestException(
          'User already exists with this phone number, Please use another phone number',
        );
      }
    }

    // updated user body
    const updatedBody: Partial<User> = {};
    updatedBody.first_name = updateUserDto.firstName ?? user.first_name;
    updatedBody.last_name = updateUserDto.lastName ?? user.last_name;
    updatedBody.email = updateUserDto.email ?? user.email;
    updatedBody.phone_number = updateUserDto.phoneNumber ?? user.phone_number;
    updatedBody.role = updateUserDto.role ?? user.role;

    try {
      user = await this.prisma.user.update({
        where: { id },
        data: updatedBody,
      });
    } catch (err) {
      console.log('unable to update user: ', err);
      throw new InternalServerErrorException(
        'Unable to update user. please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'update user successfull',
      data: user,
    });
  }
}
</file>

<file path="src/api/users/providers/find-one-user.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { User } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';

@Injectable()
export class FindOneUserProvider {
  constructor(private readonly prisma: PrismaService) {}

  async findOneUser(options: Partial<User>) {
    try {
      return await this.prisma.user.findFirst({ where: options });
    } catch (err) {
      console.log('find one user provider: ', err);
      throw new InternalServerErrorException(
        'Unable to fetch a user. please try again later.',
      );
    }
  }
}
</file>

<file path="src/api/users/users.controller.ts">
import {
  BadRequestException,
  Body,
  Controller,
  Delete,
  Get,
  HttpCode,
  HttpStatus,
  Param,
  ParseUUIDPipe,
  Patch,
  Post,
  UploadedFile,
  UploadedFiles,
  UseInterceptors,
} from '@nestjs/common';
import {
  ApiBearerAuth,
  ApiBody,
  ApiConsumes,
  ApiOperation,
  ApiParam,
} from '@nestjs/swagger';
import { UserRole } from '@prisma/client';
import { ActiveUser, Auth, Role } from '../auth/decorators';
import { AuthType } from '../auth/enums/auth-type.enum';
import { UsersService } from './users.service';
import {
  CreateUserDto,
  UpdateProfilePictureDto,
  UpdateUserDataDto,
  UpdateUserDto,
  UpdateUserPasswordDto,
  VerifyUserDto,
} from './dto';
import {
  FileFieldsInterceptor,
  FileInterceptor,
} from '@nestjs/platform-express';
import { FileUploadService } from 'src/common/file-upload/file-upload.service';
import { FileUploadDirNames } from 'src/lib/constants/file-upload-dir-names';
import { CompleteOnboardingDto } from './dto/complete-onboarding.dto';

@Controller('users')
export class UsersController {
  constructor(
    private readonly usersService: UsersService,
    private readonly fileUploadService: FileUploadService,
  ) {}
  // find current user
  @ApiOperation({
    summary: 'Get current user',
    description: 'users can use this route to get their profile.',
  })
  @ApiBearerAuth()
  @Get('account/current-user')
  findCurrentUser(@ActiveUser('sub') id: string) {
    return this.usersService.findUserById(id);
  }

  @ApiOperation({
    summary: "update currently logged's data.",
    description: "update currently logged's data.",
  })
  @ApiBody({
    type: UpdateUserDataDto,
    required: true,
  })
  @ApiBearerAuth()
  @Patch('account/update-my-data')
  updateUserData(
    @ActiveUser('sub') id: string,
    @Body() updateUserDataDto: UpdateUserDataDto,
  ) {
    return this.usersService.updateUserData(id, updateUserDataDto);
  }

  @ApiOperation({
    summary: 'Update user profile-picture',
    description: 'users can use this route to update their profile picture.',
  })
  @ApiBody({
    required: true,
    type: UpdateProfilePictureDto,
  })
  @ApiConsumes('multipart/form-data')
  @ApiBearerAuth()
  @UseInterceptors(
    FileInterceptor(
      'profilePicture',
      FileUploadService.saveImageToStorage({
        dirName: FileUploadDirNames.user,
      }),
    ),
  )
  @Patch('account/profile-picture')
  updateMyProfilePicture(
    @UploadedFile() profilePicture: Express.Multer.File,
    @ActiveUser('sub') id: string,
  ) {
    if (!profilePicture) {
      throw new BadRequestException('Profile picture is required');
    }
    const updateProfilePictureDto: UpdateProfilePictureDto = {
      profilePicture: this.fileUploadService.getFilePath(profilePicture),
    };
    return this.usersService.updateProfilePicture(id, updateProfilePictureDto);
  }

  @ApiOperation({
    summary: 'Update user password',
    description: 'Update user password',
  })
  @ApiBody({
    type: UpdateUserPasswordDto,
    required: true,
  })
  @ApiBearerAuth()
  @Patch('account/password')
  updateUserPassword(
    @ActiveUser('sub') id: string,
    @Body() updateUserPasswordDto: UpdateUserPasswordDto,
  ) {
    return this.usersService.updateUserPassword(id, updateUserPasswordDto);
  }

  @ApiOperation({
    summary:
      'Complete users onboarding process / complete user profile information',
    description:
      'Complete users onboarding process / complete user profile information',
  })
  @ApiBody({
    type: CompleteOnboardingDto,
    required: true,
  })
  @ApiBearerAuth()
  @ApiConsumes('multipart/form-data')
  @UseInterceptors(
    FileFieldsInterceptor(
      [
        { name: 'idPhoto_front', maxCount: 1 },
        { name: 'idPhoto_back', maxCount: 1 },
        { name: 'profile_picture', maxCount: 1 },
      ],
      FileUploadService.saveImageToStorage({
        dirName: FileUploadDirNames.user,
      }),
    ),
  )
  @Patch('account/complete-onboarding')
  completeOnboarding(
    @Body() completeOnboardingDto: CompleteOnboardingDto,
    @ActiveUser('sub') userId: string,
    @UploadedFiles()
    files: {
      idPhoto_front: Express.Multer.File;
      idPhoto_back: Express.Multer.File;
      profile_picture: Express.Multer.File;
    },
  ) {
    if (
      !files.idPhoto_back[0] ||
      !files.idPhoto_front ||
      !files.profile_picture
    ) {
      throw new BadRequestException(
        'please provide all required fields. identification card photo and profile picture are required.',
      );
    }
    completeOnboardingDto.userId = userId;
    completeOnboardingDto.idPhoto_front = this.fileUploadService.getFilePath(
      files.idPhoto_front[0],
    );
    completeOnboardingDto.idPhoto_back = this.fileUploadService.getFilePath(
      files.idPhoto_back[0],
    );
    completeOnboardingDto.profile_picture = this.fileUploadService.getFilePath(
      files.profile_picture[0],
    );
    return this.usersService.completeOnboarding(completeOnboardingDto);
  }

  @ApiOperation({
    summary: 'request account verification for users',
    description: 'request account verification for users',
  })
  @ApiBearerAuth()
  @Role(UserRole.CUSTOMER)
  @Patch('account/request-account-verification')
  requestAccountVerification(@ActiveUser('sub') userId: string) {
    return this.usersService.requestAccountVerification(userId);
  }

  @ApiOperation({
    summary: 'find all verification requests.',
    description: 'find all verification requests.',
  })
  @ApiBearerAuth()
  @Role(UserRole.ADMIN)
  @Get('account/verification-requests')
  findAllVerificationRequests() {
    return this.usersService.findAllVerificationRequests();
  }

  @ApiOperation({
    summary: 'verify user account.',
    description:
      'admins can use this endpoint to verify/declince user verification requests',
  })
  @ApiBody({
    type: VerifyUserDto,
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.ADMIN)
  @Post('account/verify-user')
  verifyUser(@Body() verifyUserDto: VerifyUserDto) {
    return this.usersService.verifyUser(verifyUserDto);
  }

  @ApiOperation({
    summary: 'Create a User',
    description:
      'Create a User, user this route to create a new user. Admins only',
  })
  @ApiBody({
    required: true,
    type: CreateUserDto,
  })
  @ApiBearerAuth()
  @Auth(AuthType.BEARER)
  @Role(UserRole.ADMIN)
  @Post()
  createUser(@Body() createUserDto: CreateUserDto) {
    return this.usersService.createUser(createUserDto);
  }

  @ApiOperation({
    summary: 'Find All Users',
    description: 'Find All Users, use this route to get all users. Admins only',
  })
  @Get()
  @ApiBearerAuth()
  @Auth(AuthType.BEARER)
  @Role(UserRole.ADMIN)
  findAllUsers() {
    return this.usersService.findAllUsers();
  }

  @ApiOperation({
    summary: 'Find User By ID',
    description:
      'Find User By ID, use this route to get user by id. Admins only',
  })
  @ApiParam({
    name: 'id',
    description: 'id of the user',
    required: true,
  })
  @ApiBearerAuth()
  @Auth(AuthType.BEARER)
  @Role(UserRole.ADMIN)
  @Get(':id')
  findUserById(@Param('id', ParseUUIDPipe) id: string) {
    return this.usersService.findUserById(id);
  }

  @ApiOperation({
    summary: 'Update User By ID',
    description:
      'Update User By ID, use this route to update user by id. Admins only',
  })
  @ApiParam({
    name: 'id',
    description: 'id of the user',
    required: true,
  })
  @ApiBody({
    required: true,
    type: UpdateUserDto,
  })
  @ApiBearerAuth()
  @Auth(AuthType.BEARER)
  @Role(UserRole.ADMIN)
  @Patch(':id')
  updateUserById(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() updateUserDto: UpdateUserDto,
  ) {
    return this.usersService.updateUserById(id, updateUserDto);
  }

  @ApiOperation({
    summary: 'Delete User By ID',
    description:
      'Delete User By ID, use this route to delete user by id. Admins only',
  })
  @ApiParam({
    name: 'id',
    description: 'id of the user',
    required: true,
  })
  @ApiBearerAuth()
  @Auth(AuthType.BEARER)
  @Role(UserRole.ADMIN)
  @HttpCode(HttpStatus.NO_CONTENT)
  @Delete(':id')
  deleteUserById(@Param('id', ParseUUIDPipe) id: string) {
    return this.usersService.deleteUserById(id);
  }
}
</file>

<file path="src/api/users/users.module.ts">
import { Module } from '@nestjs/common';
import { FileUploadModule } from 'src/common/file-upload/file-upload.module';
import { PrismaModule } from 'src/common/prisma/prisma.module';
import { AuthModule } from '../auth/auth.module';
import { CompleteOnboardingProvider } from './providers/account/complete-onboarding.provider';
import { FindAllVerificationRequestsProvider } from './providers/account/find-all-verification-requests.provider';
import { RequestAccountVerificationProvider } from './providers/account/request-account-verification.provider';
import { UpdateProfilePictureProvider } from './providers/account/update-profile-picture.provider';
import { UpdateUserDataProvider } from './providers/account/update-user-data.provider';
import { UpdateUserPasswordProvider } from './providers/account/update-user-password.provider';
import { CreateUserProvider } from './providers/crud/create-user.provider';
import { DeleteUserByIdProvider } from './providers/crud/delete-user-by-id.provider';
import { FindAllUsersProvider } from './providers/crud/find-all-users.provider';
import { FindUserByIdProvider } from './providers/crud/find-user-by-id.provider';
import { UpdateUserByIdProvider } from './providers/crud/update-user-by-id.provider';
import { FindOneUserProvider } from './providers/find-one-user.provider';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';
import { VerifyUserProvider } from './providers/account/verify-user.provider';

@Module({
  controllers: [UsersController],
  providers: [
    UsersService,
    FindOneUserProvider,
    FindUserByIdProvider,
    UpdateUserByIdProvider,
    DeleteUserByIdProvider,
    FindAllUsersProvider,
    CreateUserProvider,
    UpdateUserDataProvider,
    UpdateUserPasswordProvider,
    UpdateProfilePictureProvider,
    CompleteOnboardingProvider,
    RequestAccountVerificationProvider,
    FindAllVerificationRequestsProvider,
    VerifyUserProvider,
  ],
  imports: [PrismaModule, AuthModule, FileUploadModule],
  exports: [UsersService],
})
export class UsersModule {}
</file>

<file path="src/api/users/users.service.ts">
import { Injectable } from '@nestjs/common';
import { DeleteUserByIdProvider } from './providers/crud/delete-user-by-id.provider';
import { FindUserByIdProvider } from './providers/crud/find-user-by-id.provider';
import { FindOneUserProvider } from './providers/find-one-user.provider';
import { FindAllUsersProvider } from './providers/crud/find-all-users.provider';
import { UpdateUserByIdProvider } from './providers/crud/update-user-by-id.provider';
import { CreateUserProvider } from './providers/crud/create-user.provider';
import { User } from '@prisma/client';
import {
  CreateUserDto,
  UpdateProfilePictureDto,
  UpdateUserDataDto,
  UpdateUserDto,
  UpdateUserPasswordDto,
  VerifyUserDto,
} from './dto';
import { UpdateProfilePictureProvider } from './providers/account/update-profile-picture.provider';
import { CompleteOnboardingProvider } from './providers/account/complete-onboarding.provider';
import { CompleteOnboardingDto } from './dto/complete-onboarding.dto';
import { RequestAccountVerificationProvider } from './providers/account/request-account-verification.provider';
import { UpdateUserPasswordProvider } from './providers/account/update-user-password.provider';
import { VerifyUserProvider } from './providers/account/verify-user.provider';
import { FindAllVerificationRequestsProvider } from './providers/account/find-all-verification-requests.provider';
import { UpdateUserDataProvider } from './providers/account/update-user-data.provider';

@Injectable()
export class UsersService {
  constructor(
    private readonly createUserProvider: CreateUserProvider,
    private readonly updateUserByIdProvider: UpdateUserByIdProvider,
    private readonly findAllUsersProvider: FindAllUsersProvider,
    private readonly findOneUserProvider: FindOneUserProvider,
    private readonly findUserByIdProvider: FindUserByIdProvider,
    private readonly deleteUserByIdProvider: DeleteUserByIdProvider,
    private readonly requestAccountVerificationProvider: RequestAccountVerificationProvider,
    private readonly updateProfilePictureProvider: UpdateProfilePictureProvider,
    private readonly completeOnboardingProvider: CompleteOnboardingProvider,
    private readonly updateUserPasswordProvider: UpdateUserPasswordProvider,
    private readonly verifyUserProvider: VerifyUserProvider,
    private readonly findAllVerificationRequestsProvider: FindAllVerificationRequestsProvider,
    private readonly updateUserDataProvider: UpdateUserDataProvider,
  ) {}

  createUser(createUserDto: CreateUserDto) {
    return this.createUserProvider.createUser(createUserDto);
  }

  findAllUsers() {
    return this.findAllUsersProvider.findAllUsers();
  }

  findUserById(id: string) {
    return this.findUserByIdProvider.findUserById(id);
  }

  updateUserById(id: string, updateUserDto: UpdateUserDto) {
    return this.updateUserByIdProvider.updateUserById(id, updateUserDto);
  }

  deleteUserById(id: string) {
    return this.deleteUserByIdProvider.deleteUserById(id);
  }

  findOneUser(options: Partial<User>) {
    return this.findOneUserProvider.findOneUser(options);
  }

  // account
  updateProfilePicture(
    id: string,
    updateProfilePictureDto: UpdateProfilePictureDto,
  ) {
    return this.updateProfilePictureProvider.updateProfilePicture(
      id,
      updateProfilePictureDto,
    );
  }

  updateUserPassword(id: string, updateUserPasswordDto: UpdateUserPasswordDto) {
    return this.updateUserPasswordProvider.updateUserPassword(
      id,
      updateUserPasswordDto,
    );
  }

  updateUserData(id: string, updateUserDataDto: UpdateUserDataDto) {
    return this.updateUserDataProvider.updateUserData(id, updateUserDataDto);
  }

  completeOnboarding(completeOnboardingDto: CompleteOnboardingDto) {
    return this.completeOnboardingProvider.completeOnboarding(
      completeOnboardingDto,
    );
  }

  requestAccountVerification(userId: string) {
    return this.requestAccountVerificationProvider.requestAccountVerification(
      userId,
    );
  }
  verifyUser(verifyUserDto: VerifyUserDto) {
    return this.verifyUserProvider.verifyUser(verifyUserDto);
  }
  findAllVerificationRequests() {
    return this.findAllVerificationRequestsProvider.findAllVerificationRequests();
  }
}
</file>

<file path="src/api/vendors/vender_transaction/vender_transaction.controller.ts">
import { Controller } from '@nestjs/common';

@Controller('vender/transaction')
export class VenderTransactionController {}
</file>

<file path="src/api/vendors/vender_transaction/vender_transaction.module.ts">
import { Module } from '@nestjs/common';
import { VenderTransactionController } from './vender_transaction.controller';
import { VenderTransactionService } from './vender_transaction.service';
import { PrismaModule } from 'src/common/prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [VenderTransactionController],
  providers: [VenderTransactionService],
})
export class VenderTransactionModule {}
</file>

<file path="src/api/vendors/vender_transaction/vender_transaction.service.ts">
import { Injectable } from '@nestjs/common';

@Injectable()
export class VenderTransactionService {}
</file>

<file path="src/api/vendors/vendor_balance/vendor_balance.controller.ts">
import {
  BadRequestException,
  Controller,
  Get,
  NotFoundException,
  Query,
} from '@nestjs/common';
import { ApiBearerAuth, ApiOperation, ApiQuery } from '@nestjs/swagger';
import { UserRole, Vendor } from '@prisma/client';
import { ActiveUser, Role } from 'src/api/auth/decorators';
import { IActiveUserData } from 'src/api/auth/interfaces/active-user-data.interface';
import { VendorsService } from '../vendors/vendors.service';
import { VendorBalanceService } from './vendor_balance.service';

@Controller('vendor/balance')
export class VendorBalanceController {
  constructor(
    private readonly vendorBalanceService: VendorBalanceService,
    private readonly vendorsService: VendorsService,
  ) {}

  @ApiOperation({
    summary: 'Get Vendor Balance.',
    description: 'Get Vendor Balance.',
  })
  @ApiQuery({
    name: 'userId',
    description:
      'admins can get the Get Vendor Balance. of vendors. userId is the id of ther user who owns the vendor.',
    required: false,
  })
  @ApiBearerAuth()
  @Role(UserRole.VENDOR, UserRole.ADMIN)
  @Get()
  async getVendorBalance(
    @Query('userId') userId: string,
    @ActiveUser() activeUserData: IActiveUserData,
  ) {
    const { role, sub } = activeUserData;
    let vendorId: string;
    let vendor: Vendor;
    if (role === UserRole.VENDOR) {
      vendor = await this.vendorsService.findOneVendor({
        userId: sub,
      });
      if (!vendor) throw new NotFoundException('vendor not found.');
      vendorId = vendor.id;
    } else {
      if (!userId) throw new BadRequestException('user id is required.');

      vendor = await this.vendorsService.findOneVendor({
        userId,
      });
      if (!vendor) throw new NotFoundException('vendor not found.');
      vendorId = vendor.id;
    }
    return this.vendorBalanceService.getVendorBalance(vendorId);
  }
}
</file>

<file path="src/api/vendors/vendor_balance/vendor_balance.module.ts">
import { forwardRef, Module } from '@nestjs/common';
import { VendorBalanceController } from './vendor_balance.controller';
import { VendorBalanceService } from './vendor_balance.service';
import { PrismaModule } from 'src/common/prisma/prisma.module';
import { VendorsModule } from '../vendors/vendors.module';

@Module({
  imports: [PrismaModule, forwardRef(() => VendorsModule)],
  controllers: [VendorBalanceController],
  providers: [VendorBalanceService],
  exports: [VendorBalanceService],
})
export class VendorBalanceModule {}
</file>

<file path="src/api/vendors/vendor_balance/vendor_balance.service.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class VendorBalanceService {
  constructor(private readonly prisma: PrismaService) {}

  // Get vendor balance
  async getVendorBalance(vendorId: string) {
    try {
      const balance = await this.prisma.vendorBalance.findUnique({
        where: { vendorId },
        include: {
          withdrawal_requests: {
            where: { status: 'PENDING' },
            take: 5,
            orderBy: { createdAt: 'desc' },
          },
          transactions: {
            take: 10,
            orderBy: { createdAt: 'desc' },
          },
        },
      });

      if (!balance) {
        throw new NotFoundException('Vendor balance not found');
      }

      return CreateApiResponse({
        status: 'success',
        message: 'getVendorBalance successfull',
        data: balance,
      });
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'Unable to find vendor balance. please try again later.',
      );
    }
  }

  // Initialize vendor balance (called when vendor is created)
  async initializeVendorBalance(vendorId: string, tx?: any) {
    try {
      // Use the passed transaction or fallback to this.prisma
      const prisma = tx || this.prisma;

      const balance = await prisma.vendorBalance.create({
        data: {
          vendor: { connect: { id: vendorId } },
        },
      });

      return CreateApiResponse({
        status: 'success',
        message: 'Initialize vendor balance successfull.',
        data: balance,
      });
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'Unable to  Initialize vendor balance. please try again later.',
      );
    }
  }

  // Update balance after order completion
  async updateBalanceAfterOrder(vendorId: string, amount: number) {
    try {
      const updatedBalance = await this.prisma.$transaction(async (tx) => {
        // Update balance
        const updatedBalance = await tx.vendorBalance.update({
          where: { vendorId },
          data: {
            total_earnings: { increment: amount },
            available_balance: { increment: amount },
          },
        });

        // Create transaction record
        await tx.vendorTransaction.create({
          data: {
            amount,
            type: 'ORDER_PAYMENT',
            status: 'COMPLETED',
            vendor_balance: { connect: { id: updatedBalance.id } },
          },
        });

        return updatedBalance;
      });

      return CreateApiResponse({
        status: 'success',
        message: 'balance updated successfully.',
        data: updatedBalance,
      });
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'Unable to update balance. please try again later.',
      );
    }
  }
}
</file>

<file path="src/api/vendors/vendor_bank_account/dtos/create-back-account.dto.ts">
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString } from 'class-validator';

export class CreateBankAccountDto {
  @ApiProperty({
    description: 'bank account holder name',
  })
  @IsString()
  @IsNotEmpty()
  account_name: string;

  @ApiProperty({
    description: 'bank account number',
  })
  @IsString()
  @IsNotEmpty()
  account_number: string;

  @ApiProperty({
    description: 'bank name',
  })
  @IsString()
  @IsNotEmpty()
  bank_name: string;

  vendorId: string;
}
</file>

<file path="src/api/vendors/vendor_bank_account/dtos/update-bank-account.dto.ts">
import { PartialType } from '@nestjs/swagger';
import { CreateBankAccountDto } from './create-back-account.dto';

export class UpdateBankAccountDto extends PartialType(CreateBankAccountDto) {}
</file>

<file path="src/api/vendors/vendor_bank_account/vendor_bank_account.controller.ts">
import { Body, Controller, Patch, Post } from '@nestjs/common';
import { VendorBankAccountService } from './vendor_bank_account.service';
import { CreateBankAccountDto } from './dtos/create-back-account.dto';
import { ActiveUser, Role } from 'src/api/auth/decorators';
import { UpdateBankAccountDto } from './dtos/update-bank-account.dto';
import { ApiBearerAuth, ApiBody, ApiOperation } from '@nestjs/swagger';
import { UserRole } from '@prisma/client';

@Controller('vendor/bank-account')
export class VendorBankAccountController {
  constructor(
    private readonly vendorBankAccountService: VendorBankAccountService,
  ) {}

  @ApiOperation({
    summary: 'create bank account',
    description: 'vendors can use this endpoint to create bank account.',
  })
  @ApiBody({
    type: CreateBankAccountDto,
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.VENDOR)
  @Post()
  createBankAccount(
    @Body() createBankAccountDto: CreateBankAccountDto,
    @ActiveUser('sub') id: string,
  ) {
    createBankAccountDto.vendorId = id;
    return this.vendorBankAccountService.createBankAccount(
      createBankAccountDto,
    );
  }

  @ApiOperation({
    summary: 'update bank account',
    description: 'vendors can use this endpoint to update bank account.',
  })
  @ApiBody({
    type: UpdateBankAccountDto,
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.VENDOR)
  @Patch()
  updateBankAccount(
    @ActiveUser('sub') id: string,
    @Body() updateBankAccountDto: UpdateBankAccountDto,
  ) {
    updateBankAccountDto.vendorId = id;
    return this.vendorBankAccountService.updateBankAccount(
      id,
      updateBankAccountDto,
    );
  }
}
</file>

<file path="src/api/vendors/vendor_bank_account/vendor_bank_account.module.ts">
import { Module } from '@nestjs/common';
import { VendorBankAccountController } from './vendor_bank_account.controller';
import { VendorBankAccountService } from './vendor_bank_account.service';
import { PrismaModule } from 'src/common/prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [VendorBankAccountController],
  providers: [VendorBankAccountService],
})
export class VendorBankAccountModule {}
</file>

<file path="src/api/vendors/vendor_bank_account/vendor_bank_account.service.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateBankAccountDto } from './dtos/create-back-account.dto';
import { VendorBankAccount } from '@prisma/client';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { UpdateBankAccountDto } from './dtos/update-bank-account.dto';

@Injectable()
export class VendorBankAccountService {
  constructor(private readonly prisma: PrismaService) {}

  public async createBankAccount(createBankAccountDto: CreateBankAccountDto) {
    const { account_name, account_number, bank_name, vendorId } =
      createBankAccountDto;

    if (!vendorId) {
      throw new BadRequestException('vendor id is required.');
    }

    let account: VendorBankAccount;
    try {
      account = await this.prisma.vendorBankAccount.findUnique({
        where: { vendorId },
      });
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'Unable to find vendor bacnk account. please try again later.',
      );
    }
    if (account) {
      return CreateApiResponse({
        status: 'success',
        message: 'vendor already registered a bank account number.',
        data: account,
      });
    }

    try {
      account = await this.prisma.vendorBankAccount.create({
        data: {
          account_name,
          account_number,
          bank_name,
          vendorId,
        },
      });
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'Unable to create account number. please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'vendor bank account created successfully.',
      data: account,
    });
  }

  public async updateBankAccount(
    id: string,
    updateBankAccountDto: UpdateBankAccountDto,
  ) {
    const { account_name, account_number, bank_name, vendorId } =
      updateBankAccountDto;

    if (!vendorId) {
      throw new BadRequestException('vendor id is required.');
    }

    let account: VendorBankAccount;
    try {
      account = await this.prisma.vendorBankAccount.findUnique({
        where: { id, vendorId },
      });
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'Unable to find vendor bacnk account. please try again later.',
      );
    }

    if (!account) {
      throw new NotFoundException('No bank account number is found.');
    }

    try {
      account = await this.prisma.vendorBankAccount.update({
        where: { id, vendorId },
        data: {
          account_name: account_name ?? account.account_name,
          account_number: account_number ?? account.account_number,
          bank_name: bank_name ?? account.bank_name,
        },
      });
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'Unable to update bank account. please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'bank account number updated successfully.',
      data: account,
    });
  }
}
</file>

<file path="src/api/vendors/vendors/dto/create-vendor.dto.ts">
import { ApiProperty } from '@nestjs/swagger';
import {
  IsEmail,
  IsNotEmpty,
  IsPhoneNumber,
  IsString,
  IsUUID,
} from 'class-validator';

export class CreateVendorDto {
  @ApiProperty({
    description: 'business name',
  })
  @IsNotEmpty()
  @IsString()
  business_name: string;

  @ApiProperty({
    description: 'business email',
  })
  @IsNotEmpty()
  @IsEmail()
  business_email: string;

  @ApiProperty({
    description: 'business phone number',
  })
  @IsNotEmpty()
  @IsPhoneNumber()
  @IsString()
  phone_number: string;

  @ApiProperty({
    description: 'business logo',
    required: true,
    type: 'string',
    format: 'binary',
  })
  //  for the frontend to send the file as a base64 string
  logo: string;
  // for the backend to save the file as a string
  logo_url: string;

  @ApiProperty({
    description: 'user id',
  })
  @IsNotEmpty()
  @IsUUID()
  userId: string;
}
</file>

<file path="src/api/vendors/vendors/dto/update-vendor.dto.ts">
import { PartialType } from '@nestjs/mapped-types';
import { CreateVendorDto } from './create-vendor.dto';

export class UpdateVendorDto extends PartialType(CreateVendorDto) {}
</file>

<file path="src/api/vendors/vendors/providers/create-vendor.provider.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { UserRole, Vendor } from '@prisma/client';
import { UsersService } from 'src/api/users/users.service';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { CreateVendorDto } from '../dto/create-vendor.dto';
import { FindOneVendorProvider } from './find-one-vendor.provider';
import { VendorBalanceService } from '../../vendor_balance/vendor_balance.service';

@Injectable()
export class CreateVendorProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly usersService: UsersService,
    private readonly findOneVendorProvider: FindOneVendorProvider,
    private readonly vendorBalanceService: VendorBalanceService,
  ) {}

  public async createVendor(createVendorDto: CreateVendorDto) {
    const { business_email, business_name, logo_url, phone_number, userId } =
      createVendorDto;
    // check if valid user id and if user still exists
    const user = await this.usersService.findOneUser({
      id: userId,
    });

    if (!user) {
      throw new NotFoundException(
        'user not found when creating a vendor, try again later',
      );
    }

    // check if user is already a vendor
    let vendor: Vendor | undefined;
    vendor = await this.findOneVendorProvider.findOneVendor({
      userId: userId,
    });

    if (vendor) {
      throw new BadRequestException('User already registered as a vendor. ');
    }

    // check if vendor already exists with the same email or phone number
    try {
      vendor = await this.prisma.vendor.findFirst({
        where: {
          OR: [{ business_email }, { phone_number }],
        },
      });
    } catch (err) {
      console.log('unable to find vendor by email or phone number', err);
      throw new InternalServerErrorException(
        'unable to find a vendor, please try again later.',
      );
    }

    if (vendor) {
      throw new BadRequestException(
        'vendor already exists with the same phone number or business email. ',
      );
    }

    try {
      // create vendor
      await this.prisma.$transaction(async (tx) => {
        vendor = await tx.vendor.create({
          data: {
            business_email,
            business_name,
            phone_number,
            logo_url,
            userId,
          },
        });
        // Initialize balance using the same transaction
        await this.vendorBalanceService.initializeVendorBalance(vendor.id, tx);

        // update user role to vendor
        await tx.user.update({
          where: { id: user.id },
          data: { role: UserRole.VENDOR },
        });
      });
    } catch (err) {
      console.log('unable to create a vendor. please try again later.', err);
      throw new InternalServerErrorException(
        'unable to create a vendor. please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'vendor created successfully',
      data: vendor,
    });
  }
}
</file>

<file path="src/api/vendors/vendors/providers/delete-vendor.provider.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
} from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { FindOneVendorProvider } from './find-one-vendor.provider';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { FileUploadService } from 'src/common/file-upload/file-upload.service';

@Injectable()
export class DeleteVendorProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly findOneVendorProvider: FindOneVendorProvider,
    private readonly fileUploadService: FileUploadService,
  ) {}

  public async deleteVendr(id: string) {
    // check if vendor exists before deleting
    const vendor = await this.findOneVendorProvider.findOneVendor({ id });

    if (!vendor) {
      throw new BadRequestException('vendor not found.');
    }

    // delete vendor
    try {
      await this.prisma.vendor.delete({ where: { id } });
      // clear files related to this vendor
      this.fileUploadService.removeFile(vendor.logo_url);
    } catch (err) {
      console.log('delete vendor: ', err);
      throw new InternalServerErrorException(
        'unable to delete vendor please try again later',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'vendor delete successfully.',
      data: null,
    });
  }
}
</file>

<file path="src/api/vendors/vendors/providers/find-all-vendors.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { Vendor } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class FindAllVendorsProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findAllVendors() {
    let vendors: Vendor[] | undefined;

    try {
      vendors = await this.prisma.vendor.findMany();
    } catch (err) {
      console.log('find all vendors: ', err);
      throw new InternalServerErrorException(
        'Unable to find all vendors, please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'find all vendors successfull.',
      metadata: {},
      data: vendors,
    });
  }
}
</file>

<file path="src/api/vendors/vendors/providers/find-one-vendor.provider.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { Vendor } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';

@Injectable()
export class FindOneVendorProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findOneVendor(options: Partial<Vendor>) {
    try {
      const vendor = await this.prisma.vendor.findFirst({
        where: options,
      });
      return vendor;
    } catch (err) {
      console.log('find one user by options: ', err);
      throw new InternalServerErrorException(
        'Unable to find user, Please try again later.',
      );
    }
  }
}
</file>

<file path="src/api/vendors/vendors/providers/find-vendor-by-id.provider.ts">
import {
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { Vendor } from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';

@Injectable()
export class FindVendorByIdProvider {
  constructor(private readonly prisma: PrismaService) {}

  public async findVendorById(id: string) {
    let vendor: Vendor | undefined;

    try {
      vendor = await this.prisma.vendor.findFirst({ where: { id } });
    } catch (err) {
      console.log('find vendor by id', err);
      throw new InternalServerErrorException(
        'Unable to fetch vendor from the database, please try again later.',
      );
    }
    if (!vendor) {
      throw new NotFoundException('Vendor not found.');
    }

    return CreateApiResponse({
      status: 'success',
      message: 'find vendor by id successfull.',
      data: vendor,
    });
  }
}
</file>

<file path="src/api/vendors/vendors/providers/update-vendor.provider.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { UpdateVendorDto } from '../dto/update-vendor.dto';
import { Vendor } from '@prisma/client';
import { FindOneVendorProvider } from './find-one-vendor.provider';
import { UsersService } from 'src/api/users/users.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { FileUploadService } from 'src/common/file-upload/file-upload.service';

@Injectable()
export class UpdateVendorProvider {
  constructor(
    private readonly prisma: PrismaService,
    private readonly usersService: UsersService,
    private readonly findOneVendorProvider: FindOneVendorProvider,
    private readonly fileUploadService: FileUploadService,
  ) {}

  public async updateVendor(id: string, updateVendorDto: UpdateVendorDto) {
    const { business_email, business_name, phone_number, logo_url, userId } =
      updateVendorDto;
    let vendor: Vendor | undefined;

    // check if vendor exists
    vendor = await this.findOneVendorProvider.findOneVendor({ id });

    if (!vendor) {
      throw new BadRequestException('vendor not found');
    }

    if (userId) {
      // check if valid user id and if user still exists
      const user = await this.usersService.findOneUser({
        id: userId,
      });

      if (!user) {
        throw new NotFoundException(
          'user not found when creating a vendor, try again later',
        );
      }
    }
    // fixeme
    // check if vendor already exists with the same email or phone number
    let existingVendor: Vendor;
    try {
      existingVendor = await this.prisma.vendor.findFirst({
        where: {
          id: {
            not: id,
          },
          OR: [{ business_email }, { phone_number }],
        },
      });
    } catch (err) {
      console.log('unable to find vendor by email or phone number', err);
      throw new InternalServerErrorException(
        'unable to find a vendor, please try again later.',
      );
    }
    if (existingVendor) {
      throw new BadRequestException(
        'vendor already exists with the same phone number or business email. ',
      );
    }
    // remove file if new logo uploaded then update vendor
    if (logo_url && vendor.logo_url) {
      this.fileUploadService.removeFile(vendor.logo_url);
    }

    // update vendor
    try {
      vendor = await this.prisma.vendor.update({
        where: { id },
        data: {
          business_email: business_email ?? vendor.business_email,
          business_name: business_name ?? vendor.business_name,
          phone_number: phone_number ?? vendor.phone_number,
          logo_url: logo_url ?? vendor.logo_url,
          userId: userId ?? vendor.userId,
        },
      });
    } catch (err) {
      console.log('update vendor provider', err);
      throw new InternalServerErrorException(
        'Unable to find vendor, please try again later.',
      );
    }

    return CreateApiResponse({
      status: 'success',
      message: 'update vendor successfull.',
      data: vendor,
    });
  }
}
</file>

<file path="src/api/vendors/vendors/vendors.controller.ts">
import {
  BadRequestException,
  Body,
  Controller,
  Delete,
  Get,
  HttpCode,
  HttpStatus,
  Param,
  Patch,
  Post,
  UploadedFile,
  UseInterceptors,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import {
  ApiBearerAuth,
  ApiBody,
  ApiConsumes,
  ApiOperation,
  ApiParam,
} from '@nestjs/swagger';
import { UserRole } from '@prisma/client';
import { FileUploadService } from 'src/common/file-upload/file-upload.service';
import { FileUploadDirNames } from 'src/lib/constants/file-upload-dir-names';
import { Role } from '../../auth/decorators';
import { CreateVendorDto } from './dto/create-vendor.dto';
import { UpdateVendorDto } from './dto/update-vendor.dto';
import { VendorsService } from './vendors.service';

@Controller('vendors')
export class VendorsController {
  constructor(
    private readonly vendorsService: VendorsService,
    private readonly fileUploadService: FileUploadService,
  ) {}

  @ApiOperation({
    summary: 'create a vendor',
    description: 'use this api endpoint to create a vendor.',
  })
  @ApiBody({
    type: CreateVendorDto,
    required: true,
  })
  @ApiConsumes('multipart/form-data')
  @UseInterceptors(
    FileInterceptor(
      'logo',
      FileUploadService.saveImageToStorage({
        dirName: FileUploadDirNames.vendor,
      }),
    ),
  )
  @ApiBearerAuth()
  @Role(UserRole.ADMIN)
  @Post()
  create(
    @Body() createVendorDto: CreateVendorDto,
    @UploadedFile() logo: Express.Multer.File,
  ) {
    if (!logo) {
      throw new BadRequestException('busines logo is required.');
    }
    createVendorDto.logo_url = this.fileUploadService.getFilePath(logo);
    return this.vendorsService.createVendor(createVendorDto);
  }

  @ApiOperation({
    summary: 'Find All Vendors.',
    description: 'use this endpoint to find all vendors.',
  })
  @ApiBearerAuth()
  @Role(UserRole.ADMIN)
  @Get()
  findAllVendors() {
    return this.vendorsService.findAllVendors();
  }

  @ApiOperation({
    summary: 'Find Vendor By ID.',
    description: 'use this api endpoint to find vendor by id',
  })
  @ApiParam({
    name: 'id',
    required: true,
    description: 'vendor id',
  })
  @ApiBearerAuth()
  @Role(UserRole.ADMIN)
  @Get(':id')
  findVendorById(@Param('id') id: string) {
    return this.vendorsService.findVendorById(id);
  }

  @ApiOperation({
    summary: 'Update Vendor By ID.',
    description: 'use this endpoint to find vendor by id and update it',
  })
  @ApiBody({
    required: true,
    type: UpdateVendorDto,
  })
  @ApiParam({
    name: 'id',
    required: true,
    description: 'vendor id.',
  })
  @ApiConsumes('multipart/form-data')
  @UseInterceptors(
    FileInterceptor(
      'logo',
      FileUploadService.saveImageToStorage({
        dirName: FileUploadDirNames.vendor,
      }),
    ),
  )
  @ApiBearerAuth()
  @Role(UserRole.ADMIN)
  @Patch(':id')
  updateVendor(
    @Param('id') id: string,
    @Body() updateVendorDto: UpdateVendorDto,
    @UploadedFile() logo: Express.Multer.File,
  ) {
    if (logo) {
      updateVendorDto.logo_url = this.fileUploadService.getFilePath(logo);
    }
    return this.vendorsService.updateVendor(id, updateVendorDto);
  }

  @ApiOperation({
    summary: 'Delete Vendor by ID',
    description: 'use this api endpoint to delete vendor by id.',
  })
  @ApiParam({
    name: 'id',
    required: true,
    description: 'vendor id',
  })
  @ApiBearerAuth()
  @Role(UserRole.ADMIN)
  @HttpCode(HttpStatus.NO_CONTENT)
  @Delete(':id')
  deleteVendor(@Param('id') id: string) {
    return this.vendorsService.deleteVendor(id);
  }
}
</file>

<file path="src/api/vendors/vendors/vendors.module.ts">
import { Module } from '@nestjs/common';
import { FileUploadModule } from 'src/common/file-upload/file-upload.module';
import { PrismaModule } from 'src/common/prisma/prisma.module';
import { CreateVendorProvider } from './providers/create-vendor.provider';
import { DeleteVendorProvider } from './providers/delete-vendor.provider';
import { FindAllVendorsProvider } from './providers/find-all-vendors.provider';
import { FindOneVendorProvider } from './providers/find-one-vendor.provider';
import { FindVendorByIdProvider } from './providers/find-vendor-by-id.provider';
import { UpdateVendorProvider } from './providers/update-vendor.provider';
import { VendorsController } from './vendors.controller';
import { VendorsService } from './vendors.service';
import { UsersModule } from '../../users/users.module';
import { VendorBalanceModule } from '../vendor_balance/vendor_balance.module';

@Module({
  controllers: [VendorsController],
  providers: [
    VendorsService,
    UpdateVendorProvider,
    CreateVendorProvider,
    DeleteVendorProvider,
    FindAllVendorsProvider,
    FindOneVendorProvider,
    FindVendorByIdProvider,
  ],
  imports: [PrismaModule, FileUploadModule, UsersModule, VendorBalanceModule],
  exports: [VendorsService],
})
export class VendorsModule {}
</file>

<file path="src/api/vendors/vendors/vendors.service.ts">
import { Injectable } from '@nestjs/common';
import { CreateVendorDto } from './dto/create-vendor.dto';
import { UpdateVendorDto } from './dto/update-vendor.dto';
import { CreateVendorProvider } from './providers/create-vendor.provider';
import { DeleteVendorProvider } from './providers/delete-vendor.provider';
import { FindAllVendorsProvider } from './providers/find-all-vendors.provider';
import { FindVendorByIdProvider } from './providers/find-vendor-by-id.provider';
import { UpdateVendorProvider } from './providers/update-vendor.provider';
import { Vendor } from '@prisma/client';
import { FindOneVendorProvider } from './providers/find-one-vendor.provider';

@Injectable()
export class VendorsService {
  constructor(
    private readonly createVendorProvider: CreateVendorProvider,
    private readonly deleteVendorProvider: DeleteVendorProvider,
    private readonly findAllVendorsProvider: FindAllVendorsProvider,
    private readonly findVendorByIdProvider: FindVendorByIdProvider,
    private readonly updateVendorProvider: UpdateVendorProvider,
    private readonly findOneVendorProvider: FindOneVendorProvider,
  ) {}
  createVendor(createVendorDto: CreateVendorDto) {
    return this.createVendorProvider.createVendor(createVendorDto);
  }

  findAllVendors() {
    return this.findAllVendorsProvider.findAllVendors();
  }

  findVendorById(id: string) {
    return this.findVendorByIdProvider.findVendorById(id);
  }

  updateVendor(id: string, updateVendorDto: UpdateVendorDto) {
    return this.updateVendorProvider.updateVendor(id, updateVendorDto);
  }

  deleteVendor(id: string) {
    return this.deleteVendorProvider.deleteVendr(id);
  }

  findOneVendor(options: Partial<Vendor>) {
    return this.findOneVendorProvider.findOneVendor(options);
  }
}
</file>

<file path="src/api/vendors/withdrawal_request/dtos/create-withdrawal-request.dto.ts">
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsNotEmpty, IsNumber, IsOptional, IsString } from 'class-validator';

export class CreateWithdrawalRequestDto {
  @ApiProperty({
    description: 'withdrawal amount.',
  })
  @IsNumber()
  @IsNotEmpty()
  amount: number;

  @ApiPropertyOptional({
    description: 'some note about the withdrawal request.',
  })
  @IsOptional()
  @IsString()
  notes: string;

  userId: string;
}
</file>

<file path="src/api/vendors/withdrawal_request/dtos/process-withdrawal.dto.ts">
import { ApiProperty } from '@nestjs/swagger';
import { WithdrawalStatus } from '@prisma/client';
import { IsEnum, IsNotEmpty } from 'class-validator';

export class ProcessWithdrawalDto {
  @ApiProperty({
    description: 'withdrawal status.',
    enum: WithdrawalStatus,
  })
  @IsEnum(WithdrawalStatus)
  @IsNotEmpty()
  status: WithdrawalStatus;
}
</file>

<file path="src/api/vendors/withdrawal_request/withdrawal_request.controller.ts">
import {
  Body,
  Controller,
  Get,
  InternalServerErrorException,
  NotFoundException,
  Param,
  Patch,
  Post,
  Query,
} from '@nestjs/common';
import {
  ApiBearerAuth,
  ApiBody,
  ApiOperation,
  ApiParam,
  ApiQuery,
} from '@nestjs/swagger';
import { UserRole, Vendor } from '@prisma/client';
import { ActiveUser, Role } from 'src/api/auth/decorators';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateWithdrawalRequestDto } from './dtos/create-withdrawal-request.dto';
import { WithdrawalRequestService } from './withdrawal_request.service';
import { IActiveUserData } from 'src/api/auth/interfaces/active-user-data.interface';
import { ProcessWithdrawalDto } from './dtos/process-withdrawal.dto';

@Controller('vendor/withdrawal-request')
export class WithdrawalRequestController {
  constructor(
    private readonly prisma: PrismaService,
    private readonly withdrawalRequestService: WithdrawalRequestService,
  ) {}

  // Create withdrawal request
  @ApiOperation({
    summary: 'Create withdrawal request',
    description: 'Create withdrawal request',
  })
  @ApiBody({
    type: CreateWithdrawalRequestDto,
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.VENDOR)
  @Post()
  async createWithdrawalRequest(
    @Body() createWithdrawalRequestDto: CreateWithdrawalRequestDto,
    @ActiveUser('sub') userId: string,
  ) {
    createWithdrawalRequestDto.userId = userId;
    return this.withdrawalRequestService.createWithdrawalRequest(
      createWithdrawalRequestDto,
    );
  }

  // Get vendor's withdrawal requests
  @ApiOperation({
    summary: "Get vendor's withdrawal requests",
    description: "Get vendor's withdrawal requests",
  })
  @ApiQuery({
    name: 'vendorId',
    description:
      'admins can send vendor id on the query and geet details about that vendor.',
    required: false,
  })
  @ApiBearerAuth()
  @Role(UserRole.ADMIN, UserRole.VENDOR)
  @Get()
  async getVendorWithdrawals(
    @Query('vendorId') vendorId: string,
    @ActiveUser() activeUserData: IActiveUserData,
  ) {
    const { role, sub: userId } = activeUserData;
    let vendor: Vendor;
    try {
      vendor = await this.prisma.vendor.findUnique({
        where: {
          ...(role === UserRole.VENDOR && { userId }),
          ...(role === UserRole.ADMIN && { vendorId }),
        },
      });
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'Unable to find vendor, please try again later.',
      );
    }

    if (!vendor) {
      throw new NotFoundException('vendor not found.');
    }

    return this.withdrawalRequestService.getVendorWithdrawals(vendor.id);
  }

  // Admin: Process withdrawal request
  @ApiOperation({
    summary: 'Admin: Process withdrawal request',
    description: 'Admin: Process withdrawal request',
  })
  @ApiBody({
    type: ProcessWithdrawalDto,
    required: true,
  })
  @ApiParam({
    description: 'withdrawal request id',
    name: 'withdrawalRequestId',
    required: true,
  })
  @ApiBearerAuth()
  @Role(UserRole.ADMIN)
  @Patch(':withdrawalRequestId')
  async processWithdrawal(
    @Param('withdrawalRequestId') withdrawalId: string,
    @Body() processWithdrawalDto: ProcessWithdrawalDto,
  ) {
    return this.withdrawalRequestService.processWithdrawal(
      withdrawalId,
      processWithdrawalDto,
    );
  }
}
</file>

<file path="src/api/vendors/withdrawal_request/withdrawal_request.module.ts">
import { Module } from '@nestjs/common';
import { WithdrawalRequestController } from './withdrawal_request.controller';
import { WithdrawalRequestService } from './withdrawal_request.service';
import { PrismaModule } from 'src/common/prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [WithdrawalRequestController],
  providers: [WithdrawalRequestService],
})
export class WithdrawalRequestModule {}
</file>

<file path="src/api/vendors/withdrawal_request/withdrawal_request.service.ts">
import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import {
  Vendor,
  VendorBalance,
  WithdrawalRequest,
  WithdrawalStatus,
} from '@prisma/client';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { CreateApiResponse } from 'src/lib/utils/create-api-response.util';
import { CreateWithdrawalRequestDto } from './dtos/create-withdrawal-request.dto';
import { ProcessWithdrawalDto } from './dtos/process-withdrawal.dto';

@Injectable()
export class WithdrawalRequestService {
  constructor(private readonly prisma: PrismaService) {}

  // Create withdrawal request
  async createWithdrawalRequest(
    createWithdrawalRequestDto: CreateWithdrawalRequestDto,
  ) {
    const { amount, notes, userId } = createWithdrawalRequestDto;

    if (!userId) {
      throw new BadRequestException('user id is required.');
    }

    let vendor: Vendor;
    try {
      vendor = await this.prisma.vendor.findUnique({ where: { userId } });
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'Unable to find vendor, please try again later.',
      );
    }

    if (!vendor) {
      throw new NotFoundException('vendor not found.');
    }

    // First check vendor balance
    let vendorBalance: VendorBalance;
    try {
      vendorBalance = await this.prisma.vendorBalance.findUnique({
        where: { vendorId: vendor.id },
      });
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'Unable to find vendor balance. please try again later.',
      );
    }

    if (!vendorBalance || vendorBalance.available_balance.toNumber() < amount) {
      throw new BadRequestException('Insufficient balance for withdrawal');
    }

    try {
      // Create withdrawal request in a transaction
      const request = await this.prisma.$transaction(async (tx) => {
        // Update vendor balance
        await tx.vendorBalance.update({
          where: { vendorId: vendor.id },
          data: {
            available_balance: { decrement: amount },
            pending_withdrawals: { increment: amount },
          },
        });

        // Create withdrawal request
        return tx.withdrawalRequest.create({
          data: {
            amount,
            notes,
            vendor_balance: { connect: { vendorId: vendor.id } },
          },
        });
      });

      return CreateApiResponse({
        status: 'success',
        message: 'withdrawal request successfull.',
        data: request,
      });
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'Unable to create withdrawal request at the momet, please try again later.',
      );
    }
  }

  // Get vendor's withdrawal requests
  async getVendorWithdrawals(vendorId: string) {
    try {
      const requests = this.prisma.withdrawalRequest.findMany({
        where: {
          vendor_balance: {
            vendorId,
          },
        },
        orderBy: {
          createdAt: 'desc',
        },
      });

      return CreateApiResponse({
        status: 'success',
        message: 'get vendors withdrawal requests successfull.',
        data: requests,
      });
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'Unable to find withdrawal requests. please try again later.',
      );
    }
  }

  // Admin: Process withdrawal request
  async processWithdrawal(
    withdrawalId: string,
    processWithdrawalDto: ProcessWithdrawalDto,
  ) {
    const { status } = processWithdrawalDto;
    let withdrawal: WithdrawalRequest;
    try {
      withdrawal = await this.prisma.withdrawalRequest.findUnique({
        where: { id: withdrawalId },
        include: { vendor_balance: true },
      });
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'unable to find withdrawalRequest. please try again later.',
      );
    }

    if (!withdrawal) {
      throw new NotFoundException('Withdrawal request not found');
    }

    try {
      const result = await this.prisma.$transaction(async (tx) => {
        if (status === WithdrawalStatus.COMPLETED) {
          await tx.vendorBalance.update({
            where: { id: withdrawal.vendor_balance_id },
            data: {
              pending_withdrawals: { decrement: withdrawal.amount },
              withdrawn_amount: { increment: withdrawal.amount },
            },
          });
        } else if (status === WithdrawalStatus.REJECTED) {
          await tx.vendorBalance.update({
            where: { id: withdrawal.vendor_balance_id },
            data: {
              pending_withdrawals: { decrement: withdrawal.amount },
              available_balance: { increment: withdrawal.amount },
            },
          });
        }

        return tx.withdrawalRequest.update({
          where: { id: withdrawalId },
          data: {
            status,
            processed_at: new Date(),
          },
        });
      });

      return CreateApiResponse({
        status: 'success',
        message: 'withdrawal processing successfull.',
        data: result,
      });
    } catch (err) {
      console.log(err);
      throw new InternalServerErrorException(
        'Unable to process withdrawal request, please try again later.',
      );
    }
  }
}
</file>

<file path="src/api/vendors/vendors_root.module.ts">
import { Module } from '@nestjs/common';
import { VenderTransactionModule } from './vender_transaction/vender_transaction.module';
import { VendorBalanceModule } from './vendor_balance/vendor_balance.module';
import { VendorBankAccountModule } from './vendor_bank_account/vendor_bank_account.module';
import { VendorsModule } from './vendors/vendors.module';
import { WithdrawalRequestModule } from './withdrawal_request/withdrawal_request.module';

@Module({
  imports: [
    VendorBankAccountModule,
    VendorBalanceModule,
    VenderTransactionModule,
    WithdrawalRequestModule,
    VendorsModule,
  ],
})
export class VendorsRootModule {}
</file>

<file path="src/api/wishlist/interfaces/create-wishlist.interface.ts">
export interface ICreateWishlist {
  productId: string;
  userId: string;
}
</file>

<file path="src/api/wishlist/wishlist.controller.ts">
import { Controller, Delete, Get, Param, Post } from '@nestjs/common';
import { WishlistService } from './wishlist.service';
import { ApiBearerAuth, ApiOperation, ApiParam } from '@nestjs/swagger';
import { ActiveUser } from '../auth/decorators';

@Controller('wishlist')
export class WishlistController {
  constructor(private readonly wishlistService: WishlistService) {}

  // get my wishlists
  @ApiOperation({
    summary: 'get my wishlists.',
  })
  @ApiBearerAuth()
  @Get()
  getMyWishlists(@ActiveUser('sub') userId: string) {
    return this.wishlistService.getMyWishlists(userId);
  }

  // create wishlist
  @ApiOperation({
    summary: 'get my wishlists.',
  })
  @ApiParam({
    name: 'id',
    description: 'product id to be added to wishlist',
    required: true,
  })
  @ApiBearerAuth()
  @Post(':id')
  createWishlist(
    @ActiveUser('sub') userId: string,
    @Param('id') productId: string,
  ) {
    return this.wishlistService.createWishlist({ productId, userId });
  }

  // delete wishlist
  @ApiOperation({
    summary: 'delete wishlist',
  })
  @ApiParam({
    name: 'id',
    description: 'wishlist id to be deleted.',
    required: true,
  })
  @ApiBearerAuth()
  @Delete(':id')
  deleteMyWishlist(@Param('id') wishlistId: string) {
    return this.wishlistService.deleteMyWishlist(wishlistId);
  }
}
</file>

<file path="src/api/wishlist/wishlist.module.ts">
import { Module } from '@nestjs/common';
import { WishlistService } from './wishlist.service';
import { WishlistController } from './wishlist.controller';
import { PrismaModule } from 'src/common/prisma/prisma.module';

@Module({
  controllers: [WishlistController],
  providers: [WishlistService],
  imports: [PrismaModule],
})
export class WishlistModule {}
</file>

<file path="src/api/wishlist/wishlist.service.ts">
import {
  Injectable,
  ConflictException,
  NotFoundException,
  InternalServerErrorException,
} from '@nestjs/common';
import { PrismaService } from 'src/common/prisma/prisma.service';
import { ICreateWishlist } from './interfaces/create-wishlist.interface';

@Injectable()
export class WishlistService {
  constructor(private readonly prisma: PrismaService) {}

  // Get current user's wishlists
  public async getMyWishlists(userId: string) {
    try {
      return await this.prisma.wishlist.findMany({
        where: { userId },
        include: {
          Product: true,
        },
      });
    } catch (error) {
      console.error('Error fetching wishlists:', error);
      throw new InternalServerErrorException('Failed to retrieve wishlists');
    }
  }

  // Add product to wishlist
  public async createWishlist({ productId, userId }: ICreateWishlist) {
    try {
      return await this.prisma.wishlist.create({
        data: { productId, userId },
      });
    } catch (error) {
      if (error.code === 'P2002') {
        // Unique constraint violation
        throw new ConflictException('Product already exists in wishlist');
      }
      console.error('Error creating wishlist:', error);
      throw new InternalServerErrorException('Failed to create wishlist');
    }
  }

  // Remove wishlist item by ID
  public async deleteMyWishlist(wishlistId: string) {
    try {
      const wishlist = await this.prisma.wishlist.findUnique({
        where: { id: wishlistId },
      });

      if (!wishlist) {
        throw new NotFoundException('Wishlist not found');
      }

      return await this.prisma.wishlist.delete({
        where: { id: wishlistId },
      });
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      console.error('Error deleting wishlist:', error);
      throw new InternalServerErrorException('Failed to delete wishlist');
    }
  }
}
</file>

<file path="src/common/configuration/config/app.config.ts">
import { registerAs } from '@nestjs/config';

export default registerAs('appConfig', () => ({
  appName: process.env.APP_NAME,
  apiVersion: process.env.API_VERSION,
  apiPrefix: process.env.API_PREFIX,
  backendUrl:
    process.env.NODE_ENV === 'development'
      ? process.env.BACKEND_URL_DEV
      : process.env.BACKEND_URL_PROD,
  frontendUrl:
    process.env.NODE_ENV === 'development'
      ? process.env.FRONTEND_URL_DEV
      : process.env.FRONTEND_URL_PROD,
  resetPasswordFrontendUrl: process.env.RESET_PASSWORD_FRONTEND_URL,
  defaultSysPassword: process.env.DEFAULT_SYS_PASSWORD,
}));
</file>

<file path="src/common/configuration/config/cookies.config.ts">
import { registerAs } from '@nestjs/config';
import { DayToTimestamp } from 'src/lib/helpers/day-to-timestamp';

export default registerAs('cookieConfig', () => ({
  accessTokenExpiresIn: DayToTimestamp(
    parseInt(process.env.COOKIE_ACCESS_TOKEN_EXPIRES_IN, 10),
  ),
  refreshTokenExpiresIn: DayToTimestamp(
    parseInt(process.env.COOKIE_REFRESH_TOKEN_EXPIRES_IN, 10),
  ),
}));
</file>

<file path="src/common/configuration/config/database.config.ts">
import { registerAs } from '@nestjs/config';

export default registerAs('databaseConfig', () => ({
  url: process.env.DATABASE_URL,
}));
</file>

<file path="src/common/configuration/config/email.config.ts">
import { registerAs } from '@nestjs/config';

export default registerAs('email', () => ({
  host: process.env.EMAIL_HOST,
  port: process.env.EMAIL_PORT,
  username: process.env.EMAIL_USERNAME,
  password: process.env.EMAIL_PASSWORD,
  from: process.env.EMAIL_FROM,

  sendgrid_username: process.env.SENDGRID_USERNAME,
  sendgrid_password: process.env.SENDGRID_PASSWORD,
}));
</file>

<file path="src/common/configuration/config/index.ts">
export { default as appConfig } from './app.config';
export { default as cookieConfig } from './cookies.config';
export { default as databaseConfig } from './database.config';
export { default as emailConfig } from './email.config';
export { default as jwtConfig } from './jwt.config';
export { default as paymentConfig } from './payment.config';
export { default as twilioConfig } from './twilio.config';
</file>

<file path="src/common/configuration/config/jwt.config.ts">
import { registerAs } from '@nestjs/config';
import { DayToTimestamp } from 'src/lib/helpers/day-to-timestamp';

export default registerAs('jwtConfig', () => ({
  secret: process.env.JWT_SECRET,
  audience: process.env.JWT_TOKEN_AUDIENCE,
  issuer: process.env.JWT_TOKEN_ISSUER,
  accessTokenTtl: DayToTimestamp(
    parseInt(process.env.JWT_ACCESS_TOKEN_TTL, 10),
  ),
  refreshTokenTtl: DayToTimestamp(
    parseInt(process.env.JWT_REFRESH_TOKEN_TTL, 10),
  ),
}));
</file>

<file path="src/common/configuration/config/payment.config.ts">
import { registerAs } from '@nestjs/config';

export default registerAs('paymentConfig', () => ({
  chapaWebhookUrl: process.env.CHAPA_WEBHOOK_URL,
  chapaWebhookSecret: process.env.CHAPA_WEBHOOK_SECRET,
  chapaSecretKey: process.env.CHAPA_SECRET_KEY,
}));
</file>

<file path="src/common/configuration/config/twilio.config.ts">
import { registerAs } from '@nestjs/config';

export default registerAs('twilio', () => ({
  accountSid: process.env.TWILIO_ACCOUNT_SID,
  phoneNumber: process.env.TWILIO_PHONE_NUMBER,
  authToken: process.env.TWILIO_AUTH_TOKEN,
}));
</file>

<file path="src/common/configuration/configuration.module.ts">
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import environmentValidation from './environment.validation';
import {
  appConfig,
  cookieConfig,
  databaseConfig,
  jwtConfig,
  emailConfig,
  twilioConfig,
  paymentConfig,
} from './config';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: '.env',
      load: [
        appConfig,
        databaseConfig,
        jwtConfig,
        cookieConfig,
        emailConfig,
        twilioConfig,
        paymentConfig,
      ],
      validationSchema: environmentValidation,
    }),
  ],
})
export class ConfigurationModule {}
</file>

<file path="src/common/configuration/environment.validation.ts">
import * as Joi from 'joi';

export default Joi.object({
  // app config
  APP_NAME: Joi.string().required(),
  API_VERSION: Joi.string().required(),
  API_PREFIX: Joi.string().required(),
  BACKEND_URL_DEV: Joi.string().required(),
  BACKEND_URL_PROD: Joi.string().required(),
  FRONTEND_URL_DEV: Joi.string().required(),
  FRONTEND_URL_PROD: Joi.string().required(),
  RESET_PASSWORD_FRONTEND_URL: Joi.string().required(),
  DEFAULT_SYS_PASSWORD: Joi.string().required(),

  // database config
  DATABASE_URL: Joi.string().required(),

  // jwt config
  JWT_SECRET: Joi.string().required(),
  JWT_TOKEN_AUDIENCE: Joi.string().required(),
  JWT_TOKEN_ISSUER: Joi.string().required(),
  JWT_ACCESS_TOKEN_TTL: Joi.number().required(),
  JWT_REFRESH_TOKEN_TTL: Joi.number().required(),

  // cookie config
  COOKIE_ACCESS_TOKEN_EXPIRES_IN: Joi.number().required(),
  COOKIE_REFRESH_TOKEN_EXPIRES_IN: Joi.number().required(),

  // chapa payment get way
  CHAPA_WEBHOOK_URL: Joi.string().required(),
  CHAPA_WEBHOOK_SECRET: Joi.string().required(),
  CHAPA_SECRET_KEY: Joi.string().required(),

  // email service
  EMAIL_HOST: Joi.string().required(),
  EMAIL_PORT: Joi.number().port().required(),
  EMAIL_USERNAME: Joi.string().required(),
  EMAIL_PASSWORD: Joi.string().required(),
  EMAIL_FROM: Joi.string().required(),

  // real email sending
  SENDGRID_USERNAME: Joi.string().required(),
  SENDGRID_PASSWORD: Joi.string().required(),

  // Twilio
  TWILIO_ACCOUNT_SID: Joi.string().required(),
  TWILIO_PHONE_NUMBER: Joi.string().required(),
  TWILIO_AUTH_TOKEN: Joi.string().required(),
});
</file>

<file path="src/common/decorators/check-password-confirm.decorator.ts">
import {
  registerDecorator,
  ValidationArguments,
  ValidationOptions,
} from 'class-validator';

export function CheckPasswordConfirm(options: ValidationOptions) {
  return (object: object, propertyName: string) => {
    registerDecorator({
      propertyName,
      target: object.constructor,
      name: 'checkPasswordConfirm',
      options,
      validator: {
        validate(_value: any, args: ValidationArguments) {
          const { password, passwordConfirm } = args.object as any;

          return !!(password === passwordConfirm);
        },
        defaultMessage() {
          return 'password and password confirm should be the same';
        },
      },
    });
  };
}
</file>

<file path="src/common/decorators/email-or-phone.decorator.ts">
import {
  registerDecorator,
  ValidationArguments,
  ValidationOptions,
} from 'class-validator';

export function EmailOrPhone(validationOptions?: ValidationOptions) {
  return (object: object, propertyName: string) => {
    registerDecorator({
      name: 'eitherEmailOrPhone',
      target: object.constructor,
      options: validationOptions,
      propertyName,
      validator: {
        validate(_value: any, args: ValidationArguments) {
          const { email, phoneNumber } = args.object as any;
          return !!(email || phoneNumber);
        },
        defaultMessage() {
          return 'Email or Phone Number must be provided.';
        },
      },
    });
  };
}
</file>

<file path="src/common/email/interfaces/send-email.interface.ts">
export interface ISendEmailOptions {
  recipient_email: string;
  subject: string;
  message: string;
  html: string;
}
</file>

<file path="src/common/email/email.module.ts">
import { Module } from '@nestjs/common';
import { EmailService } from './email.service';
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [ConfigModule],
  providers: [EmailService],
  exports: [EmailService],
})
export class EmailModule {}
</file>

<file path="src/common/email/email.service.ts">
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as nodemailer from 'nodemailer';
import { ISendEmailOptions } from './interfaces/send-email.interface';

@Injectable()
export class EmailService {
  constructor(private readonly configService: ConfigService) {}

  public async sendEmail(options: ISendEmailOptions) {
    // create transporter

    // const transporter = nodemailer.createTransport({
    //   host: this.configService.get('email.host'),
    //   port: this.configService.get('email.port'), // Port must be a number
    //   auth: {
    //     user: this.configService.get('email.username'),
    //     pass: this.configService.get('email.password'),
    //   },
    //   debug: true,
    //   logger: true,
    // });
    const transporter = nodemailer.createTransport({
      service: 'SendGrid',
      secure: false,
      auth: {
        user: this.configService.get('email.sendgrid_username'),
        pass: this.configService.get('email.sendgrid_password'),
      },
    });

    // send the email
    await transporter.sendMail({
      from: {
        name: this.configService.get('appConfig.appName'),
        address: this.configService.get('email.from'),
      },
      to: options.recipient_email,
      subject: options.subject,
      text: options.message,
      html: options.html,
    });
  }
}
</file>

<file path="src/common/file-upload/file-upload.module.ts">
import { Module } from '@nestjs/common';
import { FileUploadService } from './file-upload.service';

@Module({
  providers: [FileUploadService],
  exports: [FileUploadService],
})
export class FileUploadModule {}
</file>

<file path="src/common/file-upload/file-upload.service.ts">
import { BadRequestException, Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as fs from 'fs';
import { diskStorage } from 'multer';
import * as path from 'path';
import { MaxImageFileSize } from 'src/lib/constants/max-image-file-size';
import { v4 as uuidv4 } from 'uuid';

type ValidMimeType = 'image/png' | 'image/jpg' | 'image/jpeg';

const validMimeTypes: ValidMimeType[] = [
  'image/png',
  'image/jpg',
  'image/jpeg',
];

@Injectable()
export class FileUploadService {
  constructor(private readonly configService: ConfigService) {}

  public getFilePath(file: Express.Multer.File) {
    let filePath =
      file.destination.split('/').slice(-2).join('/') + '/' + file.filename;

    filePath = `${this.configService.get('appConfig.backendUrl')}/${filePath}`;

    return filePath;
  }

  public static saveImageToStorage({ dirName }: { dirName: string }) {
    const uploadsDirRoot = path.join(
      process.cwd(),
      'public',
      'uploads',
      dirName,
    );

    // Ensure the uploads directory exists
    if (!fs.existsSync(uploadsDirRoot)) {
      fs.mkdirSync(uploadsDirRoot, { recursive: true });
    }

    return {
      storage: diskStorage({
        destination: (_req, _file, cb) => {
          cb(null, uploadsDirRoot);
        },
        filename: async (_req, file, cb) => {
          const fileExtension = path.extname(file.originalname).toLowerCase();
          const fileName = `${dirName}-${uuidv4()}${fileExtension}`;
          cb(null, fileName);
        },
      }),
      fileFilter: (_req, file, cb) => {
        if (!file.mimetype.startsWith('image')) {
          return cb(
            new BadRequestException(
              'Invalid file type! only image can be uploaded',
            ),
            false,
          );
        }

        if (file.size > MaxImageFileSize) {
          return cb(
            new BadRequestException(
              `File size exceeds the ${MaxImageFileSize}MB limit.`,
            ),
            false,
          );
        }

        cb(null, true);
      },
    };
  }

  public removeFile(fullFilePath: string): void {
    try {
      if (!fullFilePath) {
        console.warn('No file path provided to remove');
        return;
      }

      let filePath: string;

      if (
        fullFilePath.startsWith('http://') ||
        fullFilePath.startsWith('https://')
      ) {
        // Extract the relative path after 'uploads/'
        const matches = fullFilePath.match(/\/uploads\/(.*)/);
        if (!matches || !matches[1]) {
          throw new Error('Invalid file path format');
        }

        filePath = path.join(process.cwd(), 'public', 'uploads', matches[1]);
      } else {
        // If it's already a local path
        filePath = fullFilePath;
      }

      // Check if file exists before attempting to delete
      if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath); // Using sync version for simplicity
        console.log(`File successfully removed: ${filePath}`);
      } else {
        console.warn(`File not found: ${filePath}`);
      }
    } catch (error) {
      console.error('Error removing file:', error);
      throw new BadRequestException(`Failed to remove file: ${error.message}`);
    }
  }
}
</file>

<file path="src/common/interceptors/data-response/data-response.interceptor.ts">
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { map, Observable } from 'rxjs';

@Injectable()
export class DataResponseInterceptor implements NestInterceptor {
  constructor(private configService: ConfigService) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      map((data) => ({
        apiVersion: this.configService.get('appConfig.apiVersion'),
        data,
      })),
    );
  }
}
</file>

<file path="src/common/interceptors/serialize-prisma-decimals/decimal.interceptor.ts">
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { Decimal } from '@prisma/client/runtime/library';

function convertDecimalsAndDates(obj: any): any {
  if (Array.isArray(obj)) {
    return obj.map(convertDecimalsAndDates);
  } else if (obj && typeof obj === 'object') {
    return Object.fromEntries(
      Object.entries(obj).map(([key, value]) => {
        if (value instanceof Decimal) {
          return [key, value.toNumber()];
        }
        if (value instanceof Date) {
          return [key, value.toISOString()];
        }
        return [key, convertDecimalsAndDates(value)];
      }),
    );
  }
  return obj;
}

@Injectable()
export class DecimalInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(map((data) => convertDecimalsAndDates(data)));
  }
}
</file>

<file path="src/common/interceptors/interceptors.module.ts">
import { Module } from '@nestjs/common';
import { APP_INTERCEPTOR } from '@nestjs/core';
import { DataResponseInterceptor } from './data-response/data-response.interceptor';

@Module({
  providers: [
    {
      provide: APP_INTERCEPTOR,
      useClass: DataResponseInterceptor,
    },
  ],
})
export class InterceptorsModule {}
</file>

<file path="src/common/message/interfaces/send-sms.interface.ts">
export interface ISendSMS {
  recieptPhoneNumber: string;
  message: string;
}
</file>

<file path="src/common/message/message.module.ts">
import { Module } from '@nestjs/common';
import { MessageService } from './message.service';
import { ConfigModule } from '@nestjs/config';

@Module({
  providers: [MessageService],
  exports: [MessageService],
  imports: [ConfigModule],
})
export class MessageModule {}
</file>

<file path="src/common/message/message.service.ts">
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Twilio } from 'twilio';
import { ISendSMS } from './interfaces/send-sms.interface';

@Injectable()
export class MessageService {
  private twilioClient: Twilio;

  constructor(private readonly configService: ConfigService) {
    const accountSid = this.configService.get('twilio.account_sid');
    const authtoken = this.configService.get('twilio.authtoken');

    this.twilioClient = new Twilio(accountSid, authtoken);
  }

  public async sendSMS({ message, recieptPhoneNumber }: ISendSMS) {
    console.log('sending sms message to: ', recieptPhoneNumber);

    const response = await this.twilioClient.messages.create({
      body: message,
      from: this.configService.get('twilio.phoneNumber'),
      to: recieptPhoneNumber,
    });

    console.log('message sent successfully to: ', recieptPhoneNumber);
    console.log(response.body);
  }
}
</file>

<file path="src/common/pagination/dtos/pagination-query.dto.ts">
import { ApiProperty } from '@nestjs/swagger';
import { IsOptional, IsPositive } from 'class-validator';

export class PaginationQueryDto {
  @ApiProperty({
    description: 'The page number to retrieve',
    default: 20,
    required: false,
  })
  @IsOptional()
  @IsPositive()
  limit?: number = 20;

  @ApiProperty({
    description: 'The number of items to skip',
    default: 1,
    required: false,
  })
  @IsOptional()
  @IsPositive()
  page?: number = 1;
}
</file>

<file path="src/common/pinno-logger/pinno-logger.module.ts">
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { LoggerModule } from 'nestjs-pino';

@Module({
  imports: [
    LoggerModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => {
        const isProduction =
          configService.get('appConfig.environment') === 'production';

        return {
          pinoHttp: {
            transport: isProduction
              ? undefined
              : {
                  target: 'pino-pretty',
                  options: {
                    singleLine: true,
                  },
                },
            level: isProduction ? 'info' : 'debug',
          },
        };
      },
      inject: [ConfigService],
    }),
  ],
})
export class PinnoLoggerModule {}
</file>

<file path="src/common/prisma/prisma.module.ts">
import { Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}
</file>

<file path="src/common/prisma/prisma.service.ts">
import { Injectable } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient {}
</file>

<file path="src/common/swagger/swagger.module.ts">
import { INestApplication, Module } from '@nestjs/common';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';

@Module({})
export class SwaggerConfigModule {
  static setup(app: INestApplication) {
    const ENV = process.env.NODE_ENV || 'development';

    const config = new DocumentBuilder()
      .setTitle('Multivendor market place backend api')
      .setDescription('Multivendor market place backend API built using NestJS')
      .setVersion('1.0.0')
      .addServer(
        ENV === 'development'
          ? process.env.BACKEND_URL_DEV
          : process.env.BACKEND_URL_PROD,
      )
      .addBearerAuth() // Add Bearer token support
      .build();

    const document = SwaggerModule.createDocument(app, config);
    SwaggerModule.setup('api-docs', app, document);
  }
}
</file>

<file path="src/common/types/api-response.type.ts">
export interface Metadata {
  itemsPerPage?: number;
  totalItems?: number;
  currentPage?: number;
  totalPages?: number;
  [key: string]: any;
}

export class ApiResponse<T> {
  status: 'success' | 'error';
  message: string;
  timestamp: string;
  metadata?: Metadata;
  data: T | null;

  constructor(
    status: 'success' | 'error',
    message: string,
    metadata?: Metadata,
    data: T | null = null,
  ) {
    this.status = status;
    this.message = message;
    this.timestamp = new Date().toISOString(); // Default timestamp
    this.metadata = metadata;
    this.data = data;
  }
}
</file>

<file path="src/lib/constants/default-images.ts">
export const DEFAULT_USER_AVATAR =
  'https://res.cloudinary.com/dvp1mjhd9/image/upload/v1714690850/default_profile_image.png';
export const DEFAULT_PRODUCT_IMAGE_1 =
  'https://res.cloudinary.com/dvp1mjhd9/image/upload/v1744938280/axrcyeudhipiu0e1mvem.jpg';
export const DEFAULT_PRODUCT_IMAGE_2 =
  'https://res.cloudinary.com/dvp1mjhd9/image/upload/v1744938280/d8fbhim9ixedbebaxf28.jpg';
export const DEFAULT_COMPANY_LOGO =
  'https://res.cloudinary.com/dvp1mjhd9/image/upload/v1744938281/ysmaqbtkrwaftn40j6i2.png';
</file>

<file path="src/lib/constants/file-upload-dir-names.ts">
export const FileUploadDirNames = {
  user: 'user',
  product: 'product',
  vendor: 'vendor',
  category: 'category',
};
</file>

<file path="src/lib/constants/max-image-file-size.ts">
export const MaxImageFileSize = 5 * 1024 * 1024; // 5MB in bytes
</file>

<file path="src/lib/constants/pg-unique-violation-err-code.ts">
export const PgUniqueViolationErrorCode = '23505';
</file>

<file path="src/lib/helpers/day-to-timestamp.ts">
const OneDay = 24 * 60 * 60 * 1000;

export function DayToTimestamp(day: number) {
  return day * OneDay;
}
</file>

<file path="src/lib/helpers/get-reset-password-email-template.helper.ts">
import { User } from '@prisma/client';

export function GetResetPassEmailHtmlTemplate({
  user,
  resetUrl,
  appName,
}: {
  user: User;
  resetUrl: string;
  appName: string;
}) {
  return `
      <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta name="viewport" content="width=device-width, initial-scale=1.0" />
            <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
            <title>Password Reset Request</title>
            <style media="all" type="text/css">
              /* Global Resets */
              body {
                font-family: Helvetica, sans-serif;
                -webkit-font-smoothing: antialiased;
                font-size: 16px;
                line-height: 1.3;
                -ms-text-size-adjust: 100%;
                -webkit-text-size-adjust: 100%;
                background-color: #f4f5f6;
                margin: 0;
                padding: 0;
              }

              table {
                border-collapse: separate;
                width: 100%;
              }

              table td {
                font-family: Helvetica, sans-serif;
                font-size: 16px;
                vertical-align: top;
              }

              .container {
                margin: 0 auto;
                max-width: 600px;
                padding: 24px 0;
              }

              .content {
                margin: 0 auto;
                max-width: 600px;
                padding: 0;
              }

              .main {
                background: #ffffff;
                border: 1px solid #eaebed;
                border-radius: 16px;
                padding: 24px;
                width: 100%;
              }

              p {
                font-size: 16px;
                margin: 0 0 16px;
              }

              a {
                color: #0867ec;
                text-decoration: underline;
              }

              .btn-primary a {
                background-color: #0867ec;
                border: solid 2px #0867ec;
                border-radius: 4px;
                color: #ffffff;
                display: inline-block;
                font-size: 16px;
                font-weight: bold;
                padding: 12px 24px;
                text-decoration: none;
              }

              @media only screen and (max-width: 640px) {
                .main {
                  border-radius: 0 !important;
                }
              }
            </style>
          </head>
          <body>
            <table role="presentation" class="body">
              <tr>
                <td></td>
                <td class="container">
                  <div class="content">
                    <table role="presentation" class="main">
                      <tr>
                        <td class="wrapper">
                          <p>Dear ${user.first_name} ${user.last_name},</p>
                          <p>
                            We received a request to reset your password for your account at <strong>${appName}</strong>.
                          </p>
                          <p>
                            To reset your password, please click the button below. This
                            link will expire in 10 minutes for your security.
                          </p>
                          <table role="presentation" class="btn btn-primary">
                            <tr>
                              <td>
                                <a
                                  href="${resetUrl}"
                                  target="_blank"
                                  >Reset My Password</a
                                >
                              </td>
                            </tr>
                          </table>
                          <p>
                            If you did not request a password reset, please disregard
                            this email. Your account is safe, and no action is needed.
                          </p>
                          <p>
                            For any questions or assistance, feel free to reach out to
                            our support team. We're here to help!
                          </p>
                           <p>${appName}</p> 
                        </td>
                      </tr>
                    </table>
                    <!-- START FOOTER -->
                    <div class="footer">
                      <table
                        role="presentation"
                        border="0"
                        cellpadding="0"
                        cellspacing="0"
                      >
                        <tr>
                          <td class="content-block">
                            <span class="apple-link"></span>
                          </td>
                        </tr>
                        <tr>
                          <td class="content-block powered-by"></td>
                        </tr>
                      </table>
                    </div>

                    <!-- END FOOTER -->

                    <!-- END CENTERED WHITE CONTAINER -->
                  </div>
                </td>
                <td>&nbsp;</td>
              </tr>
            </table>
          </body>
        </html>
`;
}
</file>

<file path="src/lib/utils/create-api-response.util.ts">
import { Metadata, ApiResponse } from 'src/common/types/api-response.type';

export const CreateApiResponse = <T>({
  status,
  message,
  data = null,
  metadata,
  timestamp = new Date().toISOString(),
}: {
  status: 'success' | 'error';
  message: string;
  data?: T | null;
  metadata?: Metadata;
  timestamp?: string;
}): ApiResponse<T> => ({
  status,
  message,
  timestamp,
  data,
  metadata,
});
</file>

<file path="src/app.controller.ts">
import { Controller, Get } from '@nestjs/common';
import { AuthType } from './api/auth/enums/auth-type.enum';
import { Auth } from './api/auth/decorators';
import { ApiOperation } from '@nestjs/swagger';

@Controller('/') // <- disables global prefix
@Auth(AuthType.NONE)
export class AppController {
  @ApiOperation({
    summary: 'Get API information',
    description: 'Get API information',
  })
  @Get()
  getInfo() {
    return {
      name: 'Multivendor Market Place API',
      description: 'Multivendor Market Place API built using NestJS',
      docs: '/api-docs',
      timestamp: new Date(),
    };
  }
}
</file>

<file path="src/app.module.ts">
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { ChapaModule } from 'chapa-nestjs';
import { AddressesModule } from './api/addresses/addresses.module';
import { AuthModule } from './api/auth/auth.module';
import { CartModule } from './api/cart/cart.module';
import { CartItemsModule } from './api/cart_items/cart_items.module';
import { CategoriesModule } from './api/categories/categories.module';
import { OrderItemsModule } from './api/order_items/order_items.module';
import { OrdersModule } from './api/orders/orders.module';
import { PaymentsModule } from './api/payments/payments.module';
import { ProductsModule } from './api/products/products.module';
import { UsersModule } from './api/users/users.module';
import { ConfigurationModule } from './common/configuration/configuration.module';
import { FileUploadModule } from './common/file-upload/file-upload.module';
import { InterceptorsModule } from './common/interceptors/interceptors.module';
import { PinnoLoggerModule } from './common/pinno-logger/pinno-logger.module';
import { PrismaModule } from './common/prisma/prisma.module';
import { SwaggerConfigModule } from './common/swagger/swagger.module';
import { ReviewsModule } from './api/reviews/reviews.module';
import { AppController } from './app.controller';
import { EmailModule } from './common/email/email.module';
import { MessageModule } from './common/message/message.module';
import { VendorsRootModule } from './api/vendors/vendors_root.module';
import { WishlistModule } from './api/wishlist/wishlist.module';

@Module({
  imports: [
    UsersModule,
    AddressesModule,
    OrdersModule,
    OrderItemsModule,
    PaymentsModule,
    CategoriesModule,
    ProductsModule,

    PrismaModule,
    SwaggerConfigModule,
    PinnoLoggerModule,
    InterceptorsModule,
    ConfigurationModule,
    CartModule,
    CartItemsModule,
    AuthModule,
    FileUploadModule,

    ChapaModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: async (configService: ConfigService) => ({
        secretKey: configService.get('paymentConfig.chapaSecretKey'),
      }),
    }),

    ReviewsModule,

    EmailModule,

    MessageModule,

    VendorsRootModule,

    WishlistModule,
  ],
  controllers: [AppController],
})
export class AppModule {}
</file>

<file path="src/main.ts">
import {
  ClassSerializerInterceptor,
  RequestMethod,
  ValidationPipe,
} from '@nestjs/common';
import { NestFactory, Reflector } from '@nestjs/core';
import { NestExpressApplication } from '@nestjs/platform-express';
import * as cookieParser from 'cookie-parser';
import * as express from 'express';
import helmet from 'helmet';
import { join } from 'path';

import { AppModule } from './app.module';
import { DecimalInterceptor } from './common/interceptors/serialize-prisma-decimals/decimal.interceptor';
import { SwaggerConfigModule } from './common/swagger/swagger.module';

async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(AppModule, {
    logger: ['error', 'warn'],
  });

  const API_PREFIX = process.env.API_PREFIX || 'api/v1';
  // global prefix
  app.setGlobalPrefix(API_PREFIX, {
    exclude: [
      { path: '/api-docs', method: RequestMethod.GET },
      { path: '/', method: RequestMethod.GET },
    ],
  });

  // global pipes
  app.useGlobalPipes(
    new ValidationPipe({
      // properties that does not exist in the dto will be stripped
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
      transformOptions: {
        enableImplicitConversion: true,
      },
    }),
  );

  // global interceptors
  app.useGlobalInterceptors(
    new ClassSerializerInterceptor(app.get(Reflector)), // Apply ClassSerializerInterceptor globally
    new DecimalInterceptor(),
  );

  // enable cors
  app.enableCors({
    origin: ['http://localhost:3000', 'http://localhost:8081'],
    credentials: true,
  });
  app.use(cookieParser());
  app.use(helmet());

  //app.useStaticAssets(join(process.cwd(), 'public'));

  app.use(
    '/uploads',
    express.static(join(process.cwd(), 'public', 'uploads'), {
      setHeaders: (res) => {
        res.set('Access-Control-Allow-Origin', '*'); // Or restrict to specific frontend domain
        res.set('Cross-Origin-Resource-Policy', 'cross-origin'); // This is the key header
      },
    }),
  );

  // app.useLogger(app.get(Logger));

  // Setup Swagger
  SwaggerConfigModule.setup(app);

  await app.listen(process.env.PORT || 5000);
}
bootstrap();
</file>

<file path="test/app.e2e-spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});
</file>

<file path="test/jest-e2e.json">
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}
</file>

<file path=".eslintrc.js">
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
  },
};
</file>

<file path=".gitignore">
# compiled output
/dist
/node_modules
/build

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# temp directory
.temp
.tmp

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# exclude public files
public/
uploads/


# compodoc
documentation/
</file>

<file path=".prettierrc">
{
  "singleQuote": true,
  "trailingComma": "all"
}
</file>

<file path="add-to-cart-flow.md">
### 1. User Adds a Product to the Cart

- Action: User clicks "Add to Cart" on a product.

- API Call: `POST`: `/cart/items`

- Payload:

  ```json
  {
    "productId": "123",
    "quantity": 2
  }
  ```

- Backend:

  - Checks if the user already has an active cart.
  - If not, creates a new cart for the user.
  - Adds the product to cart_items.
  - Updates the cart’s total_price.

- Response:

  - Updated cart details including total price and items.

- Frontend Updates:
  - Cart icon updates to show the number of items.
  - User can view the cart.

### 2. User Views the Cart

- Action: User navigates to the "Cart" page.
- API Call: `GET`: `/cart`
- Response:

  ```json
  {
    "id": "cart-456",
    "total_price": 50.0,
    "items": [
      {
        "productId": "123",
        "name": "Product Name",
        "price": 25.0,
        "quantity": 2,
        "sub_total": 50.0
      }
    ]
  }
  ```

- Frontend Updates:
  - Displays cart items with options to:
    - Increase/Decrease quantity (PATCH /cart/items/:id).
    - Remove items (DELETE /cart/items/:id).

### 3. User Proceeds to Checkout

- Action: Clicks "Checkout" button.
- API Call: `POST` `/orders`
- Payload:

  ```json
  {
    "cartId": "cart-456",
    "addressId": "addr-789",
    "paymentMethod": "credit_card"
  }
  ```

- Backend:
  - Validates stock availability.
  - Creates an order (orders table).
  - Moves items from cart_items to order_items.
  - Updates cart status to checked_out.
  - Returns order details.
- Response:

  ```jsn
      {
        "orderId": "order-001",
        "status": "pending",
        "total_price": 50.0
      }
  ```

- Frontend Updates:
  - Redirects to Order Confirmation page.

### 4. User Makes Payment

- Action: User selects a payment method and pays.
- API Call: `POST` `/payments`
- Payload:

  ```json
  {
    "orderId": "order-001",
    "paymentMethod": "credit_card"
  }
  ```

- Backend:
  - Processes payment.
  - Updates order.status to "confirmed" if successful.
- Response:

  ```json
  {
    "orderId": "order-001",
    "status": "confirmed"
  }
  ```

- Frontend Updates:
  - Shows Order Confirmation page.
  - Updates order status to Confirmed.

## 5. Vendor Ships the Order

- Backend Process:
  - Vendor sees the confirmed order (GET /vendor/orders).
  - Ships it and updates order.status = "shipped".
- Frontend Updates:
  - User can track order status (`GET`: `/orders/:id`).
  - Shows `"Shipped"` status.

## 6. Order is Delivered

- Vendor updates order to delivered.
- User gets a notification.
- User can:
  - Mark it as received.
  - Leave a review.
</file>

<file path="check-out-flow.md">
# Checkout Flow in E-Commerce API

## 1. Validate Stock Availability

### Why?

Before proceeding with the order, the system needs to check if the products in the cart are still available in stock.

### How?

- The backend fetches all cart items:  
  **SQL Query:**

  ```sql
  SELECT product_id, quantity FROM cart_items WHERE cart_id = 'cart-456';
  ```

- It then verifies each product’s stock in the `products` table:  
  **SQL Query:**

  ```sql
  SELECT id, stock FROM products WHERE id IN ('prod-123', 'prod-456');
  ```

- If any product has insufficient stock:

  - The checkout process stops.
  - The system returns an **error message**:

    ```json
    {
      "error": "Product 'Product Name' is out of stock."
    }
    ```

- If stock is available:

  - The system **reserves the stock** by reducing the quantity temporarily.
  - **Stock update query**:

    ```sql
    UPDATE products
    SET stock = stock - 2
    WHERE id = 'prod-123';
    ```

---

## 2. Create an Order in `orders` Table

### Why?

Once stock is validated, the system needs to create a record for this purchase.

### How?

- The backend inserts a new record in the `orders` table:

  ```sql
  INSERT INTO orders (id, user, vendor, address, total_price, status, createDate)
  VALUES ('order-001', 'user-789', 'vendor-321', 'addr-456', 50.0, 'pending', NOW());
  ```

- The order starts in the **`pending`** status.

---

## 3. Move Items from `cart_items` to `order_items`

### Why?

Now that an order is created, we need to **associate** the cart items with the order and move them to the `order_items` table.

### How?

- The backend **copies** items from `cart_items` to `order_items`:

  ```sql
  INSERT INTO order_items (id, order, product, price, quantity, sub_total, createDate)
  SELECT uuid_generate_v4(), 'order-001', product, price, quantity, (price * quantity), NOW()
  FROM cart_items
  WHERE cart_id = 'cart-456';
  ```

- After copying, the **cart no longer needs these items**, so they are deleted:

  ```sql
  DELETE FROM cart_items WHERE cart_id = 'cart-456';
  ```

---

## 4. Update Cart Status to `checked_out`

### Why?

Now that the cart items have been **moved to an order**, the cart should no longer be active.

### How?

- The backend updates the cart’s status:

  ```sql
  UPDATE carts
  SET status = 'checked_out'
  WHERE id = 'cart-456';
  ```

---

## 5. Return Order Details to Frontend

### Why?

Now that the order is created, the frontend needs to **display the order confirmation**.

### How?

- The backend sends back order details:

  ```json
  {
    "orderId": "order-001",
    "status": "pending",
    "total_price": 50.0
  }
  ```

- The frontend **redirects the user** to the order confirmation page:
  - Shows `Order #001`
  - Displays the total price
  - Provides a "Proceed to Payment" button

---

## 6. Payment Process and Order Fulfillment

### Why?

After checkout, the user needs to pay for the order, and the system must process the fulfillment steps.

### How?

1. **User selects a payment method and initiates payment.**

   - The system creates a record in the `payments` table:

     ```sql
     INSERT INTO payments (id, amount, status, orderId, createdAt)
     VALUES ('payment-001', 50.0, 'pending', 'order-001', NOW());
     ```

   - The frontend redirects the user to the payment gateway.

2. **Payment is processed.**

   - If payment **succeeds**, update the payment status:

     ```sql
     UPDATE payments SET status = 'completed', updatedAt = NOW() WHERE id = 'payment-001';
     ```

   - Also update the order status:

     ```sql
     UPDATE orders SET status = 'confirmed' WHERE id = 'order-001';
     ```

   - The user receives a confirmation message.
   - If payment **fails**, update the payment status:

     ```sql
     UPDATE payments SET status = 'failed', updatedAt = NOW() WHERE id = 'payment-001';
     ```

   - The order remains in `pending`, prompting the user to retry.

3. **Vendor receives order confirmation.**

   - The system notifies the vendor to prepare for shipping.
   - Vendor updates the order status when ready for shipment:

     ```sql
     UPDATE orders SET status = 'shipped' WHERE id = 'order-001';
     ```

4. **Order is delivered to the customer.**

   - The delivery service updates tracking.
   - Once delivered, the status updates:

     ```sql
     UPDATE orders SET status = 'delivered' WHERE id = 'order-001';
     ```

   - The user is notified of successful delivery.

5. **User can request returns or refunds.**

   - If eligible, the user initiates a return request.
   - Admin/vendor processes the return:

     ```sql
     UPDATE orders SET status = 'returned' WHERE id = 'order-001';
     ```

   - If refunded, the payment is reversed, and status updates:

     ```sql
     UPDATE orders SET status = 'refunded' WHERE id = 'order-001';
     UPDATE payments SET status = 'refunded', updatedAt = NOW() WHERE orderId = 'order-001';
     ```

---

## Alternative Flows

- **User Cancels Order**: `PATCH /orders/:id → { "status": "cancelled" }`
- **User Requests a Return**: `PATCH /orders/:id → { "status": "returned" }`
- **Refund is Processed** if return is approved.
- **User retries failed payment**: `PATCH /payments/:id → { "status": "pending" }`

This ensures a smooth checkout experience while maintaining data integrity and stock consistency.
</file>

<file path="db-diagram.txt">
Project nestjs_ecommerce_api {
  database_type: 'PostgreSQL'
  Note: 'Nest.js e-commerce api'
}

enum user_roles {
  admin [note: "Have full control, manage users, vendors, and orders."]
  customer [note: "Can browse products, add to cart, place orders, and leave reviews."]
  vendor [note: "Can manage products, view orders, track payouts."]
}

enum user_status {
  active
  inactive
  banned
}

Table user {
  id uuid [pk, not null]
  first_name varchar [not null, note: "first name of the user"]
  last_name varchar [not null, note: 'last name of the user']
  email varchar [null, note: "email of ther user"]
  phone_number varchar [unique, not null]
  password  varchar [not null]
  profile_picture varchar [null, default: "default user avatar"]
  role user_roles [not null, note: "user role"]
  status user_status [not null, note: "Account status."]

  vendor uuid [null, note: "Every vendor is a user, but not every user is a vendor."]
  addresses uuid [not null]
  orders uuid [null, note: " A user can place multiple orders."]
  carts uuid [null, note: 'user can have a cart.']

  createDate timestamp
  updateDate timestamp
}

enum vendor_status {
  // User signs up as a vendor (linked to users table).
  pending [note: "Admin reviews application (status = 'pending')."]
  approved [note: "Approval"]
  suspended [note: "Rejection"]
}

Ref user_vendors: user.vendor - vendors.user
Table vendors {
  id uuid [pk, not null]
  business_name varchar [not null, note: "Vendor's store name."]
  business_email	varchar [unique, not null, note: "Contact email for the business."]
  phone_number	varchar	[not null, unique, note: "Business phone number."]
// address Vendor’s physical address.
  logo_url	varchar [null, default: "default logo url", note: "Vendor’s store logo (image link)."]
  status	vendor_status [not null, note: "Vendor’s approval status."]

  user uuid [not null]
  addresses uuid [not null]
  products uuid [null]
  orders uuid [null, note: 'Vendors fulfill multiple orders.']

  createDate timestamp
  updateDate timestamp
}

enum address_type {
  business [note: "Business Address → Vendor’s store or warehouse location."]
  shipping [note: "Shipping Address → Customer’s delivery address.."]
}

Ref: user.addresses < addresses.user
Ref: vendors.addresses < addresses.vendor
Table addresses {
  id uuid [pk, not null]
  street varchar [not null, note: "street address"]
  city varchar [not null, note: 'city name']
  zip_code varchar [null, note: 'postal code']
  country varchar [not null, note: 'country name']
  latitude float [null, note:   "geolocation - latitude"]
  longitude float [null, note:   "geolocation - longitude"]
  is_default bool [default: false]
  type address_type [not null]

  user uuid [null, note: "Links the address to a user."]
  vendor uuid [null, note: "Links to a vendor if it's a business address"]

  createDate timestamp
  updateDate timestamp 
}

enum category_status {
  active
  inactive
}
Table categories {
  id uuid [pk, not null]
  name varchar [not null, note: "Category name (e.g., Fruits, Vegetables, Organic)."]
  slug varchar [unique, not null, note: "URL-friendly version of the name (e.g., fruits, organic-vegetables)."]
  image_url varchar [null, note: "Optional category image."]
  status category_status [not null, default: "active", note: "Determines if the category is available."]

  parent_id uuid [null, note: "For subcategories (e.g., \"Citrus\" under \"Fruits\")."]
  products uuid [null, note: "referece to an array product ids."]

  createDate timestamp
  updateDate timestamp 
  deleteDate timestamp [note: "their wil be soft delete"]
}

enum product_status {
  active
  inactive
  out_of_stock
}

Ref vendor_products: vendors.products < products.vendor
Ref category_products: categories.products <> products.category
Table products {
  id uuid [pk, not null]
  name varchar [not null, note: "Product name (e.g., \"Fresh Mangoes\")."]
  description varchar [not null, note: "Detailed product description."]
  price float [not null, note: "Price per unit (e.g., per kg, per piece)."]
  discount_price float [not null, note: "Optional discount price."]
  unit varchar [not null, note: "Measurement unit (e.g., kg, lb, bunch)."]
  stock integer [not null, default: 0, note: "Available quantity in stock."]
  image_url varchar [not null, note: 'product image']
  status product_status [not null, note: "Product availability."]

  vendor uuid [not null, note: "The vendor selling this product."]
  category uuid [not null, note: "Category the product belongs to."]
  order_itmes uuid [null, note: 'Each order contains multiple products.']

  createDate timestamp
  updateDate timestamp 
}

enum CartStatus {
  ACTIVE          // Cart is in use, items can be added or removed
  CHECKED_OUT     // Cart has been converted into an order
  ABANDONED       // Cart was left without checkout
  EXPIRED         // Cart was abandoned and expired after a certain period
}

Ref: user.carts < carts.user
Ref: carts.cart_items < cart_items.cart
Ref: cart_items.product - products.id

Table carts {
// The carts table tracks products added by users before they proceed to checkout.
  id uuid [pk, not null]

  user uuid [not null, note: "User who owns the cart."]
  cart_items uuid [not null, note: "A cart contains multiple items."]
  
  total_price float [not null, default: 0, note: "Total price of all items in the cart."]
  status varchar [not null, default: 'active', note: "Cart status (e.g., active, checked_out, abandoned)."]

  createDate timestamp
  updateDate timestamp
}

Table cart_items {
  id uuid [pk, not null]

  cart uuid [not null, note: "Reference to the cart."]
  product uuid [not null, note: "Product added to the cart."]

  price float [not null, note: "Price per unit at the time of adding to cart."]
  quantity integer [not null, note: "Number of units added to the cart."]
  sub_total float [not null, note: "price * quantity."]

  createDate timestamp
  updateDate timestamp
}


enum order_status {
  pending
  delivered
  cancelled
}
Ref: user.orders < orders.user
Ref: vendors.orders < orders.vendor
Ref: orders.address - addresses.id
Table orders {
// The orders table will store customer purchases, tracking their status from placement to delivery.
  id uuid [pk, not null]
  user uuid [not null, note: "Customer who placed the order."]
  vendor uuid [not null, note: "The vendor fulfilling the order."]
  address uuid [not null, note: "Shipping/delivery address."]
  order_items uuid [not null, note: "An order contains multiple items."]

  total_price float [not null, note: "Final amount (including discounts & delivery fees)."]
  status varchar

  createDate timestamp
  updateDate timestamp 
}

Ref: orders.order_items < order_items.order
Ref: order_items.product - products.id
Table order_items {
  id uuid [pk, not null]

  order uuid [not null, note: "Reference to the order."]
  product uuid [not null, note: 'The purchased product.']

  price float [not null, note: "Price per unit at purchase time."]
  quantity integer [not null, note: "Number of units ordered."]
  sub_total float [not null, note: "price * quantity."]

  createDate timestamp
  updateDate timestamp 
}

enum payment_status {
  pending
  paid
}
Ref: payments.order - orders.id // One-to-One (orders → payments) → Each order has one payment record.
Ref: payments.user > user.id // One-to-Many (users → payments) → A user can have multiple payments.
Ref: payments.vendor > vendors.id // One-to-Many (vendors → payments) → Vendors receive multiple payments.
Table payments {
  id uuid [pk, not null]
  order uuid [not null, note: "The order linked to this payment"]
  user uuid [not null, note: "The customer making the payment."]
  vendor uuid [not null, note: "The vendor receiving the payment."]

  amount float [not null, note: "Total amount paid."]
  payment_status payment_status [not null, note: "Status of the payment."]
  transaction_id varchar [not null, note: 'External payment gateway transaction ID.']

  createDate timestamp
  updateDate timestamp 
}

// Table shipping_addresses {
//   id uuid [pk, not null]
// }

/*
1. Main Categories & Subcategories
🍎 Fruits

    Citrus Fruits → Oranges, Lemons, Limes, Grapefruits
    Berries → Strawberries, Blueberries, Raspberries, Blackberries
    Tropical Fruits → Mangoes, Pineapples, Bananas, Papayas
    Stone Fruits → Peaches, Cherries, Plums, Apricots
    Melons → Watermelon, Cantaloupe, Honeydew

🥕 Vegetables

    Leafy Greens → Spinach, Kale, Lettuce, Cabbage
    Root Vegetables → Carrots, Potatoes, Beets, Radishes
    Cruciferous Vegetables → Broccoli, Cauliflower, Brussels Sprouts
    Gourds & Squashes → Pumpkin, Zucchini, Butternut Squash
    Alliums → Onions, Garlic, Leeks, Shallots

🥛 Dairy & Eggs

    Milk & Alternatives → Cow’s Milk, Almond Milk, Soy Milk
    Cheese → Cheddar, Mozzarella, Feta, Parmesan
    Eggs → Chicken Eggs, Duck Eggs, Quail Eggs
    Yogurt & Butter → Greek Yogurt, Plain Yogurt, Butter

🥩 Meat & Seafood (If applicable)

    Fresh Meat → Beef, Chicken, Lamb, Pork
    Seafood → Fish, Shrimp, Crab, Lobster

🍞 Grains & Staples

    Flour & Rice → White Rice, Brown Rice, Wheat Flour, Corn Flour
    Pasta & Noodles → Spaghetti, Macaroni, Ramen
    Bread & Bakery → Baguettes, Sandwich Bread, Whole Wheat

🛒 Organic & Specialty Foods

    Organic Fruits & Vegetables → Certified organic produce
    Gluten-Free Products → Gluten-free bread, pasta, flour
    Vegan & Plant-Based → Plant-based meat alternatives, Tofu
*/
</file>

<file path="db.md">
```ts

Project nestjs_ecommerce_api {
  database_type: 'PostgreSQL'
  Note: 'Nest.js e-commerce api'
}

enum user_roles {
  admin [note: "Have full control, manage users, vendors, and orders."]
  customer [note: "Can browse products, add to cart, place orders, and leave reviews."]
  vendor [note: "Can manage products, view orders, track payouts."]
}

enum user_status {
  active
  inactive
  banned
  deleted
}

Table user {
  id uuid [pk, not null]
  first_name varchar [not null, note: "first name of the user"]
  last_name varchar [not null, note: 'last name of the user']
  email varchar [null, note: "email of ther user"]
  phone_number varchar [unique, not null]
  password  varchar [not null]
  profile_picture varchar [null, default: "default user avatar"]
  role user_roles [not null, note: "user role"]
  status user_status [not null, note: "Account status."]

  vendor uuid [null, note: "Every vendor is a user, but not every user is a vendor."]
  addresses uuid [not null]
  orders uuid [null, note: " A user can place multiple orders."]
  carts uuid [null, note: 'user can have a cart.']

  createDate timestamp
  updateDate timestamp
}

enum vendor_status {
  // User signs up as a vendor (linked to users table).
  pending [note: "Admin reviews application (status = 'pending')."]
  approved [note: "Approval"]
  suspended [note: "Rejection"]
}

Ref user_vendors: user.vendor - vendors.user
Table vendors {
  id uuid [pk, not null]
  business_name varchar [not null, note: "Vendor's store name."]
  business_email varchar [unique, not null, note: "Contact email for the business."]
  phone_number varchar [not null, unique, note: "Business phone number."]
// address Vendor’s physical address.
  logo_url varchar [null, default: "default logo url", note: "Vendor’s store logo (image link)."]
  status vendor_status [not null, note: "Vendor’s approval status."]

  user uuid [not null]
  addresses uuid [not null]
  products uuid [null]
  orders uuid [null, note: 'Vendors fulfill multiple orders.']

  createDate timestamp
  updateDate timestamp
}

enum address_type {
  business [note: "Business Address → Vendor’s store or warehouse location."]
  shipping [note: "Shipping Address → Customer’s delivery address.."]
}

Ref: user.addresses < addresses.user
Ref: vendors.addresses < addresses.vendor
Table addresses {
  id uuid [pk, not null]
  street varchar [not null, note: "street address"]
  city varchar [not null, note: 'city name']
  zip_code varchar [null, note: 'postal code']
  country varchar [not null, note: 'country name']
  latitude float [null, note:   "geolocation - latitude"]
  longitude float [null, note:   "geolocation - longitude"]
  is_default bool [default: false]
  type address_type [not null]

  user uuid [null, note: "Links the address to a user."]
  vendor uuid [null, note: "Links to a vendor if it's a business address"]

  createDate timestamp
  updateDate timestamp
}

enum category_status {
  active
  inactive
}
Table categories {
  id uuid [pk, not null]
  name varchar [not null, note: "Category name (e.g., Fruits, Vegetables, Organic)."]
  slug varchar [unique, not null, note: "URL-friendly version of the name (e.g., fruits, organic-vegetables)."]
  image_url varchar [null, note: "Optional category image."]
  status category_status [not null, default: "active", note: "Determines if the category is available."]

  parent_id uuid [null, note: "For subcategories (e.g., \"Citrus\" under \"Fruits\")."]
  products uuid [null, note: "referece to an array product ids."]

  createDate timestamp
  updateDate timestamp
  deleteDate timestamp [note: "their wil be soft delete"]
}

enum product_status {
  active
  inactive
  out_of_stock
}

Ref vendor_products: vendors.products < products.vendor
Ref category_products: categories.products <> products.category
Table products {
  id uuid [pk, not null]
  name varchar [not null, note: "Product name (e.g., \"Fresh Mangoes\")."]
  description varchar [not null, note: "Detailed product description."]
  price float [not null, note: "Price per unit (e.g., per kg, per piece)."]
  discount_price float [not null, note: "Optional discount price."]
  unit varchar [not null, note: "Measurement unit (e.g., kg, lb, bunch)."]
  stock integer [not null, default: 0, note: "Available quantity in stock."]
  image_url varchar [not null, note: 'product image']
  status product_status [not null, note: "Product availability."]

  vendor uuid [not null, note: "The vendor selling this product."]
  category uuid [not null, note: "Category the product belongs to."]
  order_itmes uuid [null, note: 'Each order contains multiple products.']

  createDate timestamp
  updateDate timestamp
}



enum CartStatus {
  ACTIVE          // Cart is in use, items can be added or removed
  CHECKED_OUT     // Cart has been converted into an order
  ABANDONED       // Cart was left without checkout
  EXPIRED         // Cart was abandoned and expired after a certain period
}

Ref: user.carts < carts.user
Ref: carts.cart_items < cart_items.cart
Ref: cart_items.product - products.id

Table carts {
// The carts table tracks products added by users before they proceed to checkout.
  id uuid [pk, not null]

  user uuid [not null, note: "User who owns the cart."]
  cart_items uuid [not null, note: "A cart contains multiple items."]

  total_price float [not null, default: 0, note: "Total price of all items in the cart."]
  status varchar [not null, default: 'active', note: "Cart status (e.g., active, checked_out, abandoned)."]

  createDate timestamp
  updateDate timestamp
}

Table cart_items {
  id uuid [pk, not null]

  cart uuid [not null, note: "Reference to the cart."]
  product uuid [not null, note: "Product added to the cart."]

  price float [not null, note: "Price per unit at the time of adding to cart."]
  quantity integer [not null, note: "Number of units added to the cart."]
  sub_total float [not null, note: "price * quantity."]

  createDate timestamp
  updateDate timestamp
}

export enum OrderStatus {
  PENDING = 'pending',          // Order has been placed but not yet processed
  CONFIRMED = 'confirmed',      // Order has been confirmed by the vendor
  SHIPPED = 'shipped',          // Order has been shipped to the customer
  DELIVERED = 'delivered',      // Order has been successfully delivered
  CANCELLED = 'cancelled',      // Order was canceled before fulfillment
  RETURNED = 'returned',        // Customer returned the order
  REFUNDED = 'refunded',        // Payment has been refunded
}
Ref: user.orders < orders.user
Ref: vendors.orders < orders.vendor
Ref: orders.address - addresses.id
Table orders {
// The orders table will store customer purchases, tracking their status from placement to delivery.
  id uuid [pk, not null]
  user uuid [not null, note: "Customer who placed the order."]
  vendor uuid [not null, note: "The vendor fulfilling the order."]
  address uuid [not null, note: "Shipping/delivery address."]
  order_items uuid [not null, note: "An order contains multiple items."]

  total_price float [not null, note: "Final amount (including discounts & delivery fees)."]
  status varchar

  createDate timestamp
  updateDate timestamp
}

Ref: orders.order_items < order_items.order
Ref: order_items.product - products.id
Table order_items {
  id uuid [pk, not null]

  order uuid [not null, note: "Reference to the order."]
  product uuid [not null, note: 'The purchased product.']

  price float [not null, note: "Price per unit at purchase time."]
  quantity integer [not null, note: "Number of units ordered."]
  sub_total float [not null, note: "price * quantity."]

  createDate timestamp
  updateDate timestamp
}

enum payment_status {
  pending
  paid
}
Ref: payments.order - orders.id // One-to-One (orders → payments) → Each order has one payment record.
Ref: payments.user > user.id // One-to-Many (users → payments) → A user can have multiple payments.
Ref: payments.vendor > vendors.id // One-to-Many (vendors → payments) → Vendors receive multiple payments.
Table payments {
  id uuid [pk, not null]
  order uuid [not null, note: "The order linked to this payment"]
  user uuid [not null, note: "The customer making the payment."]
  vendor uuid [not null, note: "The vendor receiving the payment."]

  amount float [not null, note: "Total amount paid."]
  payment_status payment_status [not null, note: "Status of the payment."]
  transaction_id varchar [not null, note: 'External payment gateway transaction ID.']

  createDate timestamp
  updateDate timestamp
}

// Table shipping_addresses {
//   id uuid [pk, not null]
// }

/*
1. Main Categories & Subcategories
🍎 Fruits

    Citrus Fruits → Oranges, Lemons, Limes, Grapefruits
    Berries → Strawberries, Blueberries, Raspberries, Blackberries
    Tropical Fruits → Mangoes, Pineapples, Bananas, Papayas
    Stone Fruits → Peaches, Cherries, Plums, Apricots
    Melons → Watermelon, Cantaloupe, Honeydew

🥕 Vegetables

    Leafy Greens → Spinach, Kale, Lettuce, Cabbage
    Root Vegetables → Carrots, Potatoes, Beets, Radishes
    Cruciferous Vegetables → Broccoli, Cauliflower, Brussels Sprouts
    Gourds & Squashes → Pumpkin, Zucchini, Butternut Squash
    Alliums → Onions, Garlic, Leeks, Shallots

🥛 Dairy & Eggs

    Milk & Alternatives → Cow’s Milk, Almond Milk, Soy Milk
    Cheese → Cheddar, Mozzarella, Feta, Parmesan
    Eggs → Chicken Eggs, Duck Eggs, Quail Eggs
    Yogurt & Butter → Greek Yogurt, Plain Yogurt, Butter

🥩 Meat & Seafood (If applicable)

    Fresh Meat → Beef, Chicken, Lamb, Pork
    Seafood → Fish, Shrimp, Crab, Lobster

🍞 Grains & Staples

    Flour & Rice → White Rice, Brown Rice, Wheat Flour, Corn Flour
    Pasta & Noodles → Spaghetti, Macaroni, Ramen
    Bread & Bakery → Baguettes, Sandwich Bread, Whole Wheat

🛒 Organic & Specialty Foods

    Organic Fruits & Vegetables → Certified organic produce
    Gluten-Free Products → Gluten-free bread, pasta, flour
    Vegan & Plant-Based → Plant-based meat alternatives, Tofu
*/

```
</file>

<file path="nest-cli.json">
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}
</file>

<file path="order-related-endpoints.md">
---

# 🧾 Orders API – Endpoint Reference

This document outlines the essential and recommended API endpoints for managing orders in a multi-vendor eCommerce system.

---

## ✅ Essential Order Endpoints

### 1. **Get All Orders for a User (List Orders)**

`GET /orders`

- **Description**: Fetch all orders made by the authenticated user.
- **Query params**: Optional filters (`status`, `date range`, etc.)
- **Auth**: User

---

### 2. **Get Single Order (Order Details)**

`GET /orders/:id`

- **Description**: Retrieve details of a specific order including order items and shipping address.
- **Auth**: User (must own the order)

---

## 🔐 Admin/Vendor Related Endpoints

### 3. **Get All Orders (Admin/Vendor Panel)**

`GET /admin/orders`

- **Description**: Fetch all orders placed in the system.
- **Query params**:
  - `vendorId`
  - `status`
  - `date range`
  - `userId`
- **Auth**: Admin or Vendor

---

### 4. **Update Order Status**

`PATCH /orders/:id/status`

- **Description**: Update the order status to next stage in the lifecycle.
- **Status flow**:
  - `PENDING` → `CONFIRMED`
  - `CONFIRMED` → `SHIPPED`
  - `SHIPPED` → `DELIVERED`
  - `DELIVERED` → `COMPLETED`
- **Auth**: Admin or Vendor

---

## 🛑 Optional but Useful

### 5. **Cancel Order**

`PATCH /orders/:id/cancel`

- **Description**: Cancel an order before it is shipped.
- **Side Effects**:
  - Revert stock
  - Update order status to `CANCELLED`
- **Auth**: User (if order not shipped), Admin

---

### 6. **Track Order**

`GET /orders/:id/track`

- **Description**: View order tracking information (status history, estimated delivery).
- **Auth**: User (must own the order)

---

## 💳 Payment Related Endpoints

### 7. **Mark Order as Paid**

`POST /orders/:id/pay`

- **Description**: Mark an order as paid after successful payment.
- **Used by**:
  - Payment gateway callback/webhook
  - Client-side confirmation
- **Updates**:
  - `status: PAID`
  - Save `payment_reference`
  - Set `paidAt` timestamp
- **Auth**: System or Client (with verification)

---

## 🚦 Suggested Flow (Before Payment Integration)

1. ✅ **Checkout** – creates vendor-split orders from cart.
2. 🕒 **Orders are created with `PENDING` status**.
3. 💰 **Payment is processed externally**.
4. ✅ **After payment**, use `/orders/:id/pay` to confirm.

---
</file>

<file path="package.json">
{
  "name": "multi-vendor-marketplace-backend",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  },
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "doc": "npx @compodoc/compodoc -p tsconfig.json -s --port 3001 --watch -d ./documentation",
    "test:e2e": "jest --config ./test/jest-e2e.json"
  },
  "dependencies": {
    "@compodoc/compodoc": "^1.1.26",
    "@nestjs/common": "^10.0.0",
    "@nestjs/config": "^4.0.2",
    "@nestjs/core": "^10.0.0",
    "@nestjs/jwt": "^11.0.0",
    "@nestjs/mapped-types": "*",
    "@nestjs/platform-express": "^10.0.0",
    "@nestjs/swagger": "^11.1.0",
    "@prisma/client": "^6.7.0",
    "bcryptjs": "^3.0.2",
    "chapa-nestjs": "^1.3.1",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "cookie-parser": "^1.4.7",
    "google-auth-library": "^9.15.1",
    "helmet": "^8.1.0",
    "joi": "^17.13.3",
    "nestjs-pino": "^4.4.0",
    "nodemailer": "^7.0.3",
    "pino-http": "^10.4.0",
    "prisma": "^6.5.0",
    "reflect-metadata": "^0.2.0",
    "rxjs": "^7.8.1",
    "slugify": "^1.6.6",
    "twilio": "^5.6.1",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.0.0",
    "@types/bcryptjs": "^3.0.0",
    "@types/cookie-parser": "^1.4.8",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.2",
    "@types/multer": "^1.4.12",
    "@types/node": "^20.3.1",
    "@types/nodemailer": "^6.4.17",
    "@types/supertest": "^6.0.0",
    "@typescript-eslint/eslint-plugin": "^8.0.0",
    "@typescript-eslint/parser": "^8.0.0",
    "eslint": "^8.42.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "jest": "^29.5.0",
    "pino-pretty": "^13.0.0",
    "prettier": "^3.0.0",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.1.0",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}
</file>

<file path="README.md">
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ pnpm install
```

## Compile and run the project

```bash
# development
$ pnpm run start

# watch mode
$ pnpm run start:dev

# production mode
$ pnpm run start:prod
```

## Run tests

```bash
# unit tests
$ pnpm run test

# e2e tests
$ pnpm run test:e2e

# test coverage
$ pnpm run test:cov
```

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).
</file>

<file path="todo.md">
### TODO's

- [] ParseUUIDPipe every uuid param
- [] category resource - add a route to in-activate the category or update the category status on delete category instead of destroying the doc
- [] products table add multiple image for a product instead of one image
- [] change the relation names on the foreign key (categories, cartItems, orders, orderItems)
- [] Add currency if multi-currency support is expected.
- [] on products model Add a slug field for SEO-friendly URLs
- [] update on orders model
  - [] Add shipping_fee, tax, discount, etc.
  - [] Add tracking_number or shipping provider fields.
  - [] Add note field for buyer instructions.
- [] Add analytics tables later (e.g., product views, abandoned carts).
- [] Add a wishlist table for users to save products for later.
- [] Add a reviews table for users to leave feedback on products.
</file>

<file path="tsconfig.build.json">
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false
  }
}
</file>

</files>
